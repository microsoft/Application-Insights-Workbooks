{
  "version": "Notebook/1.0",
  "items": [
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "448a29bd-9c86-4cc9-b114-e89eb4532388",
            "version": "KqlParameterItem/1.0",
            "name": "qdsStartTime",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"union\\r\\n(\\r\\n// The most recent interval that is earlier than the end of time range.\\r\\n// This may be earlier than the start of time range by at most 2h.\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_start_time between (({timeRange:start} - 2h) .. {timeRange:end})\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| summarize interval_start_time = max(interval_start_time)\\r\\n),\\r\\n(\\r\\n// earliest interval start within time range\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time >= {timeRange:start} and interval_start_time <= {timeRange:end}\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| summarize interval_start_time = min(interval_start_time)\\r\\n)\\r\\n// return the earliest of these times as start of QDS range\\r\\n// if there isn't a complete QDS interval within time range, this will show the most recent available interval outside of the range\\r\\n| summarize qds_start_time = min(interval_start_time)\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "queryType": 9
          },
          {
            "id": "ea6d3fd1-3d78-43af-99a7-f138bdece7b6",
            "version": "KqlParameterItem/1.0",
            "name": "qdsEndTime",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"union\\r\\n(\\r\\n// The most recent interval that is earlier than the end of time range.\\r\\n// This may be earlier than the start of time range by at most 2h.\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time between (({timeRange:start} - 2h) .. {timeRange:end})\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| summarize interval_end_time = max(interval_end_time)\\r\\n),\\r\\n(\\r\\n// latest interval end within time range\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time >= {timeRange:start} and interval_start_time <= {timeRange:end}\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| summarize interval_end_time = max(interval_end_time)\\r\\n)\\r\\n// return the latest of these times as end of QDS range\\r\\n// if there isn't a complete QDS interval within time range, this will show the latest available interval\\r\\n| summarize qds_end_time = datetime_add(\\\"second\\\", 1, max(interval_end_time)) // make-series treats the end of interval as not inclusive, fudge by 1 second\\r\\n\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "queryType": 9
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "name": "top_query_qds_time_parameters"
    },
    {
      "type": 1,
      "content": {
        "json": "A top query is defined as a query consuming the most resources in a time interval. Resource consumption is reflected by metrics such as _execution count_, _CPU time_, _duration_, _logical reads_, etc. For each top query, choosing an aggregation type lets you see its _total_, _average_, _minimum_, or _maximum_ resource consumption within the selected time interval.\r\n\r\nQuery Store aggregates and stores data using fixed time intervals. Query statistics are collected and displayed for complete intervals only. Because of this, top query data may be delayed. For example, if Query Store interval length is one hour (which is the default configuration), then it will take at least one hour for the most recent query data to become available.\r\n\r\nTop query data is obtained from [Query Store](https://go.microsoft.com/fwlink/?linkid=2213253), using [sys.query_store_query](https://go.microsoft.com/fwlink/?linkid=2213428), [sys.query_store_query_text](https://go.microsoft.com/fwlink/?linkid=2213154), [sys.query_store_plan](https://go.microsoft.com/fwlink/?linkid=2213251), [sys.query_store_runtime_stats](https://go.microsoft.com/fwlink/?linkid=2213252), [sys.query_store_wait_stats](https://go.microsoft.com/fwlink/?linkid=2213155), and other views."
      },
      "conditionalVisibilities": [
        {
          "parameterName": "showDescriptions",
          "comparison": "isEqualTo",
          "value": "true"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_help"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "e7bd7068-660b-41bd-894d-b6008ac6e4ca",
            "version": "KqlParameterItem/1.0",
            "name": "qdsAggregation",
            "label": "Aggregation",
            "type": 2,
            "description": "Select the type of aggregation to use for query runtime statistics",
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n    {\"value\":\"total\",\"label\":\"Total\"},\r\n    {\"value\":\"avg\",\"label\":\"Average\"},\r\n    {\"value\":\"max\",\"label\":\"Maximum\"},\r\n    {\"value\":\"min\",\"label\":\"Minimum\"},\r\n    {\"value\":\"stdev\",\"label\":\"Standard deviation\"}\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "total"
          },
          {
            "id": "d78e016e-7f9c-4ddb-be50-9cc3317387b6",
            "version": "KqlParameterItem/1.0",
            "name": "qdsMetric",
            "label": "Metric",
            "type": 2,
            "description": "Find top queries sorting by selected metric in descending order",
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n    {\"value\":\"count_executions\",\"label\":\"Execution count\"},\r\n    {\"value\":\"duration\",\"label\":\"Duration\"},\r\n    {\"value\":\"cpu_time\",\"label\":\"CPU time\"},\r\n    {\"value\":\"logical_io_reads\",\"label\":\"Logical reads\"},\r\n    {\"value\":\"logical_io_writes\",\"label\":\"Logical writes\"},\r\n    {\"value\":\"physical_io_reads\",\"label\":\"Physical reads (pages)\"},\r\n    {\"value\":\"num_physical_io_reads\",\"label\":\"Physical reads (IOs)\"},\r\n    {\"value\":\"clr_time\",\"label\":\"CLR time\"},\r\n    {\"value\":\"dop\",\"label\":\"DOP\"},\r\n    {\"value\":\"query_max_used_memory\",\"label\":\"Memory grant\"},\r\n    {\"value\":\"rowcount\",\"label\":\"Row count\"},\r\n    {\"value\":\"log_bytes_used\",\"label\":\"Transaction log space used\"},\r\n    {\"value\":\"tempdb_space_used\",\"label\":\"Tempdb space used\"}\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "cpu_time"
          },
          {
            "id": "45b94f24-7a79-4941-9036-2578462ffc96",
            "version": "KqlParameterItem/1.0",
            "name": "qdsTopQueryCount",
            "label": "Top query limit",
            "type": 2,
            "description": "The number of top queries to display",
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n    {\"value\":5,\"label\":\"5\"},\r\n    {\"value\":10,\"label\":\"10\"},\r\n    {\"value\":25,\"label\":\"25\"},\r\n    {\"value\":50,\"label\":\"50\"},\r\n    {\"value\":100,\"label\":\"100\"},\r\n    {\"value\":200,\"label\":\"200\"}\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "10"
          },
          {
            "id": "a3523dda-4080-4f76-9e12-f6b835a09f56",
            "version": "KqlParameterItem/1.0",
            "name": "qdsExecutionType",
            "label": "Execution types",
            "type": 2,
            "description": "Select one or more query execution types",
            "isRequired": true,
            "multiSelect": true,
            "quote": "",
            "delimiter": ",",
            "typeSettings": {
              "additionalResourceOptions": [
                "value::all"
              ],
              "selectAllValue": "0,1,2,3,4",
              "showDefault": false
            },
            "jsonData": "[\r\n    {\"value\":\"0\",\"label\":\"Regular\"},\r\n    {\"value\":\"3\",\"label\":\"Aborted\"},\r\n    {\"value\":\"4\",\"label\":\"Exception\"}\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "defaultValue": "value::all",
            "value": [
              "value::all"
            ]
          },
          {
            "id": "e5d2125d-9a08-4eac-b8a9-d069885a44c2",
            "version": "KqlParameterItem/1.0",
            "name": "qdsSelectedDatabases",
            "label": "Databases",
            "type": 2,
            "description": "Select one or more databases",
            "multiSelect": true,
            "quote": "\"",
            "delimiter": ",",
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| summarize dcount_server_name = dcount(server_name),\\r\\n            any_server_name = take_any(server_name)\\r\\n  by database_name\\r\\n| project database_name, server_name_agg = strcat(database_name, \\\" on \\\", iif(dcount_server_name == 1, any_server_name, strcat(any_server_name, \\\" (+\\\", tostring(dcount_server_name - 1), \\\")\\\")))\\r\\n| top 200 by tolower(database_name) asc;\\r\\n\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "typeSettings": {
              "additionalResourceOptions": [
                "value::all"
              ],
              "selectAllValue": "[]",
              "showDefault": false
            },
            "queryType": 9,
            "value": [
              "value::all"
            ]
          },
          {
            "id": "bc7a7dae-4205-422c-9c5c-97b86ad051be",
            "version": "KqlParameterItem/1.0",
            "name": "qdsDatabaseNameFilter",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "qdsSelectedDatabases",
                  "operator": "is Empty",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "// no database_name filter"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsSelectedDatabases",
                  "operator": "isNotNull",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "| where database_name in ({qdsSelectedDatabases})"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "// no database_name filter"
                }
              }
            ]
          },
          {
            "id": "07f39986-d4e0-4205-b586-dc4924600e4d",
            "version": "KqlParameterItem/1.0",
            "name": "qdsQueryHash",
            "label": "Query hash",
            "type": 1,
            "description": "Enter a query hash to show top queries with that hash. This is an optional parameter.",
            "typeSettings": {
              "paramValidationRules": [
                {
                  "regExp": "\\\"",
                  "match": false,
                  "message": "Query hash filter value may not contain double quotes"
                }
              ]
            },
            "value": ""
          },
          {
            "id": "7917da4e-962c-4ce8-8296-e6f6f22e3992",
            "version": "KqlParameterItem/1.0",
            "name": "qdsQueryText",
            "label": "Query text",
            "type": 1,
            "description": "Enter a string to find queries with SQL text containing this string. This is an optional parameter.",
            "typeSettings": {
              "multiLineText": true,
              "editorLanguage": "sql",
              "multiLineHeight": 3
            },
            "value": ""
          },
          {
            "id": "5fdd560a-69f7-4aca-9dec-7d7b239f4bd3",
            "version": "KqlParameterItem/1.0",
            "name": "qdsMetricLabelMidsentenceCase",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "count_executions",
                  "resultValType": "static",
                  "resultVal": "execution count"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "duration",
                  "resultValType": "static",
                  "resultVal": "duration"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "cpu_time",
                  "resultValType": "static",
                  "resultVal": "CPU time"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "logical_io_reads",
                  "resultValType": "static",
                  "resultVal": "logical reads"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "logical_io_writes",
                  "resultValType": "static",
                  "resultVal": "logical writes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "physical_io_reads",
                  "resultValType": "static",
                  "resultVal": "physical reads (pages)"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "num_physical_io_reads",
                  "resultValType": "static",
                  "resultVal": "physical reads (IOs)"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "clr_time",
                  "resultValType": "static",
                  "resultVal": "CLR time"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "dop",
                  "resultValType": "static",
                  "resultVal": "DOP"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "query_max_used_memory",
                  "resultValType": "static",
                  "resultVal": "memory grant"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "rowcount",
                  "resultValType": "static",
                  "resultVal": "row count"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "log_bytes_used",
                  "resultValType": "static",
                  "resultVal": "transaction log space used"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "tempdb_space_used",
                  "resultValType": "static",
                  "resultVal": "tempdb space used"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "page_server_io_reads",
                  "resultValType": "static",
                  "resultVal": "page server reads (pages)"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "rightValType": "param",
                  "resultValType": "param"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "id": "13721e52-abef-4034-95e1-f7b0a13d12b3",
            "version": "KqlParameterItem/1.0",
            "name": "qdsMetricUnit",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "duration",
                  "resultValType": "static",
                  "resultVal": "time"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "cpu_time",
                  "resultValType": "static",
                  "resultVal": "time"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "clr_time",
                  "resultValType": "static",
                  "resultVal": "time"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "query_max_used_memory",
                  "resultValType": "static",
                  "resultVal": "bytes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "log_bytes_used",
                  "resultValType": "static",
                  "resultVal": "bytes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "qdsMetric",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "tempdb_space_used",
                  "resultValType": "static",
                  "resultVal": "bytes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "unitless"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "id": "cecbb02b-a14e-4650-9d82-d9487d339b38",
            "version": "KqlParameterItem/1.0",
            "name": "global_query_id",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "value": "{\"machine_name\":\"\",\"server_name\":\"\",\"database_name\":\"\",\"query_id\":0}"
          }
        ],
        "style": "pills",
        "queryType": 9
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "top_query_parameters"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "f0630d45-57bb-4eff-8761-fb757cd37f50",
            "version": "KqlParameterItem/1.0",
            "name": "showQueriesAs",
            "label": "Show queries as",
            "type": 10,
            "description": "Show queries as tiles or as a grid",
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n    {\"value\":\"tiles\",\"label\":\"Tiles\"},\r\n    {\"value\":\"grid\",\"label\":\"Grid\"}\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "tiles"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "customWidth": "20",
      "name": "show_query_as_parameters"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "list",
        "links": [
          {
            "id": "3e9f9a13-7df8-4327-b606-674ff483b05f",
            "cellValue": "",
            "linkTarget": "WorkbookTemplate",
            "linkLabel": "Top databases",
            "style": "secondary",
            "linkIsContextBlade": true,
            "workbookContext": {
              "componentIdSource": "workbook",
              "resourceIdsSource": "workbook",
              "templateIdSource": "static",
              "templateId": "Community-Workbooks/Database watcher/SQL Server/estate/top queries/top databases",
              "typeSource": "workbook",
              "gallerySource": "workbook",
              "locationSource": "default",
              "workbookName": "Top databases by total {qdsMetricLabelMidsentenceCase}"
            }
          },
          {
            "id": "71ac9443-fccd-4088-8448-59bb14fd1b02",
            "linkTarget": "WorkbookTemplate",
            "linkLabel": "Query Store intervals",
            "style": "secondary",
            "linkIsContextBlade": true,
            "workbookContext": {
              "componentIdSource": "workbook",
              "resourceIdsSource": "workbook",
              "templateIdSource": "static",
              "templateId": "Community-Workbooks/Database watcher/SQL Server/estate/top queries/query store intervals",
              "typeSource": "workbook",
              "gallerySource": "workbook",
              "locationSource": "default",
              "workbookName": "Query Store intervals"
            }
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "customWidth": "80",
      "name": "top_queries_context_pane_nav"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let max_missing_indexes_per_query_hash = 30;\\r\\n// The missing indexes table may not exist. Work around by using a same-schema stub in a fuzzy union.\\r\\nlet missing_indexes_stub = view() {\\r\\nprint query_hash = \\\"\\\", missing_index_label = \\\"\\\", create_index_statements = \\\"\\\"\\r\\n| where isnotempty(query_hash)\\r\\n};\\r\\nlet missing_indexes_table = view() {\\r\\nsqlserver_missing_indexes\\r\\n| where sample_time_utc >= todatetime(\\\"{qdsStartTime}\\\") and sample_time_utc <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where grain_type == \\\"query_plan\\\"\\r\\n// Use the last missing index sample within the QDS interval\\r\\n| summarize arg_max(sample_time_utc, schema_name, object_name, database_engine_start_time_utc, avg_user_impact, equality_columns, inequality_columns, included_columns, user_seeks, user_scans, last_user_seek_utc, last_user_scan_utc)\\r\\n            by machine_name, server_name, database_name, query_hash, query_plan_hash\\r\\n// Remove dups that may be present in different plans\\r\\n| summarize sample_time_utc = min(sample_time_utc),\\r\\n            database_engine_start_time_utc = min(database_engine_start_time_utc),\\r\\n            avg_user_impact = max(avg_user_impact),\\r\\n            user_seeks = sum(user_seeks),\\r\\n            user_scans = sum(user_scans),\\r\\n            last_user_seek_utc = max(last_user_seek_utc),\\r\\n            last_user_scan_utc = max(last_user_scan_utc),\\r\\n            query_plan_hash = take_any(query_plan_hash),\\r\\n            count_plans = dcount(query_plan_hash)\\r\\n            by machine_name, server_name, database_name, query_hash, schema_name, object_name, equality_columns, inequality_columns, included_columns\\r\\n| extend duration_since_startup_seconds = 1s * datetime_diff(\\\"second\\\", sample_time_utc, database_engine_start_time_utc),\\r\\n         query_plan_hash = iif(count_plans == 1, tostring(query_plan_hash), strcat(query_plan_hash, \\\" (+\\\", tostring(count_plans - 1), \\\")\\\"))\\r\\n| extend create_index_statement = strcat(\\r\\n\\\"/* \\\",\\r\\n\\\"\\\\r\\\\nMachine: \\\", machine_name,\\r\\n\\\"\\\\r\\\\nServer: \\\", server_name,\\r\\n\\\"\\\\r\\\\nDatabase: \\\", database_name,\\r\\n\\\"\\\\r\\\\nQuery hash: \\\", query_hash,\\r\\n\\\"\\\\r\\\\nQuery plan hash: \\\", query_plan_hash,\\r\\n\\\"\\\\r\\\\nAverage impact (%): \\\", avg_user_impact,\\r\\n\\\"\\\\r\\\\nSeeks: \\\", user_seeks,\\r\\n\\\"\\\\r\\\\nScans: \\\", user_scans,\\r\\n\\\"\\\\r\\\\nLast seek time (UTC): \\\", iif(isnotempty(last_user_seek_utc), format_datetime(last_user_seek_utc, \\\"yyyy-MM-dd HH:mm:ss.fff\\\"), \\\"N/A\\\"),\\r\\n\\\"\\\\r\\\\nLast scan time (UTC): \\\", iif(isnotempty(last_user_scan_utc), format_datetime(last_user_scan_utc, \\\"yyyy-MM-dd HH:mm:ss.fff\\\"), \\\"N/A\\\"),\\r\\n\\\"\\\\r\\\\nInterval duration: \\\", strcat(format_timespan(duration_since_startup_seconds, \\\"d\\\"), \\\" days, \\\", format_timespan(duration_since_startup_seconds, \\\"hh\\\"), \\\" hours, \\\", format_timespan(duration_since_startup_seconds, \\\"m\\\"), \\\" minutes\\\"),\\r\\n\\\"\\\\r\\\\n*/\\\",\\r\\n\\\"\\\\r\\\\nCREATE INDEX [replace-with-index-name] ON \\\", schema_name, \\\".\\\", object_name,\\r\\n\\\"\\\\r\\\\n(\\\",\\r\\niif(isnotempty(equality_columns), strcat(\\\"\\\\r\\\\n\\\", equality_columns, iif(isnotempty(inequality_columns), \\\",\\\", \\\"\\\"), \\\" /* equality columns */\\\"), \\\"\\\"),\\r\\niif(isnotempty(inequality_columns), strcat(\\\"\\\\r\\\\n\\\", inequality_columns, \\\" /* inequality columns */\\\"), \\\"\\\"),\\r\\n\\\"\\\\r\\\\n)\\\",\\r\\niif(isnotempty(included_columns), strcat(\\\"\\\\r\\\\nINCLUDE (\\\", included_columns, \\\")\\\"), \\\"\\\"),\\r\\n\\\"\\\\r\\\\nWITH /* Adjust index options as needed */\\\",\\r\\n\\\"\\\\r\\\\n(\\\",\\r\\n\\\"\\\\r\\\\nMAXDOP = 8,\\\",\\r\\n\\\"\\\\r\\\\nONLINE = ON (WAIT_AT_LOW_PRIORITY (MAX_DURATION = 5 MINUTES, ABORT_AFTER_WAIT = SELF)),\\\",\\r\\n\\\"\\\\r\\\\n-- RESUMABLE = ON,\\\",\\r\\n\\\"\\\\r\\\\n-- DATA_COMPRESSION = ROW,\\\",\\r\\n\\\"\\\\r\\\\n-- DATA_COMPRESSION = PAGE,\\\",\\r\\n\\\"\\\\r\\\\nSORT_IN_TEMPDB = ON\\\",\\r\\n\\\"\\\\r\\\\n);\\\",\\r\\n\\\"\\\\r\\\\n\\\"\\r\\n)\\r\\n| summarize count_missing_indexes = min_of(count(),  max_missing_indexes_per_query_hash),\\r\\n            statements = make_list(create_index_statement,  max_missing_indexes_per_query_hash) by query_hash\\r\\n| project query_hash,\\r\\n          missing_index_label = strcat(\\\"⚡\\\", tostring(count_missing_indexes), iif(count_missing_indexes == 1, \\\" index suggestion\\\", \\\" index suggestions\\\")),\\r\\n          create_index_statements = strcat(\\r\\n\\\"/*\\\",\\r\\n\\\"\\\\r\\\\nIMPORTANT:\\\",\\r\\n\\\"\\\\r\\\\nCREATE INDEX statements in this script are tentative suggestions.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nBefore creating indexes based on these suggestions:\\\",\\r\\n\\\"\\\\r\\\\n1. Examine existing indexes. If possible, modify them instead of creating a new index.\\\",\\r\\n\\\"\\\\r\\\\n2. When there are multiple similar index suggestions, consider combining them into one index.\\\",\\r\\n\\\"\\\\r\\\\n3. Always test and validate that a new or modified index does improve performance.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nAvoid creating many little-used indexes. That slows down inserts, updates,\\\",\\r\\n\\\"\\\\r\\\\nand deletes substantially, and increases storage and memory consumption.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nFor more information, see https://go.microsoft.com/fwlink/?linkid=2245704.\\\",\\r\\n\\\"\\\\r\\\\n*/\\\\r\\\\n\\\\r\\\\n\\\",\\r\\nstrcat_array(statements, \\\"\\\\r\\\\n\\\")\\r\\n)\\r\\n};\\r\\nlet missing_indexes = (\\r\\nunion isfuzzy=true\\r\\n(missing_indexes_stub),\\r\\n(missing_indexes_table)\\r\\n);\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| summarize any_database_name = take_any(database_name),\\r\\n            dcount_databases = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name)),\\r\\n            dcount_query_id = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name, \\\"|\\\", query_id)),\\r\\n            query_sql_text = take_any(query_sql_text),\\r\\n            count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", avg(count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sum(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           ),\\r\\n            query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n            by query_hash\\r\\n| extend multi_query_text_warning = iif(dcount_query_id > 1, strcat(\\\"There are \\\", tostring(dcount_query_id), \\\" distinct queries in \\\", tostring(dcount_databases), \\\" databases for this query hash. Displayed query text is for one of these \\\", tostring(dcount_query_id), \\\" queries.\\\"), \\\"\\\"),\\r\\n         ranked_metric = case(\\r\\n                             \\\"{qdsMetric}\\\"==\\\"count_executions\\\", toreal(count_executions),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"logical_io_reads\\\", toreal(logical_io_reads),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"logical_io_writes\\\", toreal(logical_io_writes),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"physical_io_reads\\\", toreal(physical_io_reads),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"num_physical_io_reads\\\", toreal(num_physical_io_reads),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"dop\\\", toreal(dop),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"rowcount\\\", toreal(rowcount),\\r\\n                             real(null)\\r\\n                             )\\r\\n| sort by count_executions desc | extend count_executions_rank = row_rank(count_executions)\\r\\n| sort by duration_us desc | extend duration_rank = row_rank(duration_us)\\r\\n| sort by cpu_time_us desc | extend cpu_time_rank = row_rank(cpu_time_us)\\r\\n| sort by logical_io_reads desc | extend logical_io_reads_rank = row_rank(logical_io_reads)\\r\\n| sort by logical_io_writes desc | extend logical_io_writes_rank = row_rank(logical_io_writes)\\r\\n| sort by physical_io_reads desc | extend physical_io_reads_rank = row_rank(physical_io_reads)\\r\\n| sort by num_physical_io_reads desc | extend num_physical_io_reads_rank = row_rank(num_physical_io_reads)\\r\\n| sort by clr_time_us desc | extend clr_time_rank = row_rank(clr_time_us)\\r\\n| sort by dop desc | extend dop_rank = row_rank(dop)\\r\\n| sort by query_max_used_memory desc | extend query_max_used_memory_rank = row_rank(query_max_used_memory)\\r\\n| sort by rowcount desc | extend rowcount_rank = row_rank(rowcount)\\r\\n| sort by log_bytes_used desc | extend log_bytes_used_rank = row_rank(log_bytes_used)\\r\\n| sort by tempdb_space_used desc | extend tempdb_space_used_rank = row_rank(tempdb_space_used)\\r\\n| extend ranks = dynamic_to_json(pack_array(\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Executions\\\", \\\"Rank\\\", count_executions_rank, \\\"Value\\\", count_executions),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Duration\\\", \\\"Rank\\\", duration_rank, \\\"Value\\\", duration_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CPU time\\\", \\\"Rank\\\", cpu_time_rank, \\\"Value\\\", cpu_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical reads\\\", \\\"Rank\\\", logical_io_reads_rank, \\\"Value\\\", logical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical writes\\\", \\\"Rank\\\", logical_io_writes_rank, \\\"Value\\\", logical_io_writes),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (pages)\\\", \\\"Rank\\\", physical_io_reads_rank, \\\"Value\\\", physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (IOs)\\\", \\\"Rank\\\", num_physical_io_reads_rank, \\\"Value\\\", num_physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CLR time\\\", \\\"Rank\\\", clr_time_rank, \\\"Value\\\", clr_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"DOP\\\", \\\"Rank\\\", dop_rank, \\\"Value\\\", dop),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Memory grant\\\", \\\"Rank\\\", query_max_used_memory_rank, \\\"Value\\\", query_max_used_memory),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Row count\\\", \\\"Rank\\\", rowcount_rank, \\\"Value\\\", rowcount),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Transaction log space used\\\", \\\"Rank\\\", log_bytes_used_rank, \\\"Value\\\", log_bytes_used),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Tempdb space used\\\", \\\"Rank\\\", tempdb_space_used_rank, \\\"Value\\\", tempdb_space_used)\\r\\n                                           ))\\r\\n| project-away count_executions_rank, duration_rank, cpu_time_rank, logical_io_reads_rank, logical_io_writes_rank, physical_io_reads_rank, num_physical_io_reads_rank, clr_time_rank, dop_rank, query_max_used_memory_rank, rowcount_rank, log_bytes_used_rank, tempdb_space_used_rank\\r\\n| sort by ranked_metric desc\\r\\n| extend rank = row_rank(ranked_metric)\\r\\n| project database_name_agg = iif(dcount_databases == 1, any_database_name, strcat(any_database_name, \\\" (+\\\", tostring(dcount_databases - 1), \\\")\\\")),\\r\\n          query_hash,\\r\\n          rank,\\r\\n          ranked_metric,\\r\\n          count_executions,\\r\\n          query_sql_text,\\r\\n          query_sql_text_json = dynamic_to_json(pack(\\\"query_sql_text\\\", query_sql_text)),\\r\\n          multi_query_text_warning,\\r\\n          tile_label = strcat(\\\"Query hash: \\\", tostring(query_hash)),\\r\\n          ranks\\r\\n// Restrict by query_hash after ranking to preserve query rank value in results\\r\\n| where query_hash == iif(isnotempty(@\\\"{qdsQueryHash}\\\"), @\\\"{qdsQueryHash}\\\", query_hash)\\r\\n| where query_sql_text contains \\\"{qdsQueryText:escape}\\\"\\r\\n| sort by rank asc, count_executions desc // secondary sort for determinism when primary sort is tied\\r\\n| take {qdsTopQueryCount}\\r\\n| lookup missing_indexes on query_hash\\r\\n;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 3,
        "showAnalytics": true,
        "title": "Top queries ranked by {qdsAggregation} {qdsMetricLabelMidsentenceCase}",
        "noDataMessage": "There is no data for specified parameters.",
        "exportedParameters": [
          {
            "fieldName": "query_sql_text_json",
            "parameterName": "query_sql_text_json",
            "defaultValue": "\"<Select a query>\""
          },
          {
            "fieldName": "query_hash",
            "parameterName": "query_hash",
            "parameterType": 1,
            "defaultValue": "\"\""
          },
          {
            "fieldName": "multi_query_text_warning",
            "parameterName": "multi_query_text_warning",
            "parameterType": 1,
            "defaultValue": "\"\""
          },
          {
            "fieldName": "ranks",
            "parameterName": "ranks",
            "parameterType": 1
          }
        ],
        "queryType": 9,
        "visualization": "tiles",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            }
          ]
        },
        "tileSettings": {
          "titleContent": {
            "columnMatch": "database_name_agg",
            "formatter": 1
          },
          "subtitleContent": {
            "columnMatch": "missing_index_label",
            "formatter": 1,
            "formatOptions": {
              "linkTarget": "WorkbookTemplate",
              "linkIsContextBlade": true,
              "workbookContext": {
                "componentIdSource": "workbook",
                "resourceIdsSource": "workbook",
                "templateIdSource": "static",
                "templateId": "Community-Workbooks/Database watcher/SQL text",
                "typeSource": "workbook",
                "gallerySource": "default",
                "locationSource": "workbook",
                "workbookName": "Index suggestions",
                "passSpecificParams": true,
                "templateParameters": [
                  {
                    "name": "sqlText",
                    "source": "column",
                    "value": "create_index_statements"
                  }
                ]
              }
            },
            "tooltipFormat": {
              "tooltip": "View index suggestions"
            }
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "none"
            },
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "rightContent": {
            "columnMatch": "ranked_metric",
            "formatter": 4,
            "formatOptions": {
              "palette": "coldHot"
            },
            "numberFormat": {
              "unit": 0,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          },
          "secondaryContent": {
            "columnMatch": "tile_label",
            "formatter": 1
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isEqualTo",
          "value": "tiles"
        },
        {
          "parameterName": "qdsMetricUnit",
          "comparison": "isEqualTo",
          "value": "unitless"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_top_queries_tiles_unitless"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let max_missing_indexes_per_query_hash = 30;\\r\\n// The missing indexes table may not exist. Work around by using a same-schema stub in a fuzzy union.\\r\\nlet missing_indexes_stub = view() {\\r\\nprint query_hash = \\\"\\\", missing_index_label = \\\"\\\", create_index_statements = \\\"\\\"\\r\\n| where isnotempty(query_hash)\\r\\n};\\r\\nlet missing_indexes_table = view() {\\r\\nsqlserver_missing_indexes\\r\\n| where sample_time_utc >= todatetime(\\\"{qdsStartTime}\\\") and sample_time_utc <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where grain_type == \\\"query_plan\\\"\\r\\n// Use the last missing index sample within the QDS interval\\r\\n| summarize arg_max(sample_time_utc, schema_name, object_name, database_engine_start_time_utc, avg_user_impact, equality_columns, inequality_columns, included_columns, user_seeks, user_scans, last_user_seek_utc, last_user_scan_utc)\\r\\n            by machine_name, server_name, database_name, query_hash, query_plan_hash\\r\\n// Remove dups that may be present in different plans\\r\\n| summarize sample_time_utc = min(sample_time_utc),\\r\\n            database_engine_start_time_utc = min(database_engine_start_time_utc),\\r\\n            avg_user_impact = max(avg_user_impact),\\r\\n            user_seeks = sum(user_seeks),\\r\\n            user_scans = sum(user_scans),\\r\\n            last_user_seek_utc = max(last_user_seek_utc),\\r\\n            last_user_scan_utc = max(last_user_scan_utc),\\r\\n            query_plan_hash = take_any(query_plan_hash),\\r\\n            count_plans = dcount(query_plan_hash)\\r\\n            by machine_name, server_name, database_name, query_hash, schema_name, object_name, equality_columns, inequality_columns, included_columns\\r\\n| extend duration_since_startup_seconds = 1s * datetime_diff(\\\"second\\\", sample_time_utc, database_engine_start_time_utc),\\r\\n         query_plan_hash = iif(count_plans == 1, tostring(query_plan_hash), strcat(query_plan_hash, \\\" (+\\\", tostring(count_plans - 1), \\\")\\\"))\\r\\n| extend create_index_statement = strcat(\\r\\n\\\"/* \\\",\\r\\n\\\"\\\\r\\\\nMachine: \\\", machine_name,\\r\\n\\\"\\\\r\\\\nServer: \\\", server_name,\\r\\n\\\"\\\\r\\\\nDatabase: \\\", database_name,\\r\\n\\\"\\\\r\\\\nQuery hash: \\\", query_hash,\\r\\n\\\"\\\\r\\\\nQuery plan hash: \\\", query_plan_hash,\\r\\n\\\"\\\\r\\\\nAverage impact (%): \\\", avg_user_impact,\\r\\n\\\"\\\\r\\\\nSeeks: \\\", user_seeks,\\r\\n\\\"\\\\r\\\\nScans: \\\", user_scans,\\r\\n\\\"\\\\r\\\\nLast seek time (UTC): \\\", iif(isnotempty(last_user_seek_utc), format_datetime(last_user_seek_utc, \\\"yyyy-MM-dd HH:mm:ss.fff\\\"), \\\"N/A\\\"),\\r\\n\\\"\\\\r\\\\nLast scan time (UTC): \\\", iif(isnotempty(last_user_scan_utc), format_datetime(last_user_scan_utc, \\\"yyyy-MM-dd HH:mm:ss.fff\\\"), \\\"N/A\\\"),\\r\\n\\\"\\\\r\\\\nInterval duration: \\\", strcat(format_timespan(duration_since_startup_seconds, \\\"d\\\"), \\\" days, \\\", format_timespan(duration_since_startup_seconds, \\\"hh\\\"), \\\" hours, \\\", format_timespan(duration_since_startup_seconds, \\\"m\\\"), \\\" minutes\\\"),\\r\\n\\\"\\\\r\\\\n*/\\\",\\r\\n\\\"\\\\r\\\\nCREATE INDEX [replace-with-index-name] ON \\\", schema_name, \\\".\\\", object_name,\\r\\n\\\"\\\\r\\\\n(\\\",\\r\\niif(isnotempty(equality_columns), strcat(\\\"\\\\r\\\\n\\\", equality_columns, iif(isnotempty(inequality_columns), \\\",\\\", \\\"\\\"), \\\" /* equality columns */\\\"), \\\"\\\"),\\r\\niif(isnotempty(inequality_columns), strcat(\\\"\\\\r\\\\n\\\", inequality_columns, \\\" /* inequality columns */\\\"), \\\"\\\"),\\r\\n\\\"\\\\r\\\\n)\\\",\\r\\niif(isnotempty(included_columns), strcat(\\\"\\\\r\\\\nINCLUDE (\\\", included_columns, \\\")\\\"), \\\"\\\"),\\r\\n\\\"\\\\r\\\\nWITH /* Adjust index options as needed */\\\",\\r\\n\\\"\\\\r\\\\n(\\\",\\r\\n\\\"\\\\r\\\\nMAXDOP = 8,\\\",\\r\\n\\\"\\\\r\\\\nONLINE = ON (WAIT_AT_LOW_PRIORITY (MAX_DURATION = 5 MINUTES, ABORT_AFTER_WAIT = SELF)),\\\",\\r\\n\\\"\\\\r\\\\n-- RESUMABLE = ON,\\\",\\r\\n\\\"\\\\r\\\\n-- DATA_COMPRESSION = ROW,\\\",\\r\\n\\\"\\\\r\\\\n-- DATA_COMPRESSION = PAGE,\\\",\\r\\n\\\"\\\\r\\\\nSORT_IN_TEMPDB = ON\\\",\\r\\n\\\"\\\\r\\\\n);\\\",\\r\\n\\\"\\\\r\\\\n\\\"\\r\\n)\\r\\n| summarize count_missing_indexes = min_of(count(),  max_missing_indexes_per_query_hash),\\r\\n            statements = make_list(create_index_statement,  max_missing_indexes_per_query_hash) by query_hash\\r\\n| project query_hash,\\r\\n          missing_index_label = strcat(\\\"⚡\\\", tostring(count_missing_indexes), iif(count_missing_indexes == 1, \\\" index suggestion\\\", \\\" index suggestions\\\")),\\r\\n          create_index_statements = strcat(\\r\\n\\\"/*\\\",\\r\\n\\\"\\\\r\\\\nIMPORTANT:\\\",\\r\\n\\\"\\\\r\\\\nCREATE INDEX statements in this script are tentative suggestions.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nBefore creating indexes based on these suggestions:\\\",\\r\\n\\\"\\\\r\\\\n1. Examine existing indexes. If possible, modify them instead of creating a new index.\\\",\\r\\n\\\"\\\\r\\\\n2. When there are multiple similar index suggestions, consider combining them into one index.\\\",\\r\\n\\\"\\\\r\\\\n3. Always test and validate that a new or modified index does improve performance.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nAvoid creating many little-used indexes. That slows down inserts, updates,\\\",\\r\\n\\\"\\\\r\\\\nand deletes substantially, and increases storage and memory consumption.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nFor more information, see https://go.microsoft.com/fwlink/?linkid=2245704.\\\",\\r\\n\\\"\\\\r\\\\n*/\\\\r\\\\n\\\\r\\\\n\\\",\\r\\nstrcat_array(statements, \\\"\\\\r\\\\n\\\")\\r\\n)\\r\\n};\\r\\nlet missing_indexes = (\\r\\nunion isfuzzy=true\\r\\n(missing_indexes_stub),\\r\\n(missing_indexes_table)\\r\\n);\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| summarize any_database_name = take_any(database_name),\\r\\n            dcount_databases = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name)),\\r\\n            dcount_query_id = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name, \\\"|\\\", query_id)),\\r\\n            query_sql_text = take_any(query_sql_text),\\r\\n            count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", avg(count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sum(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           ),\\r\\n            query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n            by query_hash\\r\\n| extend multi_query_text_warning = iif(dcount_query_id > 1, strcat(\\\"There are \\\", tostring(dcount_query_id), \\\" distinct queries in \\\", tostring(dcount_databases), \\\" databases for this query hash. Displayed query text is for one of these \\\", tostring(dcount_query_id), \\\" queries.\\\"), \\\"\\\"),\\r\\n         ranked_metric = case(\\r\\n                             \\\"{qdsMetric}\\\"==\\\"count_executions\\\", toreal(count_executions),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"duration\\\", toreal(duration_us),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"cpu_time\\\", toreal(cpu_time_us),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"clr_time\\\", toreal(clr_time_us),\\r\\n                             real(null)\\r\\n                             )\\r\\n| sort by count_executions desc | extend count_executions_rank = row_rank(count_executions)\\r\\n| sort by duration_us desc | extend duration_rank = row_rank(duration_us)\\r\\n| sort by cpu_time_us desc | extend cpu_time_rank = row_rank(cpu_time_us)\\r\\n| sort by logical_io_reads desc | extend logical_io_reads_rank = row_rank(logical_io_reads)\\r\\n| sort by logical_io_writes desc | extend logical_io_writes_rank = row_rank(logical_io_writes)\\r\\n| sort by physical_io_reads desc | extend physical_io_reads_rank = row_rank(physical_io_reads)\\r\\n| sort by num_physical_io_reads desc | extend num_physical_io_reads_rank = row_rank(num_physical_io_reads)\\r\\n| sort by clr_time_us desc | extend clr_time_rank = row_rank(clr_time_us)\\r\\n| sort by dop desc | extend dop_rank = row_rank(dop)\\r\\n| sort by query_max_used_memory desc | extend query_max_used_memory_rank = row_rank(query_max_used_memory)\\r\\n| sort by rowcount desc | extend rowcount_rank = row_rank(rowcount)\\r\\n| sort by log_bytes_used desc | extend log_bytes_used_rank = row_rank(log_bytes_used)\\r\\n| sort by tempdb_space_used desc | extend tempdb_space_used_rank = row_rank(tempdb_space_used)\\r\\n| extend ranks = dynamic_to_json(pack_array(\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Executions\\\", \\\"Rank\\\", count_executions_rank, \\\"Value\\\", count_executions),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Duration\\\", \\\"Rank\\\", duration_rank, \\\"Value\\\", duration_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CPU time\\\", \\\"Rank\\\", cpu_time_rank, \\\"Value\\\", cpu_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical reads\\\", \\\"Rank\\\", logical_io_reads_rank, \\\"Value\\\", logical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical writes\\\", \\\"Rank\\\", logical_io_writes_rank, \\\"Value\\\", logical_io_writes),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (pages)\\\", \\\"Rank\\\", physical_io_reads_rank, \\\"Value\\\", physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (IOs)\\\", \\\"Rank\\\", num_physical_io_reads_rank, \\\"Value\\\", num_physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CLR time\\\", \\\"Rank\\\", clr_time_rank, \\\"Value\\\", clr_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"DOP\\\", \\\"Rank\\\", dop_rank, \\\"Value\\\", dop),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Memory grant\\\", \\\"Rank\\\", query_max_used_memory_rank, \\\"Value\\\", query_max_used_memory),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Row count\\\", \\\"Rank\\\", rowcount_rank, \\\"Value\\\", rowcount),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Transaction log space used\\\", \\\"Rank\\\", log_bytes_used_rank, \\\"Value\\\", log_bytes_used),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Tempdb space used\\\", \\\"Rank\\\", tempdb_space_used_rank, \\\"Value\\\", tempdb_space_used)\\r\\n                                           ))\\r\\n| project-away count_executions_rank, duration_rank, cpu_time_rank, logical_io_reads_rank, logical_io_writes_rank, physical_io_reads_rank, num_physical_io_reads_rank, clr_time_rank, dop_rank, query_max_used_memory_rank, rowcount_rank, log_bytes_used_rank, tempdb_space_used_rank\\r\\n| sort by ranked_metric desc\\r\\n| extend rank = row_rank(ranked_metric)\\r\\n| project database_name_agg = iif(dcount_databases == 1, any_database_name, strcat(any_database_name, \\\" (+\\\", tostring(dcount_databases - 1), \\\")\\\")),\\r\\n          query_hash,\\r\\n          rank,\\r\\n          ranked_metric,\\r\\n          count_executions,\\r\\n          query_sql_text,\\r\\n          query_sql_text_json = dynamic_to_json(pack(\\\"query_sql_text\\\", query_sql_text)),\\r\\n          multi_query_text_warning,\\r\\n          tile_label = strcat(\\\"Query hash: \\\", tostring(query_hash)),\\r\\n          ranks\\r\\n// Restrict by query_id/query_hash after ranking to preserve query rank value in results\\r\\n| where query_hash == iif(isnotempty(@\\\"{qdsQueryHash}\\\"), @\\\"{qdsQueryHash}\\\", query_hash)\\r\\n| where query_sql_text contains \\\"{qdsQueryText:escape}\\\"\\r\\n| sort by rank asc, count_executions desc // secondary sort for determinism when primary sort is tied\\r\\n| take {qdsTopQueryCount}\\r\\n| lookup missing_indexes on query_hash\\r\\n;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 3,
        "showAnalytics": true,
        "title": "Top queries ranked by {qdsAggregation} {qdsMetricLabelMidsentenceCase}",
        "noDataMessage": "There is no data for specified parameters.",
        "exportedParameters": [
          {
            "fieldName": "query_sql_text_json",
            "parameterName": "query_sql_text_json",
            "defaultValue": "\"<Select a query>\""
          },
          {
            "fieldName": "query_hash",
            "parameterName": "query_hash",
            "parameterType": 1,
            "defaultValue": "\"\""
          },
          {
            "fieldName": "multi_query_text_warning",
            "parameterName": "multi_query_text_warning",
            "parameterType": 1
          },
          {
            "fieldName": "ranks",
            "parameterName": "ranks",
            "parameterType": 1
          }
        ],
        "queryType": 9,
        "visualization": "tiles",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            }
          ]
        },
        "tileSettings": {
          "titleContent": {
            "columnMatch": "database_name_agg",
            "formatter": 1
          },
          "subtitleContent": {
            "columnMatch": "missing_index_label",
            "formatter": 7,
            "formatOptions": {
              "linkTarget": "WorkbookTemplate",
              "linkIsContextBlade": true,
              "workbookContext": {
                "componentIdSource": "workbook",
                "resourceIdsSource": "workbook",
                "templateIdSource": "static",
                "templateId": "Community-Workbooks/Database watcher/SQL text",
                "typeSource": "workbook",
                "gallerySource": "default",
                "locationSource": "workbook",
                "workbookName": "Index suggestions",
                "passSpecificParams": true,
                "templateParameters": [
                  {
                    "name": "sqlText",
                    "source": "column",
                    "value": "create_index_statements"
                  }
                ]
              }
            },
            "tooltipFormat": {
              "tooltip": "View index suggestions"
            }
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "none"
            },
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "rightContent": {
            "columnMatch": "ranked_metric",
            "formatter": 4,
            "formatOptions": {
              "palette": "coldHot"
            },
            "numberFormat": {
              "unit": 22,
              "options": {
                "style": "decimal",
                "maximumFractionDigits": 2
              }
            }
          },
          "secondaryContent": {
            "columnMatch": "tile_label",
            "formatter": 1
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isEqualTo",
          "value": "tiles"
        },
        {
          "parameterName": "qdsMetricUnit",
          "comparison": "isEqualTo",
          "value": "time"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_top_queries_tiles_time"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let max_missing_indexes_per_query_hash = 30;\\r\\n// The missing indexes table may not exist. Work around by using a same-schema stub in a fuzzy union.\\r\\nlet missing_indexes_stub = view() {\\r\\nprint query_hash = \\\"\\\", missing_index_label = \\\"\\\", create_index_statements = \\\"\\\"\\r\\n| where isnotempty(query_hash)\\r\\n};\\r\\nlet missing_indexes_table = view() {\\r\\nsqlserver_missing_indexes\\r\\n| where sample_time_utc >= todatetime(\\\"{qdsStartTime}\\\") and sample_time_utc <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where grain_type == \\\"query_plan\\\"\\r\\n// Use the last missing index sample within the QDS interval\\r\\n| summarize arg_max(sample_time_utc, schema_name, object_name, database_engine_start_time_utc, avg_user_impact, equality_columns, inequality_columns, included_columns, user_seeks, user_scans, last_user_seek_utc, last_user_scan_utc)\\r\\n            by machine_name, server_name, database_name, query_hash, query_plan_hash\\r\\n// Remove dups that may be present in different plans\\r\\n| summarize sample_time_utc = min(sample_time_utc),\\r\\n            database_engine_start_time_utc = min(database_engine_start_time_utc),\\r\\n            avg_user_impact = max(avg_user_impact),\\r\\n            user_seeks = sum(user_seeks),\\r\\n            user_scans = sum(user_scans),\\r\\n            last_user_seek_utc = max(last_user_seek_utc),\\r\\n            last_user_scan_utc = max(last_user_scan_utc),\\r\\n            query_plan_hash = take_any(query_plan_hash),\\r\\n            count_plans = dcount(query_plan_hash)\\r\\n            by machine_name, server_name, database_name, query_hash, schema_name, object_name, equality_columns, inequality_columns, included_columns\\r\\n| extend duration_since_startup_seconds = 1s * datetime_diff(\\\"second\\\", sample_time_utc, database_engine_start_time_utc),\\r\\n         query_plan_hash = iif(count_plans == 1, tostring(query_plan_hash), strcat(query_plan_hash, \\\" (+\\\", tostring(count_plans - 1), \\\")\\\"))\\r\\n| extend create_index_statement = strcat(\\r\\n\\\"/* \\\",\\r\\n\\\"\\\\r\\\\nMachine: \\\", machine_name,\\r\\n\\\"\\\\r\\\\nServer: \\\", server_name,\\r\\n\\\"\\\\r\\\\nDatabase: \\\", database_name,\\r\\n\\\"\\\\r\\\\nQuery hash: \\\", query_hash,\\r\\n\\\"\\\\r\\\\nQuery plan hash: \\\", query_plan_hash,\\r\\n\\\"\\\\r\\\\nAverage impact (%): \\\", avg_user_impact,\\r\\n\\\"\\\\r\\\\nSeeks: \\\", user_seeks,\\r\\n\\\"\\\\r\\\\nScans: \\\", user_scans,\\r\\n\\\"\\\\r\\\\nLast seek time (UTC): \\\", iif(isnotempty(last_user_seek_utc), format_datetime(last_user_seek_utc, \\\"yyyy-MM-dd HH:mm:ss.fff\\\"), \\\"N/A\\\"),\\r\\n\\\"\\\\r\\\\nLast scan time (UTC): \\\", iif(isnotempty(last_user_scan_utc), format_datetime(last_user_scan_utc, \\\"yyyy-MM-dd HH:mm:ss.fff\\\"), \\\"N/A\\\"),\\r\\n\\\"\\\\r\\\\nInterval duration: \\\", strcat(format_timespan(duration_since_startup_seconds, \\\"d\\\"), \\\" days, \\\", format_timespan(duration_since_startup_seconds, \\\"hh\\\"), \\\" hours, \\\", format_timespan(duration_since_startup_seconds, \\\"m\\\"), \\\" minutes\\\"),\\r\\n\\\"\\\\r\\\\n*/\\\",\\r\\n\\\"\\\\r\\\\nCREATE INDEX [replace-with-index-name] ON \\\", schema_name, \\\".\\\", object_name,\\r\\n\\\"\\\\r\\\\n(\\\",\\r\\niif(isnotempty(equality_columns), strcat(\\\"\\\\r\\\\n\\\", equality_columns, iif(isnotempty(inequality_columns), \\\",\\\", \\\"\\\"), \\\" /* equality columns */\\\"), \\\"\\\"),\\r\\niif(isnotempty(inequality_columns), strcat(\\\"\\\\r\\\\n\\\", inequality_columns, \\\" /* inequality columns */\\\"), \\\"\\\"),\\r\\n\\\"\\\\r\\\\n)\\\",\\r\\niif(isnotempty(included_columns), strcat(\\\"\\\\r\\\\nINCLUDE (\\\", included_columns, \\\")\\\"), \\\"\\\"),\\r\\n\\\"\\\\r\\\\nWITH /* Adjust index options as needed */\\\",\\r\\n\\\"\\\\r\\\\n(\\\",\\r\\n\\\"\\\\r\\\\nMAXDOP = 8,\\\",\\r\\n\\\"\\\\r\\\\nONLINE = ON (WAIT_AT_LOW_PRIORITY (MAX_DURATION = 5 MINUTES, ABORT_AFTER_WAIT = SELF)),\\\",\\r\\n\\\"\\\\r\\\\n-- RESUMABLE = ON,\\\",\\r\\n\\\"\\\\r\\\\n-- DATA_COMPRESSION = ROW,\\\",\\r\\n\\\"\\\\r\\\\n-- DATA_COMPRESSION = PAGE,\\\",\\r\\n\\\"\\\\r\\\\nSORT_IN_TEMPDB = ON\\\",\\r\\n\\\"\\\\r\\\\n);\\\",\\r\\n\\\"\\\\r\\\\n\\\"\\r\\n)\\r\\n| summarize count_missing_indexes = min_of(count(),  max_missing_indexes_per_query_hash),\\r\\n            statements = make_list(create_index_statement,  max_missing_indexes_per_query_hash) by query_hash\\r\\n| project query_hash,\\r\\n          missing_index_label = strcat(\\\"⚡\\\", tostring(count_missing_indexes), iif(count_missing_indexes == 1, \\\" index suggestion\\\", \\\" index suggestions\\\")),\\r\\n          create_index_statements = strcat(\\r\\n\\\"/*\\\",\\r\\n\\\"\\\\r\\\\nIMPORTANT:\\\",\\r\\n\\\"\\\\r\\\\nCREATE INDEX statements in this script are tentative suggestions.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nBefore creating indexes based on these suggestions:\\\",\\r\\n\\\"\\\\r\\\\n1. Examine existing indexes. If possible, modify them instead of creating a new index.\\\",\\r\\n\\\"\\\\r\\\\n2. When there are multiple similar index suggestions, consider combining them into one index.\\\",\\r\\n\\\"\\\\r\\\\n3. Always test and validate that a new or modified index does improve performance.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nAvoid creating many little-used indexes. That slows down inserts, updates,\\\",\\r\\n\\\"\\\\r\\\\nand deletes substantially, and increases storage and memory consumption.\\\",\\r\\n\\\"\\\\r\\\\n\\\\r\\\\nFor more information, see https://go.microsoft.com/fwlink/?linkid=2245704.\\\",\\r\\n\\\"\\\\r\\\\n*/\\\\r\\\\n\\\\r\\\\n\\\",\\r\\nstrcat_array(statements, \\\"\\\\r\\\\n\\\")\\r\\n)\\r\\n};\\r\\nlet missing_indexes = (\\r\\nunion isfuzzy=true\\r\\n(missing_indexes_stub),\\r\\n(missing_indexes_table)\\r\\n);\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| summarize any_database_name = take_any(database_name),\\r\\n            dcount_databases = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name)),\\r\\n            dcount_query_id = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name, \\\"|\\\", query_id)),\\r\\n            query_sql_text = take_any(query_sql_text),\\r\\n            count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", avg(count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sum(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           ),\\r\\n            query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n            by query_hash\\r\\n| extend multi_query_text_warning = iif(dcount_query_id > 1, strcat(\\\"There are \\\", tostring(dcount_query_id), \\\" distinct queries in \\\", tostring(dcount_databases), \\\" databases for this query hash. Displayed query text is for one of these \\\", tostring(dcount_query_id), \\\" queries.\\\"), \\\"\\\"),\\r\\n         ranked_metric = case(\\r\\n                             \\\"{qdsMetric}\\\"==\\\"query_max_used_memory\\\", toreal(query_max_used_memory * 8 * 1024),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"log_bytes_used\\\", toreal(log_bytes_used),\\r\\n                             \\\"{qdsMetric}\\\"==\\\"tempdb_space_used\\\", toreal(tempdb_space_used * 8 * 1024),\\r\\n                             real(null)\\r\\n                             )\\r\\n| sort by count_executions desc | extend count_executions_rank = row_rank(count_executions)\\r\\n| sort by duration_us desc | extend duration_rank = row_rank(duration_us)\\r\\n| sort by cpu_time_us desc | extend cpu_time_rank = row_rank(cpu_time_us)\\r\\n| sort by logical_io_reads desc | extend logical_io_reads_rank = row_rank(logical_io_reads)\\r\\n| sort by logical_io_writes desc | extend logical_io_writes_rank = row_rank(logical_io_writes)\\r\\n| sort by physical_io_reads desc | extend physical_io_reads_rank = row_rank(physical_io_reads)\\r\\n| sort by num_physical_io_reads desc | extend num_physical_io_reads_rank = row_rank(num_physical_io_reads)\\r\\n| sort by clr_time_us desc | extend clr_time_rank = row_rank(clr_time_us)\\r\\n| sort by dop desc | extend dop_rank = row_rank(dop)\\r\\n| sort by query_max_used_memory desc | extend query_max_used_memory_rank = row_rank(query_max_used_memory)\\r\\n| sort by rowcount desc | extend rowcount_rank = row_rank(rowcount)\\r\\n| sort by log_bytes_used desc | extend log_bytes_used_rank = row_rank(log_bytes_used)\\r\\n| sort by tempdb_space_used desc | extend tempdb_space_used_rank = row_rank(tempdb_space_used)\\r\\n| extend ranks = dynamic_to_json(pack_array(\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Executions\\\", \\\"Rank\\\", count_executions_rank, \\\"Value\\\", count_executions),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Duration\\\", \\\"Rank\\\", duration_rank, \\\"Value\\\", duration_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CPU time\\\", \\\"Rank\\\", cpu_time_rank, \\\"Value\\\", cpu_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical reads\\\", \\\"Rank\\\", logical_io_reads_rank, \\\"Value\\\", logical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical writes\\\", \\\"Rank\\\", logical_io_writes_rank, \\\"Value\\\", logical_io_writes),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (pages)\\\", \\\"Rank\\\", physical_io_reads_rank, \\\"Value\\\", physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (IOs)\\\", \\\"Rank\\\", num_physical_io_reads_rank, \\\"Value\\\", num_physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CLR time\\\", \\\"Rank\\\", clr_time_rank, \\\"Value\\\", clr_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"DOP\\\", \\\"Rank\\\", dop_rank, \\\"Value\\\", dop),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Memory grant\\\", \\\"Rank\\\", query_max_used_memory_rank, \\\"Value\\\", query_max_used_memory),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Row count\\\", \\\"Rank\\\", rowcount_rank, \\\"Value\\\", rowcount),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Transaction log space used\\\", \\\"Rank\\\", log_bytes_used_rank, \\\"Value\\\", log_bytes_used),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Tempdb space used\\\", \\\"Rank\\\", tempdb_space_used_rank, \\\"Value\\\", tempdb_space_used)\\r\\n                                           ))\\r\\n| project-away count_executions_rank, duration_rank, cpu_time_rank, logical_io_reads_rank, logical_io_writes_rank, physical_io_reads_rank, num_physical_io_reads_rank, clr_time_rank, dop_rank, query_max_used_memory_rank, rowcount_rank, log_bytes_used_rank, tempdb_space_used_rank\\r\\n| sort by ranked_metric desc\\r\\n| extend rank = row_rank(ranked_metric)\\r\\n| project database_name_agg = iif(dcount_databases == 1, any_database_name, strcat(any_database_name, \\\" (+\\\", tostring(dcount_databases - 1), \\\")\\\")),\\r\\n          query_hash,\\r\\n          rank,\\r\\n          ranked_metric,\\r\\n          count_executions,\\r\\n          query_sql_text,\\r\\n          query_sql_text_json = dynamic_to_json(pack(\\\"query_sql_text\\\", query_sql_text)),\\r\\n          multi_query_text_warning,\\r\\n          tile_label = strcat(\\\"Query hash: \\\", tostring(query_hash)),\\r\\n          ranks\\r\\n// Restrict by query_id/query_hash after ranking to preserve query rank value in results\\r\\n| where query_hash == iif(isnotempty(@\\\"{qdsQueryHash}\\\"), @\\\"{qdsQueryHash}\\\", query_hash)\\r\\n| where query_sql_text contains \\\"{qdsQueryText:escape}\\\"\\r\\n| sort by rank asc, count_executions desc // secondary sort for determinism when primary sort is tied\\r\\n| take {qdsTopQueryCount}\\r\\n| lookup missing_indexes on query_hash\\r\\n;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 3,
        "showAnalytics": true,
        "title": "Top queries ranked by {qdsAggregation} {qdsMetricLabelMidsentenceCase}",
        "noDataMessage": "There is no data for specified parameters.",
        "exportedParameters": [
          {
            "fieldName": "query_sql_text_json",
            "parameterName": "query_sql_text_json",
            "defaultValue": "\"<Select a query>\""
          },
          {
            "fieldName": "query_hash",
            "parameterName": "query_hash",
            "parameterType": 1,
            "defaultValue": "\"\""
          },
          {
            "fieldName": "multi_query_text_warning",
            "parameterName": "multi_query_text_warning",
            "parameterType": 1
          },
          {
            "fieldName": "ranks",
            "parameterName": "ranks",
            "parameterType": 1
          }
        ],
        "queryType": 9,
        "visualization": "tiles",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            }
          ]
        },
        "tileSettings": {
          "titleContent": {
            "columnMatch": "database_name_agg",
            "formatter": 1
          },
          "subtitleContent": {
            "columnMatch": "missing_index_label",
            "formatter": 7,
            "formatOptions": {
              "linkTarget": "WorkbookTemplate",
              "linkIsContextBlade": true,
              "workbookContext": {
                "componentIdSource": "workbook",
                "resourceIdsSource": "workbook",
                "templateIdSource": "static",
                "templateId": "Community-Workbooks/Database watcher/SQL text",
                "typeSource": "workbook",
                "gallerySource": "default",
                "locationSource": "workbook",
                "workbookName": "Index suggestions",
                "passSpecificParams": true,
                "templateParameters": [
                  {
                    "name": "sqlText",
                    "source": "column",
                    "value": "create_index_statements"
                  }
                ]
              }
            },
            "tooltipFormat": {
              "tooltip": "View index suggestions"
            }
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "none"
            },
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "rightContent": {
            "columnMatch": "ranked_metric",
            "formatter": 4,
            "formatOptions": {
              "palette": "coldHot"
            },
            "numberFormat": {
              "unit": 2,
              "options": {
                "style": "decimal",
                "maximumFractionDigits": 2
              }
            },
            "tooltipFormat": {
              "tooltip": "Query runtime statistic"
            }
          },
          "secondaryContent": {
            "columnMatch": "tile_label",
            "formatter": 1
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isEqualTo",
          "value": "tiles"
        },
        {
          "parameterName": "qdsMetricUnit",
          "comparison": "isEqualTo",
          "value": "bytes"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_top_queries_tiles_bytes"
    },
    {
      "type": 1,
      "content": {
        "json": "Each tile represents all queries with the same query hash. The large number on the tile is **query rank** by `{qdsAggregation} {qdsMetricLabelMidsentenceCase}`. Two queries have the same rank if their resource usage during the interval is the same.\r\n\r\nThe tile also shows `{qdsAggregation} {qdsMetricLabelMidsentenceCase}` value, aggregated over selected time range. The length of the bar below this value is proportional to resource usage by this query, compared to other top queries displayed.\r\n\r\nThe `Query hash` value is displayed at the bottom of each tile. You can copy it and paste it in the `Query hash` parameter box above to focus on a specific top query."
      },
      "conditionalVisibilities": [
        {
          "parameterName": "showDescriptions",
          "comparison": "isEqualTo",
          "value": "true"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isEqualTo",
          "value": "tiles"
        },
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_tiles_help"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| summarize dcount_databases = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name)),\\r\\n            any_database_name = take_any(database_name),\\r\\n            dcount_query_id = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name, \\\"|\\\", query_id)),\\r\\n            dcount_sql_module_name = dcount(sql_module_name),\\r\\n            any_sql_module_name = take_any(sql_module_name),\\r\\n            dcount_context_settings_id = dcount(context_settings_id),\\r\\n            any_context_settings_id = take_any(context_settings_id),\\r\\n            dcount_plan_id = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name, \\\"|\\\", plan_id)),\\r\\n            query_sql_text = take_any(query_sql_text),\\r\\n            count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", round(avg(count_executions), 2),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sum(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            count_successful_executions = case(\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", round(avgif(count_executions, execution_type_desc == \\\"Regular\\\"), 2),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", minif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sumif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              real(null)\\r\\n                                              ),\\r\\n            count_aborted_executions = case(\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", round(avgif(count_executions, execution_type_desc == \\\"Aborted\\\"), 2),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", minif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sumif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           real(null)\\r\\n                                           ),\\r\\n            count_exception_executions = case(\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"avg\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", round(avgif(count_executions, execution_type_desc == \\\"Exception\\\"), 2),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"min\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", minif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"max\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"stdev\\\" and \\\"{qdsMetric}\\\"==\\\"count_executions\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             \\\"{qdsAggregation}\\\" in (\\\"total\\\",\\\"avg\\\",\\\"min\\\",\\\"max\\\",\\\"stdev\\\"), sumif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             real(null)\\r\\n                                             ),\\r\\n            duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n            by query_hash\\r\\n| extend multi_query_text_warning = iif(dcount_query_id > 1, strcat(\\\"There are \\\", tostring(dcount_query_id), \\\" distinct queries in \\\", tostring(dcount_databases), \\\" databases for this query hash. Displayed query text is for one of these \\\", tostring(dcount_query_id), \\\" queries.\\\"), \\\"\\\")\\r\\n| project query_hash,\\r\\n          database_name_agg = iif(dcount_databases == 1, any_database_name, strcat(any_database_name, \\\" (+\\\", tostring(dcount_databases - 1), \\\")\\\")),\\r\\n          query_sql_text,\\r\\n          count_executions,\\r\\n          count_successful_executions,\\r\\n          count_aborted_executions,\\r\\n          count_exception_executions,\\r\\n          duration_us,\\r\\n          cpu_time_us,\\r\\n          logical_io_reads,\\r\\n          logical_io_writes,\\r\\n          physical_io_reads,\\r\\n          num_physical_io_reads,\\r\\n          clr_time_us,\\r\\n          dop,\\r\\n          query_max_used_memory_kb = query_max_used_memory * 8,\\r\\n          rowcount,\\r\\n          log_bytes_used,\\r\\n          tempdb_space_used_kb = tempdb_space_used * 8,\\r\\n          sql_module_name_agg = iif(dcount_sql_module_name == 1, any_sql_module_name, strcat(any_sql_module_name, \\\" (+\\\", tostring(dcount_sql_module_name - 1), \\\")\\\")),\\r\\n          context_settings_id_agg = iif(dcount_context_settings_id == 1, tostring(any_context_settings_id), strcat(any_context_settings_id, \\\" (+\\\", tostring(dcount_context_settings_id - 1), \\\")\\\")),\\r\\n          query_sql_text_json = dynamic_to_json(pack(\\\"query_sql_text\\\", query_sql_text)),\\r\\n          multi_query_text_warning\\r\\n| sort by count_executions desc | extend count_executions_rank = row_rank(count_executions)\\r\\n| sort by duration_us desc | extend duration_rank = row_rank(duration_us)\\r\\n| sort by cpu_time_us desc | extend cpu_time_rank = row_rank(cpu_time_us)\\r\\n| sort by logical_io_reads desc | extend logical_io_reads_rank = row_rank(logical_io_reads)\\r\\n| sort by logical_io_writes desc | extend logical_io_writes_rank = row_rank(logical_io_writes)\\r\\n| sort by physical_io_reads desc | extend physical_io_reads_rank = row_rank(physical_io_reads)\\r\\n| sort by num_physical_io_reads desc | extend num_physical_io_reads_rank = row_rank(num_physical_io_reads)\\r\\n| sort by clr_time_us desc | extend clr_time_rank = row_rank(clr_time_us)\\r\\n| sort by dop desc | extend dop_rank = row_rank(dop)\\r\\n| sort by query_max_used_memory_kb desc | extend query_max_used_memory_rank = row_rank(query_max_used_memory_kb)\\r\\n| sort by rowcount desc | extend rowcount_rank = row_rank(rowcount)\\r\\n| sort by log_bytes_used desc | extend log_bytes_used_rank = row_rank(log_bytes_used)\\r\\n| sort by tempdb_space_used_kb desc | extend tempdb_space_used_rank = row_rank(tempdb_space_used_kb)\\r\\n| extend ranks = dynamic_to_json(pack_array(\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Executions\\\", \\\"Rank\\\", count_executions_rank, \\\"Value\\\", count_executions),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Duration\\\", \\\"Rank\\\", duration_rank, \\\"Value\\\", duration_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CPU time\\\", \\\"Rank\\\", cpu_time_rank, \\\"Value\\\", cpu_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical reads\\\", \\\"Rank\\\", logical_io_reads_rank, \\\"Value\\\", logical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Logical writes\\\", \\\"Rank\\\", logical_io_writes_rank, \\\"Value\\\", logical_io_writes),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (pages)\\\", \\\"Rank\\\", physical_io_reads_rank, \\\"Value\\\", physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Physical reads (IOs)\\\", \\\"Rank\\\", num_physical_io_reads_rank, \\\"Value\\\", num_physical_io_reads),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"CLR time\\\", \\\"Rank\\\", clr_time_rank, \\\"Value\\\", clr_time_us),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"DOP\\\", \\\"Rank\\\", dop_rank, \\\"Value\\\", dop),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Memory grant\\\", \\\"Rank\\\", query_max_used_memory_rank, \\\"Value\\\", query_max_used_memory_kb),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Row count\\\", \\\"Rank\\\", rowcount_rank, \\\"Value\\\", rowcount),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Transaction log space used\\\", \\\"Rank\\\", log_bytes_used_rank, \\\"Value\\\", log_bytes_used),\\r\\n                                           bag_pack(\\\"Metric\\\", \\\"Tempdb space used\\\", \\\"Rank\\\", tempdb_space_used_rank, \\\"Value\\\", tempdb_space_used_kb)\\r\\n                                           ))\\r\\n| project-away count_executions_rank, duration_rank, cpu_time_rank, logical_io_reads_rank, logical_io_writes_rank, physical_io_reads_rank, num_physical_io_reads_rank, clr_time_rank, dop_rank, query_max_used_memory_rank, rowcount_rank, log_bytes_used_rank, tempdb_space_used_rank\\r\\n| sort by case(\\r\\n              \\\"{qdsMetric}\\\"==\\\"count_executions\\\", toreal(count_executions),\\r\\n              \\\"{qdsMetric}\\\"==\\\"duration\\\", toreal(duration_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"cpu_time\\\", toreal(cpu_time_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"logical_io_reads\\\", toreal(logical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"logical_io_writes\\\", toreal(logical_io_writes),\\r\\n              \\\"{qdsMetric}\\\"==\\\"physical_io_reads\\\", toreal(physical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"num_physical_io_reads\\\", toreal(num_physical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"clr_time\\\", toreal(clr_time_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"dop\\\", toreal(dop),\\r\\n              \\\"{qdsMetric}\\\"==\\\"query_max_used_memory\\\", toreal(query_max_used_memory_kb),\\r\\n              \\\"{qdsMetric}\\\"==\\\"rowcount\\\", toreal(rowcount),\\r\\n              \\\"{qdsMetric}\\\"==\\\"log_bytes_used\\\", toreal(log_bytes_used),\\r\\n              \\\"{qdsMetric}\\\"==\\\"tempdb_space_used\\\", toreal(tempdb_space_used_kb),\\r\\n              real(null)\\r\\n              ) desc,\\r\\n          count_executions desc // secondary sort for determinism when primary sort is tied\\r\\n// Restrict by query_id/query_hash after ranking to preserve query rank value in results\\r\\n| where query_hash == iif(isnotempty(@\\\"{qdsQueryHash}\\\"), @\\\"{qdsQueryHash}\\\", query_hash)\\r\\n| where query_sql_text contains \\\"{qdsQueryText:escape}\\\"\\r\\n| take {qdsTopQueryCount}\\r\\n;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 0,
        "showAnalytics": true,
        "title": "Top queries by {qdsAggregation} {qdsMetricLabelMidsentenceCase}",
        "noDataMessage": "There is no data for specified parameters.",
        "exportedParameters": [
          {
            "fieldName": "query_sql_text_json",
            "parameterName": "query_sql_text_json",
            "defaultValue": "\"<Select a query>\""
          },
          {
            "fieldName": "q_id",
            "parameterName": "query_id",
            "parameterType": 1,
            "defaultValue": "0"
          },
          {
            "fieldName": "query_hash",
            "parameterName": "query_hash",
            "parameterType": 1,
            "defaultValue": "\"\""
          },
          {
            "fieldName": "multi_query_text_warning",
            "parameterName": "multi_query_text_warning",
            "parameterType": 1
          },
          {
            "fieldName": "ranks",
            "parameterName": "ranks",
            "parameterType": 1
          },
          {
            "fieldName": "database_id",
            "parameterName": "database_id",
            "parameterType": 1,
            "defaultValue": "0"
          }
        ],
        "showExportToExcel": true,
        "queryType": 9,
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            },
            {
              "columnMatch": "count_successful_executions",
              "formatter": 5
            },
            {
              "columnMatch": "count_aborted_executions",
              "formatter": 5
            },
            {
              "columnMatch": "count_exception_executions",
              "formatter": 5
            },
            {
              "columnMatch": "duration_us",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 22,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "cpu_time_us",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 22,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "logical_io_reads",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "logical_io_writes",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "physical_io_reads",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "24ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "num_physical_io_reads",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "24ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "clr_time_us",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 22,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "dop",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "14ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "query_max_used_memory_kb",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 3,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "rowcount",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "log_bytes_used",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 2,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "tempdb_space_used_kb",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 3,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "query_sql_text_json",
              "formatter": 5
            },
            {
              "columnMatch": "multi_query_text_warning",
              "formatter": 5
            },
            {
              "columnMatch": "ranks",
              "formatter": 5
            }
          ],
          "filter": true,
          "labelSettings": [
            {
              "columnId": "query_hash",
              "label": "Query hash"
            },
            {
              "columnId": "database_name_agg",
              "label": "Database"
            },
            {
              "columnId": "query_sql_text",
              "label": "Query text"
            },
            {
              "columnId": "count_executions",
              "label": "Executions"
            },
            {
              "columnId": "duration_us",
              "label": "Duration"
            },
            {
              "columnId": "cpu_time_us",
              "label": "CPU time"
            },
            {
              "columnId": "logical_io_reads",
              "label": "Logical reads"
            },
            {
              "columnId": "logical_io_writes",
              "label": "Logical writes"
            },
            {
              "columnId": "physical_io_reads",
              "label": "Physical reads (pages)"
            },
            {
              "columnId": "num_physical_io_reads",
              "label": "Physical reads (IOs)"
            },
            {
              "columnId": "clr_time_us",
              "label": "CLR time"
            },
            {
              "columnId": "dop",
              "label": "DOP"
            },
            {
              "columnId": "query_max_used_memory_kb",
              "label": "Memory grant"
            },
            {
              "columnId": "rowcount",
              "label": "Rows"
            },
            {
              "columnId": "log_bytes_used",
              "label": "Log space"
            },
            {
              "columnId": "tempdb_space_used_kb",
              "label": "Tempdb space"
            },
            {
              "columnId": "sql_module_name_agg",
              "label": "SQL module"
            },
            {
              "columnId": "context_settings_id_agg",
              "label": "Context settings ID"
            }
          ]
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isEqualTo",
          "value": "grid"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_top_queries_grid"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "ef3541b2-fdd5-4705-8689-b9ce167c1767",
            "version": "KqlParameterItem/1.0",
            "name": "qdsAnyWaits",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_wait_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| count\\r\\n| project Count = tostring(Count)\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          }
        ],
        "style": "pills",
        "queryType": 9
      },
      "conditionalVisibility": {
        "parameterName": "sqlserver_query_wait_stats",
        "comparison": "isEqualTo",
        "value": "1"
      },
      "name": "qds_waits_existence_parameters"
    },
    {
      "type": 1,
      "content": {
        "json": "{multi_query_text_warning}",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "multi_query_text_warning",
          "comparison": "isNotEqualTo",
          "value": ""
        },
        {
          "parameterName": "multi_query_text_warning",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        }
      ],
      "name": "multi_query_text_warning"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"datatable(ranks:dynamic)[dynamic({ranks})]\\r\\n| mv-expand bagexpansion=array ranks\\r\\n| mv-expand metric = ranks.Metric to typeof(string), rank = ranks.Rank to typeof(int), value = ranks.Value to typeof(real)\\r\\n| where value > 0 // Do not include high ranks if usage is zero\\r\\n| where not (metric==\\\"DOP\\\" and value==1 or metric==\\\"Executions\\\" and value==1 or metric==\\\"Rows\\\" and value==1) // Do not consider trivial usage\\r\\n| project r=rank, metric, rank\\r\\n| sort by rank asc, metric asc;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 1,
        "title": "Query ranks",
        "noDataMessage": "Selected query is not ranked high by any metric",
        "queryType": 9,
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "r",
              "formatter": 18,
              "formatOptions": {
                "thresholdsOptions": "icons",
                "thresholdsGrid": [
                  {
                    "operator": "<=",
                    "thresholdValue": "1",
                    "representation": "Sev0",
                    "text": "[\"metric\"]"
                  },
                  {
                    "operator": "<=",
                    "thresholdValue": "3",
                    "representation": "Sev1",
                    "text": "[\"metric\"]"
                  },
                  {
                    "operator": "<=",
                    "thresholdValue": "10",
                    "representation": "Sev2",
                    "text": "[\"metric\"]"
                  },
                  {
                    "operator": "<=",
                    "thresholdValue": "20",
                    "representation": "Sev3",
                    "text": "[\"metric\"]"
                  },
                  {
                    "operator": "Default",
                    "thresholdValue": null,
                    "representation": "Sev4",
                    "text": "[\"metric\"]"
                  }
                ],
                "customColumnWidthSetting": "27ch"
              }
            },
            {
              "columnMatch": "metric",
              "formatter": 5
            },
            {
              "columnMatch": "rank",
              "formatter": 0,
              "tooltipFormat": {
                "tooltip": "Lower numbers mean higher ranks, i.e. higher resource consumption for this metric"
              }
            }
          ],
          "labelSettings": [
            {
              "columnId": "r",
              "label": "Metric"
            },
            {
              "columnId": "rank",
              "label": "Rank"
            }
          ]
        },
        "sortBy": [],
        "tileSettings": {
          "titleContent": {
            "formatter": 1
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "hotCold"
            },
            "tooltipFormat": {
              "tooltip": "Rank 1 by \"CPU time\" means that the query is the top consumer of CPU, compared to other queries in the same time interval. The metrics ranked in the 1-10 range, if any for this query, are shown."
            }
          },
          "rightContent": {
            "columnMatch": "metric",
            "formatter": 1
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "ranks",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "customWidth": "25",
      "name": "top_query_ranks"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_wait_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| summarize query_wait_time_ms = case(\\r\\n                                     \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(toreal(total_query_wait_time_ms)),\\r\\n                                     \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_wait_time_ms),\\r\\n                                     \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_wait_time_ms)),\\r\\n                                     \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_wait_time_ms)),\\r\\n                                     \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_wait_time_ms), // use maximum stdev for the interval\\r\\n                                     real(null)\\r\\n                                     )\\r\\n            by wait_category_desc\\r\\n\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 1,
        "title": "Query wait categories",
        "noDataMessage": "There is no data for specified parameters.",
        "queryType": 9,
        "visualization": "barchart",
        "chartSettings": {
          "yAxis": [
            "query_wait_time_ms"
          ],
          "showMetrics": false,
          "seriesLabelSettings": [
            {
              "seriesName": "Unknown",
              "color": "gray"
            },
            {
              "seriesName": "CPU",
              "color": "magenta"
            },
            {
              "seriesName": "Worker Thread",
              "color": "brown"
            },
            {
              "seriesName": "Lock",
              "color": "redBright"
            },
            {
              "seriesName": "Latch",
              "color": "blueDark"
            },
            {
              "seriesName": "Buffer Latch",
              "color": "purple"
            },
            {
              "seriesName": "Buffer IO",
              "color": "lightBlue"
            },
            {
              "seriesName": "Tran Log IO",
              "color": "green"
            },
            {
              "seriesName": "Network IO",
              "color": "greenDark"
            },
            {
              "seriesName": "Parallelism",
              "color": "orange"
            },
            {
              "seriesName": "Memory",
              "color": "turquoise"
            },
            {
              "seriesName": "Other Disk IO",
              "color": "grayBlue"
            },
            {
              "seriesName": "Replication",
              "color": "pink"
            },
            {
              "seriesName": "Log Rate Governor",
              "color": "red"
            }
          ],
          "ySettings": {
            "numberFormatSettings": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "sqlserver_query_wait_stats",
          "comparison": "isEqualTo",
          "value": "1"
        },
        {
          "parameterName": "qdsAnyWaits",
          "comparison": "isNotEqualTo",
          "value": "0"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "customWidth": "25",
      "name": "qds_query_wait_categories"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"1.0.0\",\"content\":\"{query_sql_text_json}\",\"transformers\":null}",
        "size": 1,
        "title": "Query SQL text",
        "noDataMessage": "Unknown",
        "queryType": 8,
        "visualization": "card",
        "textSettings": {
          "style": "editor"
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "customWidth": "50",
      "name": "query_sql_text"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "title": "Selected top query in individual databases",
        "expandable": true,
        "items": [
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| summarize dcount_sql_module_name = dcount(sql_module_name),\\r\\n            any_sql_module_name = take_any(sql_module_name),\\r\\n            dcount_context_settings_id = dcount(context_settings_id),\\r\\n            any_context_settings_id = take_any(context_settings_id),\\r\\n            dcount_plan_id = dcount(plan_id),\\r\\n            any_plan_id = take_any(plan_id),\\r\\n            dcount_query_plan_hash = dcount(query_plan_hash),\\r\\n            any_query_plan_hash = take_any(query_plan_hash),\\r\\n            count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", round(avg(count_executions), 2),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            count_successful_executions = case(\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", round(avgif(count_executions, execution_type_desc == \\\"Regular\\\"), 2),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"min\\\", minif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"max\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Regular\\\"),\\r\\n                                              real(null)\\r\\n                                              ),\\r\\n            count_aborted_executions = case(\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", round(avgif(count_executions, execution_type_desc == \\\"Aborted\\\"), 2),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"min\\\", minif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"max\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Aborted\\\"),\\r\\n                                           real(null)\\r\\n                                           ),\\r\\n            count_exception_executions = case(\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"avg\\\", round(avgif(count_executions, execution_type_desc == \\\"Exception\\\"), 2),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"min\\\", minif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"max\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             \\\"{qdsAggregation}\\\"==\\\"stdev\\\", maxif(toreal(count_executions), execution_type_desc == \\\"Exception\\\"),\\r\\n                                             real(null)\\r\\n                                             ),\\r\\n            duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n            by machine_name, server_name, database_name, query_id\\r\\n| project machine_name,\\r\\n          server_name,\\r\\n          database_name,\\r\\n          query_id,\\r\\n          query_plan_hash_agg = iif(dcount_query_plan_hash == 1, any_query_plan_hash, strcat(any_query_plan_hash, \\\" (+\\\", tostring(dcount_query_plan_hash - 1), \\\")\\\")),\\r\\n          plan_id_agg = iif(dcount_plan_id == 1, tostring(any_plan_id), strcat(any_plan_id, \\\" (+\\\", tostring(dcount_plan_id - 1), \\\")\\\")),\\r\\n          count_executions,\\r\\n          count_successful_executions,\\r\\n          count_aborted_executions,\\r\\n          count_exception_executions,\\r\\n          duration_us,\\r\\n          cpu_time_us,\\r\\n          logical_io_reads,\\r\\n          logical_io_writes,\\r\\n          physical_io_reads,\\r\\n          num_physical_io_reads,\\r\\n          clr_time_us,\\r\\n          dop,\\r\\n          query_max_used_memory_kb = query_max_used_memory * 8,\\r\\n          rowcount,\\r\\n          log_bytes_used,\\r\\n          tempdb_space_used_kb = tempdb_space_used * 8,\\r\\n          sql_module_name_agg = iif(dcount_sql_module_name == 1, any_sql_module_name, strcat(any_sql_module_name, \\\" (+\\\", tostring(dcount_sql_module_name - 1), \\\")\\\")),\\r\\n          context_settings_id_agg = iif(dcount_context_settings_id == 1, tostring(any_context_settings_id), strcat(any_context_settings_id, \\\" (+\\\", tostring(dcount_context_settings_id - 1), \\\")\\\")),\\r\\n          global_query_id = dynamic_to_json(bag_pack(\\\"machine_name\\\", machine_name, \\\"server_name\\\", server_name, \\\"database_name\\\", database_name, \\\"query_id\\\", query_id))\\r\\n| sort by case(\\r\\n              \\\"{qdsMetric}\\\"==\\\"count_executions\\\", toreal(count_executions),\\r\\n              \\\"{qdsMetric}\\\"==\\\"duration\\\", toreal(duration_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"cpu_time\\\", toreal(cpu_time_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"logical_io_reads\\\", toreal(logical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"logical_io_writes\\\", toreal(logical_io_writes),\\r\\n              \\\"{qdsMetric}\\\"==\\\"physical_io_reads\\\", toreal(physical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"num_physical_io_reads\\\", toreal(num_physical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"clr_time\\\", toreal(clr_time_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"dop\\\", toreal(dop),\\r\\n              \\\"{qdsMetric}\\\"==\\\"query_max_used_memory\\\", toreal(query_max_used_memory_kb),\\r\\n              \\\"{qdsMetric}\\\"==\\\"rowcount\\\", toreal(rowcount),\\r\\n              \\\"{qdsMetric}\\\"==\\\"log_bytes_used\\\", toreal(log_bytes_used),\\r\\n              \\\"{qdsMetric}\\\"==\\\"tempdb_space_used\\\", toreal(tempdb_space_used_kb),\\r\\n              real(null)\\r\\n              ) desc,\\r\\n          count_executions desc // secondary sort for determinism when primary sort is tied\\r\\n;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
              "size": 1,
              "showAnalytics": true,
              "noDataMessage": "There is no data for specified parameters.",
              "exportFieldName": "global_query_id",
              "exportParameterName": "global_query_id",
              "exportDefaultValue": "{\"machine_name\":\"\",\"server_name\":\"\",\"database_name\":\"\",\"query_id\":0}",
              "showExportToExcel": true,
              "queryType": 9,
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "server_name",
                    "formatter": 7,
                    "formatOptions": {
                      "linkTarget": "WorkbookTemplate",
                      "workbookContext": {
                        "componentIdSource": "workbook",
                        "resourceIdsSource": "workbook",
                        "templateIdSource": "static",
                        "templateId": "Community-Workbooks/Database watcher/SQL Server/instance",
                        "typeSource": "workbook",
                        "gallerySource": "default",
                        "locationSource": "workbook",
                        "workbookName": "SQL Server instance",
                        "passSpecificParams": true,
                        "templateParameters": [
                          {
                            "name": "machineName",
                            "source": "column",
                            "value": "machine_name"
                          },
                          {
                            "name": "serverName",
                            "source": "column",
                            "value": "server_name"
                          },
                          {
                            "name": "timeRange",
                            "source": "parameter",
                            "value": "timeRange"
                          },
                          {
                            "name": "linkAdxClusterUri",
                            "source": "parameter",
                            "value": "adxClusterUri"
                          },
                          {
                            "name": "linkAdxDatabase",
                            "source": "parameter",
                            "value": "adxDatabase"
                          },
                          {
                            "name": "tabName",
                            "source": "static",
                            "value": "Top queries"
                          },
                          {
                            "name": "showDescriptions",
                            "source": "parameter",
                            "value": "showDescriptions"
                          }
                        ],
                        "viewerMode": true
                      }
                    }
                  },
                  {
                    "columnMatch": "count_executions",
                    "formatter": 22,
                    "formatOptions": {
                      "compositeBarSettings": {
                        "labelText": "",
                        "columnSettings": [
                          {
                            "columnName": "count_successful_executions",
                            "color": "green"
                          },
                          {
                            "columnName": "count_aborted_executions",
                            "color": "orange"
                          },
                          {
                            "columnName": "count_exception_executions",
                            "color": "red"
                          }
                        ]
                      }
                    },
                    "tooltipFormat": {
                      "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
                    }
                  },
                  {
                    "columnMatch": "count_successful_executions",
                    "formatter": 5
                  },
                  {
                    "columnMatch": "count_aborted_executions",
                    "formatter": 5
                  },
                  {
                    "columnMatch": "count_exception_executions",
                    "formatter": 5
                  },
                  {
                    "columnMatch": "duration_us",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 22,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "cpu_time_us",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 22,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "logical_io_reads",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "logical_io_writes",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "physical_io_reads",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "num_physical_io_reads",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "clr_time_us",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 22,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "dop",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "query_max_used_memory_kb",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 3,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "rowcount",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "log_bytes_used",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 3,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "tempdb_space_used_kb",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 3,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  },
                  {
                    "columnMatch": "global_query_id",
                    "formatter": 5
                  }
                ],
                "filter": true,
                "sortBy": [
                  {
                    "itemKey": "$gen_compositeBar_count_executions_6",
                    "sortOrder": 2
                  }
                ],
                "labelSettings": [
                  {
                    "columnId": "machine_name",
                    "label": "Machine"
                  },
                  {
                    "columnId": "server_name",
                    "label": "Server"
                  },
                  {
                    "columnId": "database_name",
                    "label": "Database"
                  },
                  {
                    "columnId": "query_id",
                    "label": "Query ID"
                  },
                  {
                    "columnId": "query_plan_hash_agg",
                    "label": "Plan hash"
                  },
                  {
                    "columnId": "plan_id_agg",
                    "label": "Plan ID"
                  },
                  {
                    "columnId": "count_executions",
                    "label": "Executions"
                  },
                  {
                    "columnId": "duration_us",
                    "label": "Duration"
                  },
                  {
                    "columnId": "cpu_time_us",
                    "label": "CPU time"
                  },
                  {
                    "columnId": "logical_io_reads",
                    "label": "Logical reads"
                  },
                  {
                    "columnId": "logical_io_writes",
                    "label": "Logical writes"
                  },
                  {
                    "columnId": "physical_io_reads",
                    "label": "Physical reads (pages)"
                  },
                  {
                    "columnId": "num_physical_io_reads",
                    "label": "Physical reads (IOs)"
                  },
                  {
                    "columnId": "clr_time_us",
                    "label": "CLR time"
                  },
                  {
                    "columnId": "dop",
                    "label": "DOP"
                  },
                  {
                    "columnId": "query_max_used_memory_kb",
                    "label": "Memory grant"
                  },
                  {
                    "columnId": "rowcount",
                    "label": "Rows"
                  },
                  {
                    "columnId": "log_bytes_used",
                    "label": "Log space"
                  },
                  {
                    "columnId": "tempdb_space_used_kb",
                    "label": "Tempdb space"
                  },
                  {
                    "columnId": "sql_module_name_agg",
                    "label": "SQL module"
                  },
                  {
                    "columnId": "context_settings_id_agg",
                    "label": "Context settings ID"
                  }
                ]
              },
              "sortBy": [
                {
                  "itemKey": "$gen_compositeBar_count_executions_6",
                  "sortOrder": 2
                }
              ]
            },
            "name": "query_details"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "database_id",
          "comparison": "isNotEqualTo",
          "value": "0"
        }
      ],
      "name": "per_database_details_group"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "5e875829-c0a1-4d00-b853-d90b119a5883",
            "version": "KqlParameterItem/1.0",
            "name": "showPlansAs",
            "label": "Show query plans as",
            "type": 10,
            "description": "Select \"Chart\" to show query plans as bars on a time chart. Select \"Grid\" to show a summary of query plan statistics in a grid.",
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n    {\"value\":\"chart\",\"label\":\"Chart\"},\r\n    {\"value\":\"grid\",\"label\":\"Grid\"}\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "chart"
          },
          {
            "id": "e13aabd4-e4d7-46a7-a1d7-20292f9a521b",
            "version": "KqlParameterItem/1.0",
            "name": "selectedGridPlan",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "{\"plan_id\":0,\"interval_end_time\":\"1900-01-01\"}"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "selectedChartPlan",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "value": "{\"x\":\"1900-01-01\",\"series\":\"\"}",
            "id": "8dafcf7a-df0e-4d9b-83ec-55579bad8df5"
          },
          {
            "id": "b66d1dc9-af20-41b2-8a68-ad2aab7d2ee6",
            "version": "KqlParameterItem/1.0",
            "name": "planTabName",
            "type": 1,
            "isHiddenWhenLocked": true,
            "value": "details"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "query_plan_parameters"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| summarize dcount_databases = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name)),\\r\\n            any_database_name = take_any(database_name),\\r\\n            dcount_plan_id = dcount(strcat(machine_name, \\\"|\\\", server_name, \\\"|\\\", database_name, \\\"|\\\", plan_id)),\\r\\n            any_plan_id = take_any(plan_id),\\r\\n            count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", round(avg(count_executions), 2),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            interval_end_time = max(interval_end_time)\\r\\n            by query_plan_hash,\\r\\n               plan_id = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", plan_id, long(null)),\\r\\n               execution_type_desc,\\r\\n               is_forced_plan,\\r\\n               plan_forcing_type_desc\\r\\n| extend plan_id = iif(isnull(plan_id), any_plan_id, plan_id)\\r\\n| project query_plan_hash,\\r\\n          database_name_agg = iif(dcount_databases == 1, any_database_name, strcat(any_database_name, \\\" (+\\\", tostring(dcount_databases - 1), \\\")\\\")),\\r\\n          plan_id,\\r\\n          interval_end_time,\\r\\n          execution_type_desc,\\r\\n          count_executions,\\r\\n          plan_forcing = case(plan_forcing_type_desc == \\\"AUTO\\\", \\\"Auto\\\", plan_forcing_type_desc == \\\"MANUAL\\\" or is_forced_plan, \\\"Manual\\\", \\\"None\\\"),\\r\\n          duration_us,\\r\\n          cpu_time_us,\\r\\n          logical_io_reads,\\r\\n          logical_io_writes,\\r\\n          physical_io_reads,\\r\\n          num_physical_io_reads,\\r\\n          clr_time_us,\\r\\n          dop,\\r\\n          query_max_used_memory_kb = query_max_used_memory * 8,\\r\\n          rowcount,\\r\\n          log_bytes_used,\\r\\n          tempdb_space_used_kb = tempdb_space_used * 8\\r\\n| sort by case(\\r\\n              \\\"{qdsMetric}\\\"==\\\"count_executions\\\", toreal(count_executions),\\r\\n              \\\"{qdsMetric}\\\"==\\\"duration\\\", toreal(duration_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"cpu_time\\\", toreal(cpu_time_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"logical_io_reads\\\", toreal(logical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"logical_io_writes\\\", toreal(logical_io_writes),\\r\\n              \\\"{qdsMetric}\\\"==\\\"physical_io_reads\\\", toreal(physical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"num_physical_io_reads\\\", toreal(num_physical_io_reads),\\r\\n              \\\"{qdsMetric}\\\"==\\\"clr_time\\\", toreal(clr_time_us),\\r\\n              \\\"{qdsMetric}\\\"==\\\"dop\\\", toreal(dop),\\r\\n              \\\"{qdsMetric}\\\"==\\\"query_max_used_memory\\\", toreal(query_max_used_memory_kb),\\r\\n              \\\"{qdsMetric}\\\"==\\\"rowcount\\\", toreal(rowcount),\\r\\n              \\\"{qdsMetric}\\\"==\\\"log_bytes_used\\\", toreal(log_bytes_used),\\r\\n              \\\"{qdsMetric}\\\"==\\\"tempdb_space_used\\\", toreal(tempdb_space_used_kb),\\r\\n              real(null)\\r\\n              ) desc,\\r\\n          count_executions desc // secondary sort for determinism when primary sort is tied\\r\\n| take 100 // assumption: looking at more than 100 plans is not interesting\\r\\n;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 1,
        "showAnalytics": true,
        "title": "{qdsAggregation:label} metrics by query plan",
        "noDataMessage": "There is no data for specified parameters.",
        "exportFieldName": "",
        "exportParameterName": "selectedGridPlan",
        "exportDefaultValue": "{\"plan_id\":0,\"interval_end_time\":\"\"}",
        "showExportToExcel": true,
        "queryType": 9,
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "plan_id",
              "formatter": 5
            },
            {
              "columnMatch": "interval_end_time",
              "formatter": 5
            },
            {
              "columnMatch": "execution_type_desc",
              "formatter": 18,
              "formatOptions": {
                "thresholdsOptions": "colors",
                "thresholdsGrid": [
                  {
                    "operator": "==",
                    "thresholdValue": "Aborted",
                    "representation": "orange",
                    "text": "{0}{1}"
                  },
                  {
                    "operator": "==",
                    "thresholdValue": "Exception",
                    "representation": "red",
                    "text": "{0}{1}"
                  },
                  {
                    "operator": "Default",
                    "thresholdValue": null,
                    "text": "{0}{1}"
                  }
                ],
                "customColumnWidthSetting": "18ch"
              }
            },
            {
              "columnMatch": "count_executions",
              "formatter": 0,
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            },
            {
              "columnMatch": "plan_forcing",
              "formatter": 18,
              "formatOptions": {
                "thresholdsOptions": "colors",
                "thresholdsGrid": [
                  {
                    "operator": "==",
                    "thresholdValue": "Auto",
                    "representation": "lightBlue",
                    "text": "{0}{1}"
                  },
                  {
                    "operator": "==",
                    "thresholdValue": "Manual",
                    "representation": "magenta",
                    "text": "{0}{1}"
                  },
                  {
                    "operator": "Default",
                    "thresholdValue": null,
                    "text": "{0}{1}"
                  }
                ]
              }
            },
            {
              "columnMatch": "duration_us",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "15ch"
              },
              "numberFormat": {
                "unit": 22,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "cpu_time_us",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 22,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "logical_io_reads",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "logical_io_writes",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "physical_io_reads",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "24ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "num_physical_io_reads",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "22ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "clr_time_us",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 22,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "dop",
              "formatter": 0,
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "query_max_used_memory_kb",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 3,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "rowcount",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 0,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "log_bytes_used",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 2,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            },
            {
              "columnMatch": "tempdb_space_used_kb",
              "formatter": 0,
              "formatOptions": {
                "customColumnWidthSetting": "18ch"
              },
              "numberFormat": {
                "unit": 3,
                "options": {
                  "style": "decimal",
                  "useGrouping": true,
                  "maximumFractionDigits": 2
                }
              }
            }
          ],
          "filter": true,
          "labelSettings": [
            {
              "columnId": "query_plan_hash",
              "label": "Plan hash"
            },
            {
              "columnId": "database_name_agg",
              "label": "Database"
            },
            {
              "columnId": "execution_type_desc",
              "label": "Execution type"
            },
            {
              "columnId": "count_executions",
              "label": "Executions"
            },
            {
              "columnId": "plan_forcing",
              "label": "Forcing"
            },
            {
              "columnId": "duration_us",
              "label": "Duration"
            },
            {
              "columnId": "cpu_time_us",
              "label": "CPU time"
            },
            {
              "columnId": "logical_io_reads",
              "label": "Logical reads"
            },
            {
              "columnId": "logical_io_writes",
              "label": "Logical writes"
            },
            {
              "columnId": "physical_io_reads",
              "label": "Physical reads (pages)"
            },
            {
              "columnId": "num_physical_io_reads",
              "label": "Physical reads (IOs)"
            },
            {
              "columnId": "clr_time_us",
              "label": "CLR time"
            },
            {
              "columnId": "dop",
              "label": "DOP"
            },
            {
              "columnId": "query_max_used_memory_kb",
              "label": "Memory grant"
            },
            {
              "columnId": "rowcount",
              "label": "Rows"
            },
            {
              "columnId": "log_bytes_used",
              "label": "Log space"
            },
            {
              "columnId": "tempdb_space_used_kb",
              "label": "Tempdb space"
            }
          ]
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showPlansAs",
          "comparison": "isEqualTo",
          "value": "grid"
        },
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "showQueriesAs",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_query_plans_grid"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| summarize count_executions = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", round(avg(count_executions), 2),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(count_executions)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(toreal(count_executions)),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_reads = case(\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_reads * count_executions),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_reads),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_reads)),\\r\\n                                   \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_reads),\\r\\n                                   real(null)\\r\\n                                   ),\\r\\n            logical_io_writes = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_logical_io_writes * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_logical_io_writes),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_logical_io_writes)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_logical_io_writes),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            physical_io_reads = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_physical_io_reads * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_physical_io_reads),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_physical_io_reads)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_physical_io_reads),\\r\\n                                    real(null)\\r\\n                                    ),\\r\\n            num_physical_io_reads = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_num_physical_io_reads * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_num_physical_io_reads),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_num_physical_io_reads)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_num_physical_io_reads),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            dop = case(\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"total\\\", sumif(avg_dop * count_executions, is_parallel_plan), // Total DOP for serial queries is meaningless, show as zero\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_dop),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_dop)),\\r\\n                      \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_dop),\\r\\n                      real(null)\\r\\n                      ),\\r\\n            rowcount = case(\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_rowcount * count_executions),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_rowcount),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_rowcount)),\\r\\n                           \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_rowcount),\\r\\n                           real(null)\\r\\n                           )\\r\\n            by query_plan_hash,\\r\\n               plan_id = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", plan_id, long(null)),\\r\\n               interval_end_time\\r\\n| extend metric = case(\\r\\n                      \\\"{qdsMetric}\\\"==\\\"count_executions\\\", toreal(count_executions),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"logical_io_reads\\\", toreal(logical_io_reads),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"logical_io_writes\\\", toreal(logical_io_writes),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"physical_io_reads\\\", toreal(physical_io_reads),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"num_physical_io_reads\\\", toreal(num_physical_io_reads),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"dop\\\", toreal(dop),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"rowcount\\\", toreal(rowcount),\\r\\n                      real(null)\\r\\n                      )\\r\\n| project plan_label = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", strcat(\\\"Plan ID: \\\", tostring(plan_id)), strcat(\\\"Plan hash: \\\", query_plan_hash)),\\r\\n          interval_end_time,\\r\\n          metric\\r\\n| make-series metric = max(metric) default = long(null) on interval_end_time from todatetime(\\\"{qdsStartTime}\\\") to todatetime(\\\"{qdsEndTime}\\\") step {timeRange:grain} by plan_label;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 0,
        "showAnnotations": true,
        "showAnalytics": true,
        "title": "{qdsAggregation:label} {qdsMetricLabelMidsentenceCase} by query plan",
        "noDataMessage": "There is no data for specified parameters.",
        "exportParameterName": "selectedChartPlan",
        "exportDefaultValue": "0",
        "queryType": 9,
        "visualization": "unstackedbar",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            }
          ]
        },
        "tileSettings": {
          "titleContent": {
            "formatter": 1,
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "none"
            },
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "rightContent": {
            "columnMatch": "ranked_metric",
            "formatter": 4,
            "formatOptions": {
              "palette": "coldHot"
            },
            "numberFormat": {
              "unit": 0,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        },
        "chartSettings": {
          "yAxis": [
            "metric"
          ],
          "group": "plan_label",
          "createOtherGroup": null,
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 17,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showPlansAs",
          "comparison": "isEqualTo",
          "value": "chart"
        },
        {
          "parameterName": "qdsMetricUnit",
          "comparison": "isEqualTo",
          "value": "unitless"
        },
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_query_plan_chart_unitless"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| summarize duration_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_duration_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_duration_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_duration_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us), // use maximum stdev for the interval\\r\\n                              real(null)\\r\\n                              ),\\r\\n            cpu_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_cpu_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_cpu_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_cpu_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_cpu_time_us),\\r\\n                              real(null)\\r\\n                              ),\\r\\n            clr_time_us = case(\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_clr_time_us * count_executions),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_clr_time_us),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_clr_time_us)),\\r\\n                              \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_clr_time_us),\\r\\n                              real(null)\\r\\n                              )\\r\\n            by query_plan_hash,\\r\\n               plan_id = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", plan_id, long(null)),\\r\\n               interval_end_time\\r\\n| extend metric = case(\\r\\n                      \\\"{qdsMetric}\\\"==\\\"duration\\\", toreal(duration_us),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"cpu_time\\\", toreal(cpu_time_us),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"clr_time\\\", toreal(clr_time_us),\\r\\n                      real(null)\\r\\n                      )\\r\\n| project plan_label = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", strcat(\\\"Plan ID: \\\", tostring(plan_id)), strcat(\\\"Plan hash: \\\", query_plan_hash)),\\r\\n          interval_end_time,\\r\\n          metric\\r\\n| make-series metric = max(metric) default = long(null) on interval_end_time from todatetime(\\\"{qdsStartTime}\\\") to todatetime(\\\"{qdsEndTime}\\\") step {timeRange:grain} by plan_label;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 0,
        "showAnnotations": true,
        "showAnalytics": true,
        "title": "{qdsAggregation:label} {qdsMetricLabelMidsentenceCase} by query plan",
        "noDataMessage": "There is no data for specified parameters.",
        "exportParameterName": "selectedChartPlan",
        "exportDefaultValue": "0",
        "queryType": 9,
        "visualization": "unstackedbar",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            }
          ]
        },
        "tileSettings": {
          "titleContent": {
            "formatter": 1,
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "none"
            },
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "rightContent": {
            "columnMatch": "ranked_metric",
            "formatter": 4,
            "formatOptions": {
              "palette": "coldHot"
            },
            "numberFormat": {
              "unit": 0,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        },
        "chartSettings": {
          "yAxis": [
            "metric"
          ],
          "group": "plan_label",
          "createOtherGroup": null,
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 22,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showPlansAs",
          "comparison": "isEqualTo",
          "value": "chart"
        },
        {
          "parameterName": "qdsMetricUnit",
          "comparison": "isEqualTo",
          "value": "time"
        },
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_query_plan_chart_time"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| summarize query_max_used_memory = case(\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_query_max_used_memory * count_executions),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_query_max_used_memory),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_query_max_used_memory)),\\r\\n                                        \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_query_max_used_memory),\\r\\n                                        real(null)\\r\\n                                        ),\\r\\n            log_bytes_used = case(\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_log_bytes_used * count_executions),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_log_bytes_used),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_log_bytes_used)),\\r\\n                                 \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_log_bytes_used),\\r\\n                                 real(null)\\r\\n                                 ),\\r\\n            tempdb_space_used = case(\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"total\\\", sum(avg_tempdb_space_used * count_executions),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"avg\\\", avg(avg_tempdb_space_used),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"min\\\", min(toreal(min_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"max\\\", max(toreal(max_tempdb_space_used)),\\r\\n                                    \\\"{qdsAggregation}\\\"==\\\"stdev\\\", max(stdev_tempdb_space_used),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n            by query_plan_hash,\\r\\n               plan_id = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", plan_id, long(null)),\\r\\n               interval_end_time\\r\\n| extend metric = case(\\r\\n                      \\\"{qdsMetric}\\\"==\\\"query_max_used_memory\\\", toreal(query_max_used_memory * 8 * 1024),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"log_bytes_used\\\", toreal(log_bytes_used),\\r\\n                      \\\"{qdsMetric}\\\"==\\\"tempdb_space_used\\\", toreal(tempdb_space_used * 8 * 1024),\\r\\n                      real(null)\\r\\n                      )\\r\\n| project plan_label = iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", strcat(\\\"Plan ID: \\\", tostring(plan_id)), strcat(\\\"Plan hash: \\\", query_plan_hash)),\\r\\n          interval_end_time,\\r\\n          metric\\r\\n| make-series metric = max(metric) default = long(null) on interval_end_time from todatetime(\\\"{qdsStartTime}\\\") to todatetime(\\\"{qdsEndTime}\\\") step {timeRange:grain} by plan_label;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 0,
        "showAnnotations": true,
        "showAnalytics": true,
        "title": "{qdsAggregation:label} {qdsMetricLabelMidsentenceCase} by query plan",
        "noDataMessage": "There is no data for specified parameters.",
        "exportParameterName": "selectedChartPlan",
        "exportDefaultValue": "0",
        "queryType": 9,
        "visualization": "unstackedbar",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "count_executions",
              "formatter": 22,
              "formatOptions": {
                "compositeBarSettings": {
                  "labelText": "",
                  "columnSettings": [
                    {
                      "columnName": "count_successful_executions",
                      "color": "green"
                    },
                    {
                      "columnName": "count_aborted_executions",
                      "color": "orange"
                    },
                    {
                      "columnName": "count_exception_executions",
                      "color": "red"
                    }
                  ]
                }
              },
              "tooltipFormat": {
                "tooltip": "Successful (green), aborted (orange), and exception (red) executions"
              }
            }
          ]
        },
        "tileSettings": {
          "titleContent": {
            "formatter": 1,
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "leftContent": {
            "columnMatch": "rank",
            "formatter": 12,
            "formatOptions": {
              "palette": "none"
            },
            "tooltipFormat": {
              "tooltip": "Query rank"
            }
          },
          "rightContent": {
            "columnMatch": "ranked_metric",
            "formatter": 4,
            "formatOptions": {
              "palette": "coldHot"
            },
            "numberFormat": {
              "unit": 0,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          },
          "showBorder": true,
          "sortCriteriaField": "rank",
          "sortOrderField": 1,
          "size": "auto"
        },
        "chartSettings": {
          "yAxis": [
            "metric"
          ],
          "group": "plan_label",
          "createOtherGroup": null,
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 2,
              "options": {
                "style": "decimal",
                "useGrouping": true,
                "maximumFractionDigits": 2
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "showPlansAs",
          "comparison": "isEqualTo",
          "value": "chart"
        },
        {
          "parameterName": "qdsMetricUnit",
          "comparison": "isEqualTo",
          "value": "bytes"
        },
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsStartTime",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsEndTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "qds_query_plan_chart_bytes"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "5537e73a-2aa9-4f11-9f3b-a1894f13be60",
            "version": "KqlParameterItem/1.0",
            "name": "selectedChartPlanId",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", tolong(replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan ID: \\\", \\\"\\\")), plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan hash: \\\", \\\"\\\"), query_plan_hash)\\r\\n| top 1 by collection_time_utc desc\\r\\n| project plan_id\\r\\n\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          },
          {
            "id": "b551bad3-2098-47d2-ab67-852c93ea574b",
            "version": "KqlParameterItem/1.0",
            "name": "selectedChartPlanHash",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| where query_plan_hash == replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan hash: \\\", \\\"\\\")\\r\\n| top 1 by collection_time_utc desc\\r\\n| project query_plan_hash\\r\\n\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          },
          {
            "id": "3bbed235-3813-4be5-bfe3-0766b4383fe5",
            "version": "KqlParameterItem/1.0",
            "name": "selectedChartIntervalEndTime",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"// Time (x-coordinate) selected on a chart is generated by make-series and is unlikely to match any existing interval_end_time.\\r\\n// Look up the nearest interval_end_time here.\\r\\nunion\\r\\n(\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{selectedChartPlan:$.x}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", tolong(replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan ID: \\\", \\\"\\\")), plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan hash: \\\", \\\"\\\"), query_plan_hash)\\r\\n| summarize interval_end_time = max(interval_end_time)\\r\\n),\\r\\n(\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{selectedChartPlan:$.x}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", tolong(replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan ID: \\\", \\\"\\\")), plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", replace_string(\\\"{selectedChartPlan:$.series}\\\", \\\"Plan hash: \\\", \\\"\\\"), query_plan_hash)\\r\\n| summarize interval_end_time = min(interval_end_time)\\r\\n)\\r\\n| summarize interval_end_time = min(interval_end_time)\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          },
          {
            "id": "046d7500-d82b-43d9-b857-62e350285137",
            "version": "KqlParameterItem/1.0",
            "name": "selectedGridPlanId",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"print plan_id = tolong(\\\"{selectedGridPlan:$.plan_id}\\\")\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          },
          {
            "id": "1d92a89b-f1b1-4642-b09c-fd015f67cf9c",
            "version": "KqlParameterItem/1.0",
            "name": "selectedGridPlanHash",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"print plan_hash = \\\"{selectedGridPlan:$.query_plan_hash}\\\"\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          },
          {
            "id": "aa9ce676-6214-44be-8a4a-af84f775c14e",
            "version": "KqlParameterItem/1.0",
            "name": "selectedGridIntervalEndTime",
            "type": 1,
            "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"print interval_end_time = \\\"{selectedGridPlan:$.interval_end_time}\\\"\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 9
          },
          {
            "id": "e669c402-166b-4e3e-bd6c-2fc79441467a",
            "version": "KqlParameterItem/1.0",
            "name": "selectedPlanId",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "showPlansAs",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "grid",
                  "resultValType": "param",
                  "resultVal": "selectedGridPlanId"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "showPlansAs",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "chart",
                  "resultValType": "param",
                  "resultVal": "selectedChartPlanId"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "0"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "selectedPlanHash",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "showPlansAs",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "grid",
                  "resultValType": "param",
                  "resultVal": "selectedGridPlanHash"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "showPlansAs",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "chart",
                  "resultValType": "param",
                  "resultVal": "selectedChartPlanHash"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "0"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            },
            "id": "120eaca9-83d5-447d-af06-098e53d04674"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "selectedIntervalEndTime",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "showPlansAs",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "grid",
                  "resultValType": "param",
                  "resultVal": "selectedGridIntervalEndTime"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "showPlansAs",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "chart",
                  "resultValType": "param",
                  "resultVal": "selectedChartIntervalEndTime"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "\"1900-01-01\""
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            },
            "id": "903fef93-1c44-4bd7-867e-14b50d01f80e"
          }
        ],
        "style": "pills",
        "queryType": 9
      },
      "name": "selected_plan_parameters"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "links": [
          {
            "id": "96c6627e-1c4f-49cb-86e8-928964ecfc19",
            "cellValue": "planTabName",
            "linkTarget": "parameter",
            "linkLabel": "Plan details",
            "subTarget": "details",
            "style": "link"
          },
          {
            "id": "e8e0a56b-d1d9-46d0-ab32-e5864d25574f",
            "cellValue": "planTabName",
            "linkTarget": "parameter",
            "linkLabel": "Plan XML",
            "subTarget": "xmlPlan",
            "style": "link"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "selectedIntervalEndTime",
          "comparison": "isNotEqualTo",
          "value": "null"
        },
        {
          "parameterName": "selectedPlanId",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "plan_detail_tabs"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let plan_property = datatable(key:int, plan_property_name:string) [\\r\\n1, \\\"engine_version\\\",\\r\\n1, \\\"query_plan_hash\\\",\\r\\n1, \\\"last_force_failure_reason_desc\\\",\\r\\n1, \\\"plan_forcing_type_desc\\\",\\r\\n1, \\\"database_name\\\"\\r\\n];\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time == todatetime(\\\"{selectedIntervalEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {selectedPlanId}, plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", \\\"{selectedPlanHash}\\\", query_plan_hash)\\r\\n| summarize arg_max(interval_end_time, engine_version, query_plan_hash, last_force_failure_reason_desc, plan_forcing_type_desc, database_name)\\r\\n| extend key = int(1)\\r\\n| join kind=inner plan_property on key\\r\\n| project plan_property_name, engine_version, query_plan_hash, last_force_failure_reason_desc, plan_forcing_type_desc, database_name\\r\\n| extend plan_property_value = case(\\r\\n                                    plan_property_name == \\\"engine_version\\\", engine_version,\\r\\n                                    plan_property_name == \\\"query_plan_hash\\\", query_plan_hash,\\r\\n                                    plan_property_name == \\\"last_force_failure_reason_desc\\\", last_force_failure_reason_desc,\\r\\n                                    plan_property_name == \\\"plan_forcing_type_desc\\\", plan_forcing_type_desc,\\r\\n                                    plan_property_name == \\\"database_name\\\", database_name,\\r\\n                                    \\\"\\\"\\r\\n                                    )\\r\\n| project-away engine_version, query_plan_hash, last_force_failure_reason_desc, plan_forcing_type_desc, database_name\\r\\n| sort by plan_property_name asc;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
              "size": 3,
              "showAnalytics": true,
              "noDataMessage": "There is no data for specified parameters.",
              "showExportToExcel": true,
              "queryType": 9,
              "gridSettings": {
                "labelSettings": [
                  {
                    "columnId": "plan_property_name",
                    "label": "Property"
                  },
                  {
                    "columnId": "plan_property_value",
                    "label": "Value"
                  }
                ]
              }
            },
            "customWidth": "33",
            "name": "plan_details_string"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let plan_property = datatable(key:int, plan_property_name:string) [\\r\\n1, \\\"is_parallel_plan\\\",\\r\\n1, \\\"is_forced_plan\\\",\\r\\n1, \\\"is_natively_compiled\\\",\\r\\n1, \\\"has_compile_replay_script\\\"\\r\\n];\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time == todatetime(\\\"{selectedIntervalEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {selectedPlanId}, plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", \\\"{selectedPlanHash}\\\", query_plan_hash)\\r\\n| summarize arg_max(interval_end_time, is_parallel_plan, is_forced_plan, is_natively_compiled, has_compile_replay_script)\\r\\n| extend key = int(1)\\r\\n| join kind=inner plan_property on key\\r\\n| project plan_property_name, is_parallel_plan, is_forced_plan, is_natively_compiled, has_compile_replay_script\\r\\n| extend plan_property_value = case(\\r\\n                                    plan_property_name == \\\"is_parallel_plan\\\", is_parallel_plan,\\r\\n                                    plan_property_name == \\\"is_forced_plan\\\", is_forced_plan,\\r\\n                                    plan_property_name == \\\"is_natively_compiled\\\", is_natively_compiled,\\r\\n                                    plan_property_name == \\\"has_compile_replay_script\\\", has_compile_replay_script,\\r\\n                                    bool(null)\\r\\n                                    )\\r\\n| project-away is_parallel_plan, is_forced_plan, is_natively_compiled, has_compile_replay_script\\r\\n| sort by plan_property_name asc;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
              "size": 3,
              "showAnalytics": true,
              "noDataMessage": "There is no data for specified parameters.",
              "showExportToExcel": true,
              "queryType": 9,
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "plan_property_value",
                    "formatter": 18,
                    "formatOptions": {
                      "thresholdsOptions": "icons",
                      "thresholdsGrid": [
                        {
                          "operator": "==",
                          "thresholdValue": "true",
                          "representation": "Check",
                          "text": ""
                        },
                        {
                          "operator": "==",
                          "thresholdValue": "false",
                          "representation": "Subtract",
                          "text": ""
                        },
                        {
                          "operator": "Default",
                          "thresholdValue": null,
                          "representation": "Blank",
                          "text": "{0}{1}"
                        }
                      ]
                    }
                  }
                ],
                "labelSettings": [
                  {
                    "columnId": "plan_property_name",
                    "label": "Property"
                  },
                  {
                    "columnId": "plan_property_value",
                    "label": "Value"
                  }
                ]
              }
            },
            "customWidth": "33",
            "name": "plan_details_boolean"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let plan_property = datatable(key:int, plan_property_name:string) [\\r\\n1, \\\"plan_id\\\",\\r\\n1, \\\"plan_group_id\\\",\\r\\n1, \\\"force_failure_count\\\",\\r\\n1, \\\"plan_count_compiles\\\",\\r\\n1, \\\"compatibility_level\\\",\\r\\n1, \\\"database_id\\\"\\r\\n];\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time == todatetime(\\\"{selectedIntervalEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {selectedPlanId}, plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", \\\"{selectedPlanHash}\\\", query_plan_hash)\\r\\n| summarize arg_max(interval_end_time, plan_id, plan_group_id, force_failure_count, plan_count_compiles, compatibility_level, database_id)\\r\\n| extend key = int(1)\\r\\n| join kind=inner plan_property on key\\r\\n| project plan_property_name, plan_id, plan_group_id, force_failure_count, plan_count_compiles, compatibility_level, database_id\\r\\n| extend plan_property_value = case(\\r\\n                                    plan_property_name == \\\"plan_id\\\", plan_id,\\r\\n                                    plan_property_name == \\\"plan_group_id\\\", plan_group_id,\\r\\n                                    plan_property_name == \\\"force_failure_count\\\", force_failure_count,\\r\\n                                    plan_property_name == \\\"plan_count_compiles\\\", plan_count_compiles,\\r\\n                                    plan_property_name == \\\"compatibility_level\\\", tolong(compatibility_level),\\r\\n                                    plan_property_name == \\\"database_id\\\", tolong(database_id),\\r\\n                                    long(null)\\r\\n                                    )\\r\\n| project-away plan_id, plan_group_id, force_failure_count, plan_count_compiles, compatibility_level, database_id\\r\\n| sort by plan_property_name asc;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
              "size": 3,
              "showAnalytics": true,
              "noDataMessage": "There is no data for specified parameters.",
              "showExportToExcel": true,
              "queryType": 9,
              "gridSettings": {
                "labelSettings": [
                  {
                    "columnId": "plan_property_name",
                    "label": "Property"
                  },
                  {
                    "columnId": "plan_property_value",
                    "label": "Value"
                  }
                ]
              }
            },
            "customWidth": "33",
            "name": "plan_details_number"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let plan_property = datatable(key:int, plan_property_name:string) [\\r\\n1, \\\"plan_initial_compile_start_time\\\",\\r\\n1, \\\"plan_last_compile_start_time\\\",\\r\\n1, \\\"plan_last_execution_time\\\"\\r\\n];\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time == todatetime(\\\"{selectedIntervalEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {selectedPlanId}, plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", \\\"{selectedPlanHash}\\\", query_plan_hash)\\r\\n| summarize arg_max(interval_end_time, plan_initial_compile_start_time, plan_last_compile_start_time, plan_last_execution_time)\\r\\n| extend key = int(1)\\r\\n| join kind=inner plan_property on key\\r\\n| project plan_property_name, plan_initial_compile_start_time, plan_last_compile_start_time, plan_last_execution_time\\r\\n| extend plan_property_value = case(\\r\\n                                    plan_property_name == \\\"plan_initial_compile_start_time\\\", plan_initial_compile_start_time,\\r\\n                                    plan_property_name == \\\"plan_last_compile_start_time\\\", plan_last_compile_start_time,\\r\\n                                    plan_property_name == \\\"plan_last_execution_time\\\", plan_last_execution_time,\\r\\n                                    datetime(null)\\r\\n                                    )\\r\\n| project-away plan_initial_compile_start_time, plan_last_compile_start_time, plan_last_execution_time\\r\\n| sort by plan_property_name asc;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
              "size": 3,
              "showAnalytics": true,
              "noDataMessage": "There is no data for specified parameters.",
              "showExportToExcel": true,
              "queryType": 9,
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "plan_property_value",
                    "formatter": 6,
                    "dateFormat": {
                      "showUtcTime": null,
                      "formatName": "shortDateTimePattern"
                    }
                  }
                ],
                "labelSettings": [
                  {
                    "columnId": "plan_property_name",
                    "label": "Property"
                  },
                  {
                    "columnId": "plan_property_value",
                    "label": "Value"
                  }
                ]
              }
            },
            "customWidth": "33",
            "name": "plan_details_datetime"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"let plan_property = datatable(key:int, plan_property_name:string) [\\r\\n1, \\\"plan_avg_compile_duration\\\",\\r\\n1, \\\"plan_last_compile_duration\\\"\\r\\n];\\r\\nsqlserver_query_runtime_stats\\r\\n| where interval_end_time == todatetime(\\\"{selectedIntervalEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {selectedPlanId}, plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", \\\"{selectedPlanHash}\\\", query_plan_hash)\\r\\n| summarize arg_max(interval_end_time, plan_avg_compile_duration_us, plan_last_compile_duration_us)\\r\\n| extend key = int(1)\\r\\n| join kind=inner plan_property on key\\r\\n| project plan_property_name, plan_avg_compile_duration_us, plan_last_compile_duration_us\\r\\n| extend plan_property_value = case(\\r\\n                                    plan_property_name == \\\"plan_avg_compile_duration\\\", plan_avg_compile_duration_us,\\r\\n                                    plan_property_name == \\\"plan_last_compile_duration\\\", toreal(plan_last_compile_duration_us),\\r\\n                                    real(null)\\r\\n                                    )\\r\\n| project-away plan_avg_compile_duration_us, plan_last_compile_duration_us\\r\\n| sort by plan_property_name asc;\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
              "size": 3,
              "showAnalytics": true,
              "noDataMessage": "There is no data for specified parameters.",
              "showExportToExcel": true,
              "queryType": 9,
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "plan_property_value",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 22,
                      "options": {
                        "style": "decimal",
                        "useGrouping": true
                      }
                    }
                  }
                ],
                "labelSettings": [
                  {
                    "columnId": "plan_property_name",
                    "label": "Property"
                  },
                  {
                    "columnId": "plan_property_value",
                    "label": "Value"
                  }
                ]
              }
            },
            "customWidth": "33",
            "name": "plan_details_duration"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "planTabName",
          "comparison": "isEqualTo",
          "value": "details"
        },
        {
          "parameterName": "selectedPlanId",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "plan_details_group"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"AzureDataExplorerQuery/1.0\",\"queryText\":\"sqlserver_query_runtime_stats\\r\\n| where interval_start_time >= todatetime(\\\"{qdsStartTime}\\\") and interval_end_time <= todatetime(\\\"{qdsEndTime}\\\")\\r\\n{machineNameFilter}\\r\\n{serverNameFilter}\\r\\n{qdsDatabaseNameFilter}\\r\\n| where execution_type in ({qdsExecutionType})\\r\\n// always filter by query hash; additionally, if a query_id in a specific database is selected, restrict to plans for that query\\r\\n| where query_hash == \\\"{query_hash}\\\"\\r\\n| where machine_name == iif(\\\"{global_query_id:$.machine_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.machine_name}\\\", machine_name)\\r\\n| where server_name == iif(\\\"{global_query_id:$.server_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.server_name}\\\", server_name)\\r\\n| where database_name == iif(\\\"{global_query_id:$.database_name}\\\" != \\\"null\\\", \\\"{global_query_id:$.database_name}\\\", database_name)\\r\\n| where query_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {global_query_id:$.query_id}, query_id)\\r\\n| where plan_id == iif(\\\"{global_query_id:$.query_id}\\\" != \\\"0\\\", {selectedPlanId}, plan_id)\\r\\n| where query_plan_hash == iif(\\\"{global_query_id:$.query_id}\\\" == \\\"0\\\", \\\"{selectedPlanHash}\\\", query_plan_hash)\\r\\n| summarize arg_max(interval_end_time, query_plan)\\r\\n| project query_plan\",\"clusterName\":\"{adxClusterUri}\",\"databaseName\":\"{adxDatabase}\"}",
        "size": 3,
        "noDataMessage": "Unknown",
        "queryType": 9,
        "visualization": "card",
        "textSettings": {
          "style": "editor"
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "query_hash",
          "comparison": "isNotEqualTo",
          "value": "\"\""
        },
        {
          "parameterName": "qdsMetric",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsAggregation",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "qdsTopQueryCount",
          "comparison": "isNotEqualTo"
        },
        {
          "parameterName": "selectedIntervalEndTime",
          "comparison": "isNotEqualTo",
          "value": "null"
        },
        {
          "parameterName": "planTabName",
          "comparison": "isEqualTo",
          "value": "xmlPlan"
        },
        {
          "parameterName": "selectedPlanId",
          "comparison": "isNotEqualTo"
        }
      ],
      "customWidth": "50",
      "name": "query_xml_plan"
    }
  ],
  "$schema": "https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json"
}