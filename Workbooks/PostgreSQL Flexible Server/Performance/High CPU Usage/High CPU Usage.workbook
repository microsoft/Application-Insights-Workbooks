{
  "version": "Notebook/1.0",
  "items": [
    {
      "type": 1,
      "content": {
        "json": "## Optimizing high CPU utilization\r\n\r\nIn this troubleshooting guide we will try to identify the probable causes of high CPU utilization and possible fixes to mitigate the issue.\r\n\r\nHigh CPU utilization can be caused by several reasons which include increased workload, slow running queries, increased number of connections on the server or suboptimal statistics in tables because autovacuum is not catching up with the workload. The table below highlights each step that needs to be followed using the troubleshooting guide to understand the behavior on the server.</h6>",
        "style": "info"
      },
      "name": "high cpu header"
    },
    {
      "type": 1,
      "content": {
        "json": "Step | Description\r\n--- | ---\r\n**Analysis period** | Choose the time interval that you wish to analyze.\r\n**CPU** | Use the `CPU` tab to analyze and understand `CPU` usage on the server. Any spike in values compared to previous time intervals can be considered unusual and needing further investigation.\r\n**Workload** | Analyze and understand what proportion of `read` and `write` your workload is composed of. Read workload includes all reads made by any type of statement, not only SELECTs. While write workload includes all modifications (inserts, deletes or updates) made by any type of statement, including SELECTs. Compare the CPU spike seen in **CPU** step with read and write workloads. Any spike in workload during the window of interest points to increased workload on server.\r\n**Transactions** | Use the `Transactions` tab to analyze transaction trends on the server.\r\n**Long running transactions** | Use the `Long running transactions` tab to identify PIDs which have long running transactions. Follow mitigation steps suggested in the tab and monitor CPU utilization.\r\n**Queries** | Identify queries with highest duration over the period of interest. Follow mitigation steps suggested in the tab and monitor CPU utilization.\r\n**User connections** | Use `User connections` tab to understand the connectivity patterns of your client applications. Follow mitigation steps suggested in the tab and monitor CPU Usage.\r\n**Locking and blocking** | Use the `Locking and blocking` tab to understand patterns on which locks are acquired and released, or which processes are blocked by others.\r\n"
      },
      "name": "high cpu workbook grid",
      "styleSettings": {
        "margin": "100",
        "padding": "100"
      }
    },
    {
      "type": 1,
      "content": {
        "json": "#### Start by setting the following parameters:"
      },
      "name": "high cpu parameter set all"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Subscription}"
        ],
        "parameters": [
          {
            "id": "778f33f0-034d-4a5b-a7c7-9b990f81d7ea",
            "version": "KqlParameterItem/1.0",
            "name": "Resource",
            "type": 5,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false,
              "componentIdOnly": true
            }
          },
          {
            "id": "9ebd8e9a-5e9c-496a-bdb1-e41b9faaf9ad",
            "version": "KqlParameterItem/1.0",
            "name": "TimeRange",
            "type": 4,
            "description": "Defines the time window on which you want to focus your analysis. Notice that it refers to your local time.",
            "isRequired": true,
            "isGlobal": true,
            "value": {
              "durationMs": 86400000
            },
            "typeSettings": {
              "selectableValues": [
                {
                  "durationMs": 3600000
                },
                {
                  "durationMs": 14400000
                },
                {
                  "durationMs": 43200000
                },
                {
                  "durationMs": 86400000
                },
                {
                  "durationMs": 172800000
                },
                {
                  "durationMs": 259200000
                },
                {
                  "durationMs": 604800000
                },
                {
                  "durationMs": 1209600000
                },
                {
                  "durationMs": 2419200000
                }
              ],
              "allowCustom": true
            },
            "timeContext": {
              "durationMs": 86400000
            },
            "label": "Analysis period (local time)"
          },
          {
            "id": "f8678c39-7dad-4aef-aae1-d67793e82c01",
            "version": "KqlParameterItem/1.0",
            "name": "MIN_TIME_WINDOW_SEC",
            "type": 1,
            "description": "Defines the minimum duration a connection may exist before it is classified as long lived.",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "3600"
                }
              }
            ]
          },
          {
            "id": "13ee21e4-ee50-48cd-880d-6ea3b62d96c3",
            "version": "KqlParameterItem/1.0",
            "name": "HIGH_CONNECTION_COUNT",
            "type": 1,
            "description": "Defines the minimum number of connections before server is classified as having a high connection count.",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "150"
                }
              }
            ]
          },
          {
            "id": "e9948714-d7f2-45f2-bd63-0ba9a493962b",
            "version": "KqlParameterItem/1.0",
            "name": "LONG_RUNNING_QUERY_SEC_DURATION_THRESHOLD",
            "type": 1,
            "description": "Defines the minimum number of seconds a query can take before it is classified in this workbook as long running.",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7200"
                }
              }
            ]
          },
          {
            "id": "e43a4f05-b912-4815-870d-e22141b050fc",
            "version": "KqlParameterItem/1.0",
            "name": "WINDOW_SIZE_FOR_QUERY_TIME_CAPTURE",
            "type": 1,
            "description": "Defines the aggregation window to capture maximum query duration for queries with highest duration.",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "30m"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "MIN_XACT_TIME_MS_THRESHOLD_FOR_LONG_XACTS",
            "type": 1,
            "description": "Defines the minimum duration a connection may exist before it is classified as long lived.",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7200000"
                }
              }
            ],
            "id": "e43b3ea3-5702-449e-8da6-fcba878649f9"
          },
          {
            "id": "8cbf68c1-e64a-4286-928b-f248a99a4989",
            "version": "KqlParameterItem/1.0",
            "name": "QueryStoreTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} - 1h and TimeGenerated <= {TimeRange:end} + 1h | where Category =='PostgreSQLFlexQueryStoreRuntime'  | project TimeGenerated, RuntimeStatsEntryId = tolong(     iff(isnotempty(AdditionalFields.Runtime_stats_entry_id), AdditionalFields.Runtime_stats_entry_id,         column_ifexists('Runtime_stats_entry_id_d',             column_ifexists('Runtime_stats_entry_id',                 column_ifexists('Runtime_stats_entry_id_s', \"\")             )         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Userid), AdditionalFields.Userid,         column_ifexists('Userid_d',             column_ifexists('Userid',                 column_ifexists('Userid_s', \"\")             )         )     ) ), DatabaseId = toint(     iff(isnotempty(AdditionalFields.Dbid), AdditionalFields.Dbid,         column_ifexists('Dbid_d',             column_ifexists('Dbid',                 column_ifexists('Dbid_s', \"\")             )         )     ) ), QueryId = iff(isnotempty(AdditionalFields.Queryid_str), tostring(AdditionalFields.Queryid_str),      iff(isnotempty(AdditionalFields.Queryid), tostring(AdditionalFields.Queryid),          iff(isnotempty(column_ifexists('Queryid_str_s', \"\")), tostring(column_ifexists('Queryid_str_s', \"\")),              iff(isnotempty(column_ifexists('Queryid_d', \"\")), tostring(column_ifexists('Queryid_d', \"\")),                  iff(isnotempty(column_ifexists('Queryid', \"\")), tostring(column_ifexists('Queryid', \"\")), tostring(column_ifexists('Queryid_s', \"\")))             )         )     ) ), PlanId = tolong(     iff(isnotempty(AdditionalFields.Plan_id), AdditionalFields.Plan_id,         column_ifexists('Plan_id_d',             column_ifexists('Plan_id_s',                 column_ifexists('Plan_id', \"\")             )         )     ) ), StartTime = todatetime(     iff(isnotempty(AdditionalFields.Start_time), AdditionalFields.Start_time,         column_ifexists('Start_time_t',             column_ifexists('Start_time',                 column_ifexists('Start_time_s', \"\")             )         )     ) ), EndTime = todatetime(     iff(isnotempty(AdditionalFields.End_time), AdditionalFields.End_time,         column_ifexists('End_time_t',             column_ifexists('End_time',                 column_ifexists('End_time_s', \"\")             )         )     ) ), Calls = tolong(     iff(isnotempty(AdditionalFields.Calls), AdditionalFields.Calls,         column_ifexists('Calls_d',             column_ifexists('Calls',                 column_ifexists('Calls_s', \"\")             )         )     ) ), TotalExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Total_time), AdditionalFields.Total_time,         column_ifexists('Total_time_d',             column_ifexists('Total_time',                 column_ifexists('Total_time_s', \"\")             )         )     ) ), MinExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Min_time), AdditionalFields.Min_time,         column_ifexists('Min_time_d',             column_ifexists('Min_time',                 column_ifexists('Min_time_s', \"\")             )         )     ) ), MaxExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Max_time), AdditionalFields.Max_time,         column_ifexists('Max_time_d',             column_ifexists('Max_time',                 column_ifexists('Max_time_s', \"\")             )         )     ) ), MeanExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Mean_time), AdditionalFields.Mean_time,         column_ifexists('Mean_time_d',             column_ifexists('Mean_time',                 column_ifexists('Mean_time_s', \"\")             )         )     ) ), StdDevExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Stddev_time), AdditionalFields.Stddev_time,         column_ifexists('Stddev_time_d',             column_ifexists('Stddev_time',                 column_ifexists('Stddev_time_s', \"\")             )         )     ) ), Rows = tolong(     iff(isnotempty(AdditionalFields.Rows), AdditionalFields.Rows,         column_ifexists('Rows_d',             column_ifexists('Rows',                 column_ifexists('Rows_s', \"\")             )         )     ) ), SharedBlksHit = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_hit), AdditionalFields.Shared_blks_hit,         column_ifexists('Shared_blks_hit_d',             column_ifexists('Shared_blks_hit',                 column_ifexists('Shared_blks_hit_s', \"\")             )         )     ) ), SharedBlksRead = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_read), AdditionalFields.Shared_blks_read,         column_ifexists('Shared_blks_read_d',             column_ifexists('Shared_blks_read',                 column_ifexists('Shared_blks_read_s', \"\")             )         )     ) ), SharedBlksDirtied = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_dirtied), AdditionalFields.Shared_blks_dirtied,         column_ifexists('Shared_blks_dirtied_d',             column_ifexists('Shared_blks_dirtied',                 column_ifexists('Shared_blks_dirtied_s', \"\")             )         )     ) ), SharedBlksWritten = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_written), AdditionalFields.Shared_blks_written,         column_ifexists('Shared_blks_written_d',             column_ifexists('Shared_blks_written',                 column_ifexists('Shared_blks_written_s', \"\")             )         )     ) ), LocalBlksHit = tolong(     iff(isnotempty(AdditionalFields.Local_blks_hit), AdditionalFields.Local_blks_hit,         column_ifexists('Local_blks_hit_d',             column_ifexists('Local_blks_hit',                 column_ifexists('Local_blks_hit_s', \"\")             )         )     ) ), LocalBlksRead = tolong(     iff(isnotempty(AdditionalFields.Local_blks_read), AdditionalFields.Local_blks_read,         column_ifexists('Local_blks_read_d',             column_ifexists('Local_blks_read',                 column_ifexists('Local_blks_read_s', \"\")             )         )     ) ), LocalBlksDirtied = tolong(     iff(isnotempty(AdditionalFields.Local_blks_dirtied), AdditionalFields.Local_blks_dirtied,         column_ifexists('Local_blks_dirtied_d',             column_ifexists('Local_blks_dirtied',                 column_ifexists('Local_blks_dirtied_s', \"\")             )         )     ) ), LocalBlksWritten = tolong(     iff(isnotempty(AdditionalFields.Local_blks_written), AdditionalFields.Local_blks_written,         column_ifexists('Local_blks_written_d',             column_ifexists('Local_blks_written',                 column_ifexists('Local_blks_written_s', \"\")             )         )     ) ), TempBlksRead = tolong(     iff(isnotempty(AdditionalFields.Temp_blks_read), AdditionalFields.Temp_blks_read,         column_ifexists('Temp_blks_read_d',             column_ifexists('Temp_blks_read',                 column_ifexists('Temp_blks_read_s', \"\")             )         )     ) ), TempBlksWritten = tolong(     iff(isnotempty(AdditionalFields.Temp_blks_written), AdditionalFields.Temp_blks_written,         column_ifexists('Temp_blks_written_d',             column_ifexists('Temp_blks_written',                 column_ifexists('Temp_blks_written_s', \"\")             )         )     ) ), BlkReadTime = todouble(     iff(isnotempty(AdditionalFields.Blk_read_time), AdditionalFields.Blk_read_time,         column_ifexists('Blk_read_time_d',             column_ifexists('Blk_read_time',                 column_ifexists('Blk_read_time_s', \"\")             )         )     ) ), BlkWriteTime = todouble(     iff(isnotempty(AdditionalFields.Blk_write_time), AdditionalFields.Blk_write_time,         column_ifexists('Blk_write_time_d',             column_ifexists('Blk_write_time',                 column_ifexists('Blk_write_time_s', \"\")             )         )     ) ), IsSystemQuery = tobool(     iff(isnotempty(AdditionalFields.Is_system_query), AdditionalFields.Is_system_query,         column_ifexists('Is_system_query_b',             column_ifexists('Is_system_query',                 column_ifexists('Is_system_query_s', false)             )         )     ) ), QueryType = tostring(     iff(isnotempty(AdditionalFields.Query_type), AdditionalFields.Query_type,         column_ifexists('Query_type_s',             column_ifexists('Query_type', \"\")         )     ) ), SearchPath = tostring(     iff(isnotempty(AdditionalFields.Search_path), AdditionalFields.Search_path,         column_ifexists('Search_path_s',             column_ifexists('Search_path', \"\")         )     ) ), SearchPathCaptureStatus = tostring(     iff(isnotempty(AdditionalFields.Search_path_capture_status), AdditionalFields.Search_path_capture_status,         column_ifexists('Search_path_capture_status_s',             column_ifexists('Search_path_capture_status', \"\")         )     ) ), ParametersCaptureStatus = tostring(     iff(isnotempty(AdditionalFields.Parameters_capture_status), AdditionalFields.Parameters_capture_status,         column_ifexists('Parameters_capture_status_s',             column_ifexists('Parameters_capture_status', \"\")         )     ) ) | union isfuzzy=true PGSQLQueryStoreRuntime"
                }
              }
            ]
          },
          {
            "id": "7f241474-2356-49f4-bbac-1d528f3210e5",
            "version": "KqlParameterItem/1.0",
            "name": "SessionsTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category == 'PostgreSQLFlexSessions' | project TimeGenerated, DatabaseId = toint(     iff(isnotempty(AdditionalFields.Datid), AdditionalFields.Datid,         column_ifexists('Datid_d',             column_ifexists('Datid_s',                 column_ifexists('Datid', \"\")             )         )     ) ), DatabaseName = tostring(     iff(isnotempty(AdditionalFields.Database_name), AdditionalFields.Database_name,         column_ifexists('Database_name_s',             column_ifexists('Database_name', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.Pid), AdditionalFields.Pid,         column_ifexists('Pid_d',             column_ifexists('Pid', \"\")         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Usesysid), AdditionalFields.Usesysid,         column_ifexists('Usesysid_d',             column_ifexists('Usesysid_s',                 column_ifexists('Usesysid', \"\")             )         )     ) ), ApplicationName = tostring(     iff(isnotempty(AdditionalFields.Application_name), AdditionalFields.Application_name,         column_ifexists('Application_name_s',             column_ifexists('Application_name', \"\")         )     ) ), ClientIpAddress = tostring(     iff(isnotempty(AdditionalFields.Client_addr), AdditionalFields.Client_addr,         column_ifexists('Client_addr_s',             column_ifexists('Client_addr', \"\")         )     ) ), State = tostring(     iff(isnotempty(AdditionalFields.State), AdditionalFields.State,         column_ifexists('State_s',             column_ifexists('State', \"\")         )     ) ), WaitEventType = tostring(     iff(isnotempty(AdditionalFields.Wait_event_type), AdditionalFields.Wait_event_type,         column_ifexists('Wait_event_type_s',             column_ifexists('Wait_event_type', \"\")         )     ) ), WaitEvent = tostring(     iff(isnotempty(AdditionalFields.Wait_event), AdditionalFields.Wait_event,         column_ifexists('Wait_event_s',             column_ifexists('Wait_event', \"\")         )     ) ), BackendStartTime = todatetime(     iff(isnotempty(AdditionalFields.Backend_start), AdditionalFields.Backend_start,         column_ifexists('Backend_start_t',             column_ifexists('Backend_start',                 column_ifexists('Backend_start_s', \"\")             )         )     ) ), TransactionStartTime = todatetime(     iff(isnotempty(AdditionalFields.Xact_start), AdditionalFields.Xact_start,         column_ifexists('Xact_start_t',             column_ifexists('Xact_start_s',                 column_ifexists('Xact_start', \"\")             )         )     ) ), QueryStartTime = todatetime(     iff(isnotempty(AdditionalFields.Query_start), AdditionalFields.Query_start,         column_ifexists('Query_start_t',             column_ifexists('Query_start_s',                 column_ifexists('Query_start', \"\")             )         )     ) ), StateChangeTime = todatetime(     iff(isnotempty(AdditionalFields.State_change), AdditionalFields.State_change,         column_ifexists('State_change_t',             column_ifexists('State_change_s',                 column_ifexists('State_change', \"\")             )         )     ) ), CollectionTime = todatetime(     iff(isnotempty(AdditionalFields.Collection_time), AdditionalFields.Collection_time,         column_ifexists('Collection_time_t',             column_ifexists('Collection_time_s',                 column_ifexists('Collection_time', \"\")             )         )     ) ), TransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xid), AdditionalFields.Backend_xid,         column_ifexists('Backend_xid_d',             column_ifexists('Backend_xid_s',                 column_ifexists('Backend_xid', \"\")             )         )     ) ), OldestTransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xmin), AdditionalFields.Backend_xmin,         column_ifexists('Backend_xmin_d',             column_ifexists('Backend_xmin_s',                 column_ifexists('Backend_xmin', \"\")             )         )     ) ), BackendType = tostring(     iff(isnotempty(AdditionalFields.Backend_type), AdditionalFields.Backend_type,         column_ifexists('Backend_type_s',             column_ifexists('Backend_type', \"\")         )     ) ) | union isfuzzy=true PGSQLPgStatActivitySessions"
                }
              }
            ]
          },
          {
            "id": "e1c1909b-bda2-4692-b400-b666366a23a6",
            "version": "KqlParameterItem/1.0",
            "name": "MetricsTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureMetrics"
                }
              }
            ]
          },
          {
            "id": "4e301c40-91f2-498d-8c7e-d8e476627646",
            "version": "KqlParameterItem/1.0",
            "name": "TablestatsTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category == 'PostgreSQLFlexTableStats' | project TimeGenerated, DatabaseName = tostring(     iff(isnotempty(AdditionalFields.DatabaseName), AdditionalFields.DatabaseName,         column_ifexists('DatabaseName_s',             column_ifexists('DatabaseName', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.Schemaname), AdditionalFields.Schemaname,         column_ifexists('Schemaname_s',             column_ifexists('Schemaname', \"\")         )     ) ), LiveRowsCount = tolong(     iff(isnotempty(AdditionalFields.N_live_tup), AdditionalFields.N_live_tup,         column_ifexists('N_live_tup_d',             column_ifexists('N_live_tup',                 column_ifexists('N_live_tup_s', \"\")             )         )     ) ), DeadRowsCount = tolong(     iff(isnotempty(AdditionalFields.N_dead_tup), AdditionalFields.N_dead_tup,         column_ifexists('N_dead_tup_d',             column_ifexists('N_dead_tup',                 column_ifexists('N_dead_tup_s', \"\")             )         )     ) ), SeqentialScansCount = tolong(     iff(isnotempty(AdditionalFields.Seq_scan), AdditionalFields.Seq_scan,         column_ifexists('Seq_scan_d',             column_ifexists('Seq_scan',                 column_ifexists('Seq_scan_s', \"\")             )         )     ) ), RowsFromSeqentialScansCount = tolong(     iff(isnotempty(AdditionalFields.Seq_tup_read), AdditionalFields.Seq_tup_read,         column_ifexists('Seq_tup_read_d',             column_ifexists('Seq_tup_read',                 column_ifexists('Seq_tup_read_s', \"\")             )         )     ) ), IndexScansCount = tolong(     iff(isnotempty(AdditionalFields.Idx_scan), AdditionalFields.Idx_scan,         column_ifexists('Idx_scan_d',             column_ifexists('Idx_scan',                 column_ifexists('Idx_scan_s', \"\")             )         )     ) ), RowsFromIndexScansCount = tolong(     iff(isnotempty(AdditionalFields.Idx_tup_fetch), AdditionalFields.Idx_tup_fetch,         column_ifexists('Idx_tup_fetch_d',             column_ifexists('Idx_tup_fetch',                 column_ifexists('Idx_tup_fetch_s', \"\")             )         )     ) ), RowsInsertedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_ins), AdditionalFields.N_tup_ins,         column_ifexists('N_tup_ins_d',             column_ifexists('N_tup_ins',                 column_ifexists('N_tup_ins_s', \"\")             )         )     ) ), RowsUpdatedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_upd), AdditionalFields.N_tup_upd,         column_ifexists('N_tup_upd_d',             column_ifexists('N_tup_upd',                 column_ifexists('N_tup_upd_s', \"\")             )         )     ) ), RowsDeletedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_del), AdditionalFields.N_tup_del,         column_ifexists('N_tup_del_d',             column_ifexists('N_tup_del',                 column_ifexists('N_tup_del_s', \"\")             )         )     ) ), RowsHotUpdatedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_hot_upd), AdditionalFields.N_tup_hot_upd,         column_ifexists('N_tup_hot_upd_d',             column_ifexists('N_tup_hot_upd',                 column_ifexists('N_tup_hot_upd_s', \"\")             )         )     ) ), ModificationsSinceAnalyzeCount = tolong(     iff(isnotempty(AdditionalFields.N_mod_since_analyze), AdditionalFields.N_mod_since_analyze,         column_ifexists('N_mod_since_analyze_d',             column_ifexists('N_mod_since_analyze',                 column_ifexists('N_mod_since_analyze_s', \"\")             )         )     ) ), VacuumCount = tolong(     iff(isnotempty(AdditionalFields.Vacuum_count), AdditionalFields.Vacuum_count,         column_ifexists('Vacuum_count_d',             column_ifexists('Vacuum_count',                 column_ifexists('Vacuum_count_s', \"\")             )         )     ) ), AutovacuumCount = tolong(     iff(isnotempty(AdditionalFields.Autovacuum_count), AdditionalFields.Autovacuum_count,         column_ifexists('Autovacuum_count_d',             column_ifexists('Autovacuum_count',                 column_ifexists('Autovacuum_count_s', \"\")             )         )     ) ), AnalyzeCount = tolong(     iff(isnotempty(AdditionalFields.Analyze_count), AdditionalFields.Analyze_count,         column_ifexists('Analyze_count_d',             column_ifexists('Analyze_count',                 column_ifexists('Analyze_count_s', \"\")             )         )     ) ), AutoanalyzeCount = tolong(     iff(isnotempty(AdditionalFields.Autoanalyze_count), AdditionalFields.Autoanalyze_count,         column_ifexists('Autoanalyze_count_d',             column_ifexists('Autoanalyze_count',                 column_ifexists('Autoanalyze_count_s', \"\")             )         )     ) ), TablesCount = tolong(     iff(isnotempty(AdditionalFields.Tables_counter), AdditionalFields.Tables_counter,         column_ifexists('Tables_counter_d',             column_ifexists('Tables_counter',                 column_ifexists('Tables_counter_s', \"\")             )         )     ) ), TablesVacuumedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_vacuumed), AdditionalFields.Tables_vacuumed,         column_ifexists('Tables_vacuumed_d',             column_ifexists('Tables_vacuumed',                 column_ifexists('Tables_vacuumed_s', \"\")             )         )     ) ), TablesAutovacuumedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_autovacuumed), AdditionalFields.Tables_autovacuumed,         column_ifexists('Tables_autovacuumed_d',             column_ifexists('Tables_autovacuumed',                 column_ifexists('Tables_autovacuumed_s', \"\")             )         )     ) ), TablesAnalyzedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_analyzed), AdditionalFields.Tables_analyzed,         column_ifexists('Tables_analyzed_d',             column_ifexists('Tables_analyzed',                 column_ifexists('Tables_analyzed_s', \"\")             )         )     ) ), TablesAutoanalyzedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_autoanalyzed), AdditionalFields.Tables_autoanalyzed,         column_ifexists('Tables_autoanalyzed_d',             column_ifexists('Tables_autoanalyzed',                 column_ifexists('Tables_autoanalyzed_s', \"\")             )         )     ) ) | union isfuzzy=true PGSQLAutovacuumStats"
                }
              }
            ]
          },
          {
            "id": "c97c5981-2927-49e3-bb7f-28b91a02ecf3",
            "version": "KqlParameterItem/1.0",
            "name": "PGServerLogsTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category == 'PostgreSQLLogs' | project TimeGenerated, LogicalServerName = tostring(     iff(isnotempty(AdditionalFields.LogicalServerName), AdditionalFields.LogicalServerName,         column_ifexists('LogicalServerName_s',            column_ifexists('LogicalServerName', \"\")         )     ) ), ReplicaRole = tostring(     iff(isnotempty(AdditionalFields.ReplicaRole), AdditionalFields.ReplicaRole,         column_ifexists('ReplicaRole_s',            column_ifexists('ReplicaRole', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.processId), AdditionalFields.processId,         column_ifexists('processId_d',             column_ifexists('processId_s',                 column_ifexists('processId', \"\")             )         )     ) ), ErrorLevel = tostring(     iff(isnotempty(AdditionalFields.errorLevel), AdditionalFields.errorLevel,         column_ifexists('errorLevel_s',             column_ifexists('errorLevel', \"\")         )     ) ), SqlErrorCode = tostring(     iff(isnotempty(AdditionalFields.sqlerrcode), AdditionalFields.sqlerrcode,         column_ifexists('sqlerrcode_s',             column_ifexists('sqlerrcode', \"\")         )     ) ), Message = tostring(     iff(isnotempty(AdditionalFields.message), AdditionalFields.message,         column_ifexists('Message',             column_ifexists('message_s', \"\")         )     ) ), Detail = tostring(     iff(isnotempty(AdditionalFields.detail), AdditionalFields.detail,         column_ifexists('detail_s',             column_ifexists('detail', \"\")         )     ) ), DetailLog = tostring(     iff(isnotempty(AdditionalFields.detail_log), AdditionalFields.detail_log,         column_ifexists('detail_log_s',            column_ifexists('detail_log', \"\")         )     ) ), Hint = tostring(     iff(isnotempty(AdditionalFields.hint), AdditionalFields.hint,         column_ifexists('hint_s',             column_ifexists('hint', \"\")         )     ) ), Query = tostring(     iff(isnotempty(AdditionalFields.query), AdditionalFields.query,         column_ifexists('query_s',             column_ifexists('query', \"\")         )     ) ), Context = tostring(     iff(isnotempty(AdditionalFields.context), AdditionalFields.context,         column_ifexists('context_s',             column_ifexists('context', \"\")         )     ) ), Statement = tostring(     iff(isnotempty(AdditionalFields.statement), AdditionalFields.statement,         column_ifexists('statement_s',             column_ifexists('statement', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.schema_name), AdditionalFields.schema_name,         column_ifexists('schema_name_s',             column_ifexists('schema_name', \"\")         )     ) ), TableName = tostring(     iff(isnotempty(AdditionalFields.table_name), AdditionalFields.table_name,         column_ifexists('table_name_s',             column_ifexists('table_name', \"\")         )     ) ), ColumnName = tostring(     iff(isnotempty(AdditionalFields.column_name), AdditionalFields.column_name,         column_ifexists('column_name_s',             column_ifexists('column_name', \"\")         )     ) ), DatatypeName = tostring(     iff(isnotempty(AdditionalFields.datatype_name), AdditionalFields.datatype_name,         column_ifexists('datatype_name_s',             column_ifexists('datatype_name', \"\")         )     ) ), ConstraintName = tostring(     iff(isnotempty(AdditionalFields.constraint_name), AdditionalFields.constraint_name,         column_ifexists('constraint_name_s',             column_ifexists('constraint_name', \"\")         )     ) ), BackendType = tostring(     iff(isnotempty(AdditionalFields.backend_type), AdditionalFields.backend_type,         column_ifexists('backend_type_s',            column_ifexists('backend_type', \"\")         )     ) ) | union isfuzzy=true PGSQLServerLogs"
                }
              }
            ]
          },
          {
            "id": "e8b3a34f-b56a-44a5-9b23-07810aa47995",
            "version": "KqlParameterItem/1.0",
            "name": "MIN_SESSION_TIME_SEC_THRESHOLD_FOR_LONG_SESSIONS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "1200"
                }
              }
            ]
          },
          {
            "id": "1215c1a2-2b3c-44d3-9818-864c8e792049",
            "version": "KqlParameterItem/1.0",
            "name": "AV_LOOK_BACK_DAYS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7d"
                }
              }
            ]
          },
          {
            "id": "3165c85f-3d3f-48d7-882e-1d8fa747655d",
            "version": "KqlParameterItem/1.0",
            "name": "AV_BLOAT_THRESHOLD",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "50"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "SessionTableInsight",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "materialize(     AzureDiagnostics     | where TimeGenerated between (prevStart .. endTime)     | where Category == 'PostgreSQLFlexSessions'     | project         TimeGenerated,         DatabaseId = toint(iff(isnotempty(AdditionalFields.Datid), AdditionalFields.Datid, column_ifexists('Datid_d', column_ifexists('Datid_s', column_ifexists('Datid', \"\"))))),         DatabaseName = tostring(iff(isnotempty(AdditionalFields.Database_name), AdditionalFields.Database_name, column_ifexists('Database_name_s', column_ifexists('Database_name', \"\")))),         ProcessId = toint(iff(isnotempty(AdditionalFields.Pid), AdditionalFields.Pid, column_ifexists('Pid_d', column_ifexists('Pid', \"\")))),         UserId = toint(iff(isnotempty(AdditionalFields.Usesysid), AdditionalFields.Usesysid, column_ifexists('Usesysid_d', column_ifexists('Usesysid_s', column_ifexists('Usesysid', \"\"))))),         ApplicationName = tostring(iff(isnotempty(AdditionalFields.Application_name), AdditionalFields.Application_name, column_ifexists('Application_name_s', column_ifexists('Application_name', \"\")))),         ClientIpAddress = tostring(iff(isnotempty(AdditionalFields.Client_addr), AdditionalFields.Client_addr, column_ifexists('Client_addr_s', column_ifexists('Client_addr', \"\")))),         State = tostring(iff(isnotempty(AdditionalFields.State), AdditionalFields.State, column_ifexists('State_s', column_ifexists('State', \"\")))),         WaitEventType = tostring(iff(isnotempty(AdditionalFields.Wait_event_type), AdditionalFields.Wait_event_type, column_ifexists('Wait_event_type_s', column_ifexists('Wait_event_type', \"\")))),         WaitEvent = tostring(iff(isnotempty(AdditionalFields.Wait_event), AdditionalFields.Wait_event, column_ifexists('Wait_event_s', column_ifexists('Wait_event', \"\")))),         BackendStartTime = todatetime(iff(isnotempty(AdditionalFields.Backend_start), AdditionalFields.Backend_start, column_ifexists('Backend_start_t', column_ifexists('Backend_start', column_ifexists('Backend_start_s', \"\"))))),         TransactionStartTime = todatetime(iff(isnotempty(AdditionalFields.Xact_start), AdditionalFields.Xact_start, column_ifexists('Xact_start_t', column_ifexists('Xact_start_s', column_ifexists('Xact_start', \"\"))))),         QueryStartTime = todatetime(iff(isnotempty(AdditionalFields.Query_start), AdditionalFields.Query_start, column_ifexists('Query_start_t', column_ifexists('Query_start_s', column_ifexists('Query_start', \"\"))))),         StateChangeTime = todatetime(iff(isnotempty(AdditionalFields.State_change), AdditionalFields.State_change, column_ifexists('State_change_t', column_ifexists('State_change_s', column_ifexists('State_change', \"\"))))),         CollectionTime = todatetime(iff(isnotempty(AdditionalFields.Collection_time), AdditionalFields.Collection_time, column_ifexists('Collection_time_t', column_ifexists('Collection_time_s', column_ifexists('Collection_time', \"\"))))),         TransactionId = tolong(iff(isnotempty(AdditionalFields.Backend_xid), AdditionalFields.Backend_xid, column_ifexists('Backend_xid_d', column_ifexists('Backend_xid_s', column_ifexists('Backend_xid', \"\"))))),         OldestTransactionId = tolong(iff(isnotempty(AdditionalFields.Backend_xmin), AdditionalFields.Backend_xmin, column_ifexists('Backend_xmin_d', column_ifexists('Backend_xmin_s', column_ifexists('Backend_xmin', \"\"))))),         BackendType = tostring(iff(isnotempty(AdditionalFields.Backend_type), AdditionalFields.Backend_type, column_ifexists('Backend_type_s', column_ifexists('Backend_type', \"\"))))     | union isfuzzy=true PGSQLPgStatActivitySessions )"
                }
              }
            ],
            "id": "1a01ea1b-eec9-45a8-94b8-366de866211f"
          }
        ],
        "style": "above",
        "queryType": 1,
        "resourceType": "microsoft.resourcegraph/resources"
      },
      "name": "high cpu parameters all"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "86be5e3b-33b7-4355-a24a-243bdd914591",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetEnabledGroups",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.categoryGroup!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.categoryGroup\",\"columnid\":\"CategoryGroup\"}]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "3026f6d9-f060-40d1-87a5-6d18204ada0b",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetAllEnabledCategories",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.category!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.category\",\"columnid\":\"Category\"}]}}]}",
            "queryType": 12
          },
          {
            "id": "477ec0d7-9343-498c-9124-6ab8e638c20c",
            "version": "KqlParameterItem/1.0",
            "name": "LessThanOneHourInterval",
            "type": 1,
            "query": "let interval = 1h;\r\nprint iff({TimeRange:end} - {TimeRange:start} < interval, \"Yes\", \"No\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "75222467-e8dd-49e2-acce-4dd4306b5d20",
            "version": "KqlParameterItem/1.0",
            "name": "QueryStoreCheck",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/pg_qs.query_capture_mode?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^None|NONE|none$\",\"substringReplace\":\"none\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "value": null
          },
          {
            "id": "77b10db0-dfc9-451b-97dd-1e3fbc6ea695",
            "version": "KqlParameterItem/1.0",
            "name": "isQueryStoreEnabled",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "QueryStoreCheck",
                  "operator": "!=",
                  "rightValType": "static",
                  "rightVal": "none",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "56b02e54-1a1d-42f8-a28b-f15880f68523",
            "version": "KqlParameterItem/1.0",
            "name": "HighCPUQueries",
            "type": 1,
            "query": "let dt = {TimeRange:end};\r\nlet GlobalEndTime = iff(dt<now(), dt, now());\r\nlet GlobalStartTime= iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime(GlobalEndTime)-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start});\r\nlet Start_Time = todatetime(GlobalStartTime);\r\nlet End_Time = todatetime(GlobalEndTime);\r\n{QueryStoreTable}\r\n| where todatetime(EndTime) >= Start_Time and todatetime(EndTime) <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n //| summarize max(Mean_time_d) by Queryid_d\r\n| count\r\n| extend HaveQueryIds = iff(Count > 0, \"Yes\", \"No\")\r\n| project HaveQueryIds",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "25b4ff8a-def1-4bf4-81b2-62f9b180ffcb",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimaryAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..properties..replicationRole\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "3313e0fe-1cc6-4cd9-bb5a-a2197f5ed2bf",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimaryCheck",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsServerPrimaryAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "Primary",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "5dab1bb7-fa88-4a62-b1b7-ee99a4a55d4c",
            "version": "KqlParameterItem/1.0",
            "name": "IsAVCatchingUp",
            "type": 1,
            "query": "\r\nlet dt = {TimeRange:end};\r\nlet GlobalEndTime = iff(dt<now(), dt, now());\r\n\r\nlet GlobalStartTime= iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime(GlobalEndTime)-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start});\r\n\r\nlet Start_Time = todatetime(GlobalEndTime)-{AV_LOOK_BACK_DAYS};\r\nlet End_Time = todatetime(GlobalEndTime);\r\nlet MAX_BLOAT_PCT=100;\r\n{TablestatsTable}\r\n| where DatabaseName !in (\"azure_sys\",\"azure_maintenance\")\r\n| where LiveRowsCount >100 and DeadRowsCount >1000\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| summarize LiveTuplesCluster= max(LiveTuplesCluster),DeadTuplesCluster=max(DeadTuplesCluster)  \r\n  by bin(TimeGenerated,1d),DatabaseName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal((DeadTuplesCluster+LiveTuplesCluster))*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n|project TimeGenerated, DatabaseName, BloatRatio\r\n|summarize arg_max(TimeGenerated,latest_bloat_pct=(MAX_BLOAT_PCT-BloatRatio)),arg_min(TimeGenerated,last_bloat_pct=(MAX_BLOAT_PCT-BloatRatio)) by DatabaseName\r\n|extend  pct_bloat_change = toreal(((latest_bloat_pct-last_bloat_pct)/((latest_bloat_pct+last_bloat_pct)/2))*100)\r\n|extend pct_bloat_change = iff(isnan(pct_bloat_change),0.0,pct_bloat_change)\r\n|extend actual_latest_pct=MAX_BLOAT_PCT-latest_bloat_pct\r\n|where pct_bloat_change >{AV_BLOAT_THRESHOLD} or actual_latest_pct >{AV_BLOAT_THRESHOLD}\r\n|project DatabaseName\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "fec93f41-8dbe-4eb5-a7b8-d1cae4b20284",
            "version": "KqlParameterItem/1.0",
            "name": "_SevenDaysAgoTimestamp",
            "type": 1,
            "query": "let dt = {TimeRange:end}-7d;\r\nprint \r\nv=format_datetime(dt, 'MM/dd/yyyy hh:mm tt')",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0
          },
          {
            "id": "092a79be-1a20-481d-9a1e-90c468a0a362",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricsCollectordatabaseActivityOn",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/metrics.collector_database_activity?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^ON|on|On$\",\"substringReplace\":\"ON\"}]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "4e1813b0-d573-4b79-ae58-c74618093e0a",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagAPIMetrics",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.metrics[?(@.category=='AllMetrics' && @.enabled==true)].enabled\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "c45a71df-13b4-468a-90bf-7347fa7027fb",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagAPIPostgreSQLLogs",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..properties..logs[?(@.category=='PostgreSQLLogs')].enabled\",\"columns\":[]}}]}",
            "queryType": 12
          },
          {
            "id": "f153e854-2870-4873-824f-d794a2d34410",
            "version": "KqlParameterItem/1.0",
            "name": "IsQueryStoreRuntimeSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexQueryStoreRuntime",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "228ace36-140b-45dc-8a08-278b4909d980",
            "version": "KqlParameterItem/1.0",
            "name": "IsAllMetricsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagAPIMetrics",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "true",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "aaa581c6-a9e0-4609-ab48-f4e71f079589",
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLLogsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "03b5d513-44ea-4d5a-99e5-8652296d8b60",
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexSessions",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "ea3f24a4-a179-457c-ba4d-38e5354cc863",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricDataExists",
            "type": 1,
            "query": "let dt = {TimeRange:end};\r\nlet GlobalEndTime = iff(dt<now(), dt, now());\r\nlet GlobalStartTime= iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime(GlobalEndTime)-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start});\r\nlet Start_Time = todatetime(GlobalStartTime);\r\nlet End_Time = todatetime(GlobalEndTime);\r\n\r\nlet graph_grain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\n{MetricsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where MetricName == 'xact_total'\r\n| distinct Total,TimeGenerated\r\n|count\r\n| extend metricdata = iff(Count>0,'Yes','No')\r\n| project metricdata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "ed4838c4-67fa-4d97-8869-a274996d9f90",
            "version": "KqlParameterItem/1.0",
            "name": "ConnectionDurationData",
            "type": 1,
            "query": "let dt = {TimeRange:end};\r\nlet GlobalEndTime = iff(dt<now(), dt, now());\r\nlet GlobalStartTime= iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime(GlobalEndTime)-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start});\r\nlet Start_Time = todatetime(GlobalStartTime);\r\nlet End_Time = todatetime(GlobalEndTime);\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"disconnection\"\r\n| distinct TimeGenerated,Message\r\n| extend allmatches=extract_all(@'session.time:(.+)user=(.+)database=(.+)host=(.+).port', Message)\r\n| extend user=trim(@\" \",tostring(allmatches[0][1]) )\r\n| where  user !in ('azuresu','replication')\r\n| count\r\n| extend conndata = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project conndata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_log_min_duration_statement",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/log_min_duration_statement?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "7e0bcbb6-3eea-47a9-bc22-4efa7a7c41d9",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_log_statement",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/log_statement?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"none|NONE\",\"substringReplace\":\"none\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "0bd06db8-3e2a-42e1-b592-c8a136f559dc",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_pgaudit_log",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/pgaudit.log?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "eab50eec-0ba8-44fa-92fa-d6c045eb6aed",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_log_statement_stats",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/log_statement_stats?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"none|NONE\",\"substringReplace\":\"none\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "ad298d50-89b2-4729-bcd5-2ea5213f1be9",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_shared_preload_libraries",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/shared_preload_libraries?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "1f1a7a44-f29a-47e6-b285-e4a50d7683e0",
            "value": null
          },
          {
            "id": "596bfc43-b203-47a2-a6d8-2ecf975b4102",
            "version": "KqlParameterItem/1.0",
            "name": "has_excessive_logging_enabled",
            "type": 1,
            "isRequired": true,
            "query": "let log_min_duration_statement = {fetch_log_min_duration_statement};\r\nlet log_statement = '{fetch_log_statement}';\r\nlet log_statement_stats = '{fetch_log_statement_stats}';\r\nlet pgaudit_log = '{fetch_pgaudit_log}';\r\nlet shared_preload_libraries = '{fetch_shared_preload_libraries}';\r\nlet evaluate_pgaudit_none = iff(pgaudit_log contains 'none', 'none','No');\r\n\r\nlet log_min_duration_statement_text = iif(toint(log_min_duration_statement) >= 0 and toint(log_min_duration_statement) <= 60000, \"- **log_min_duration_statement**: This parameter is currently set to {fetch_log_min_duration_statement}. This value indicates that all SQL statements that run longer than the specified number of milliseconds are logged. A value between 0 and 60000 milliseconds is often considered aggressive, as it can lead to extensive logging, especially if many queries exceed this duration. The optimal setting can vary depending on the nature of your application. It's recommended to adjust this value based on your application's specific needs to strike a balance between performance and the level of detail in the logs.\\n\\n\", \"\");\r\nlet log_statement_text = iif(log_statement contains 'all' or log_statement contains  'mod', \"- **log_statement**: This parameter is currently set to '{fetch_log_statement}'. If this value is 'ALL' or 'mod', it means that all SQL statements are logged. This can generate a large volume of logs and impact performance.\\n\\n\", \"\");\r\n\r\nlet log_statement_stats_text=iif(log_statement_stats contains 'on', \"- **log_statement_stats**: This parameter is currently set to '{fetch_log_statement_stats}'. If this parameter is enabled, it means that statistics for all SQL statements are logged. This can generate a large volume of logs and impact performance.\\n\\n\", \"\");\r\n\r\nlet pgaudit_log_text = iif((pgaudit_log contains 'READ' or pgaudit_log contains 'WRITE' or pgaudit_log contains 'ALL') and evaluate_pgaudit_none=='No' and shared_preload_libraries contains 'pgaudit', \"- **pgaudit.log**: This parameter is currently set to '{fetch_pgaudit_log}'. If this value is 'READ', 'WRITE', or 'ALL', it means that the PostgreSQL Audit Extension (pgAudit) is logging every read, write, or all operations, which can generate a large volume of logs and impact performance.\", \"\");\r\n\r\n\r\n\r\nlet excessive_logging_enabled = strcat(log_min_duration_statement_text, log_statement_text, log_statement_stats_text, pgaudit_log_text);\r\n\r\nprint excessive_logging_enabled;",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 0
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_pgbouncer_enabled",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/pgbouncer.enabled?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "abd0bf39-6f47-41cb-a2a3-3cc868dfb3d4",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_metric_pgbouncer_diagnostics",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/metrics.pgbouncer_diagnostics?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "e483c47a-97b1-49d1-931f-3763ec85e3d5",
            "value": null
          },
          {
            "id": "f8e021a9-7889-4f3d-894d-01e6a5f8dd5a",
            "version": "KqlParameterItem/1.0",
            "name": "evaluate_pgbouncer_metrics_data",
            "type": 1,
            "query": "let pgbouncer_enabled_value = '{fetch_pgbouncer_enabled}';\r\nlet metric_pgbouncer_diagnostics_value = '{fetch_metric_pgbouncer_diagnostics}';\r\nlet pgbouner_metrics_exists = iff(pgbouncer_enabled_value contains 'true' and metric_pgbouncer_diagnostics_value contains 'on', 'Yes','No');\r\nprint result=pgbouner_metrics_exists",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsServerBurstable",
            "type": 1,
            "isRequired": true,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}?api-version=2024-08-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..sku..tier\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "84592438-a0e9-4016-b930-e03e337e7a0e",
            "value": null
          }
        ],
        "style": "pills",
        "queryType": 12
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "high cpu parameter logs"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "### WARNING: The autovacuum process is not able to keep up with the workload for certain databases on the server.\r\n\r\nBetween the time period **{_SevenDaysAgoTimestamp}** and **{TimeRange:end}** the bloat ratio for **{IsAVCatchingUp}**  databases seems to have increased more than {AV_BLOAT_THRESHOLD}% or the bloat ratio for these databases at current time period - {TimeRange:end} is more than {AV_BLOAT_THRESHOLD}%.\r\n\r\nMonitoring statistics and dead tuples in the tables is important. Stale statistics and high number of dead tuples increase query times which contributes to higher CPU consumption.",
              "style": "warning"
            },
            "name": "high cpu av threshold"
          },
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "list",
              "links": [
                {
                  "id": "57ba7895-7e6a-40fa-ae2f-597495d440f7",
                  "cellValue": "",
                  "linkTarget": "WorkbookTemplate",
                  "linkLabel": "Autovacuum monitoring troubleshooting guide",
                  "preText": "It is recommended to monitor autovacuum metrics on the server by using the",
                  "postText": ".",
                  "style": "link",
                  "linkIsContextBlade": true,
                  "workbookContext": {
                    "componentIdSource": "workbook",
                    "resourceIdsSource": "workbook",
                    "templateIdSource": "static",
                    "templateId": "Community-Workbooks/PostgreSQL Flexible Server/Performance/Autovacuum Monitoring",
                    "typeSource": "workbook",
                    "gallerySource": "workbook",
                    "locationSource": "default",
                    "passSpecificParams": true,
                    "templateParameters": [
                      {
                        "name": "Resource",
                        "source": "parameter",
                        "value": "Resource"
                      },
                      {
                        "name": "TimeRange",
                        "source": "parameter",
                        "value": "TimeRange"
                      }
                    ]
                  }
                }
              ]
            },
            "name": "high cpu av link"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "IsAVCatchingUp",
        "comparison": "isNotEqualTo",
        "value": ""
      },
      "name": "high cpu av group"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "b01ad3ec-d7f4-4f48-877f-97b8e5df9dc3",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalEndTime",
            "type": 1,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\n\r\nlet dt = {TimeRange:end};\r\nprint iff(dt<now(), dt, now())\r\n\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "96e3b87c-aab0-4016-bffd-f08e63a3010b",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalStartTime",
            "type": 1,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\nprint iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime('{GlobalEndTime}')-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start})",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "0aac6a30-1f93-4b3c-9947-52f85e7bcff4",
            "version": "KqlParameterItem/1.0",
            "name": "LessThanOneHourInterval",
            "type": 1,
            "query": "let interval = 1h;\r\nprint iff({TimeRange:end} - {TimeRange:start} < interval, \"Yes\", \"No\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "125f3e47-3f38-492e-bf74-d9686a928b04",
            "version": "KqlParameterItem/1.0",
            "name": "ChartGrain",
            "type": 1,
            "query": "let trange=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nprint case(\r\n    trange<1h, strcat(format_timespan(trange,'m'),' minutes'),\r\n    trange>=1h and trange<1d, strcat(format_timespan(trange,'H'),' hours') ,\r\n    strcat(format_timespan(trange,'dd'),' days')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "0daf8f52-1d24-456b-9d44-9ef438b843d8",
            "version": "KqlParameterItem/1.0",
            "name": "MetricsGrain",
            "type": 1,
            "query": "print case(\r\n    {TimeRange:grain}<1h, strcat(format_timespan({TimeRange:grain},'m'),' minutes'),\r\n    {TimeRange:grain}>=1h and {TimeRange:grain}<1d, strcat(format_timespan({TimeRange:grain},'H'),' hours') ,\r\n    strcat(format_timespan({TimeRange:grain},'dd'),' days')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "3c99b826-ed5f-47fb-91db-8ddbbe88e90c",
            "version": "KqlParameterItem/1.0",
            "name": "ChartGrainMin5",
            "type": 1,
            "query": "let trange=iff({TimeRange:grain}<5m,5m, {TimeRange:grain});\r\nprint case(\r\n    trange<1h, strcat(format_timespan(trange,'m'),' minutes'),\r\n    trange>=1h and trange<1d, strcat(format_timespan(trange,'H'),' hours') ,\r\n    strcat(format_timespan(trange,'dd'),' days')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "cb23b5a0-28ad-4513-841f-b00e47f28b11",
            "version": "KqlParameterItem/1.0",
            "name": "IsConnectionDataExists",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('template1','template0', 'azure_maintenance','azure_sys')\r\n| where State !=\"\"\r\n| limit 10\r\n| count\r\n| extend conndata = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project conndata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "1c4ad1d0-e09b-447d-8ee2-1ec5a73960cb",
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLServerLogsDataExists",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"disconnection\"\r\n| distinct TimeGenerated,Message\r\n| extend DisconnectTime=todatetime(TimeGenerated)\r\n| extend allmatches=extract_all(@'session.time:(.+)user=(.+)database=(.+)host=(.+).port', Message)\r\n| extend duration=totime(allmatches[0][0])\r\n| extend user=trim(@\" \",tostring(allmatches[0][1]) )\r\n| extend database=tostring(allmatches[0][2])\r\n| extend IP=tostring(allmatches[0][3])\r\n| where user !in ('azuresu','replication')\r\n| count\r\n| extend logsdata = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project logsdata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "7a94771a-69d8-46e4-addf-d827c156b109",
            "version": "KqlParameterItem/1.0",
            "name": "IsLogMinDurationDataExists",
            "type": 1,
            "query": "let TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd   = todatetime('{GlobalEndTime}');\r\nlet logs = \r\n    {PGServerLogsTable}\r\n    | where TimeGenerated between (TimeStart .. TimeEnd)\r\n          and Message contains \"duration:\" \r\n          and Message contains \"statement:\"\r\n    | limit 1;\r\nlogs\r\n| summarize logCount = count()\r\n| project logsdata = iff(logCount > 0, \"Yes\", \"No\")\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "9c47caa3-1d4b-4a08-917c-ae29e1157e20",
            "version": "KqlParameterItem/1.0",
            "name": "check_long_running_idle_in_transaction",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 and State !='idle' and BackendType !='autovacuum worker'\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('millisecond',CollectionTime,BackendStartTime), Query_duration_ms = datetime_diff('millisecond',CollectionTime,QueryStartTime),  Transaction_duration_ms=datetime_diff('millisecond',CollectionTime,TransactionStartTime)\r\n   | summarize Connection_duration_sec=max(Connection_duration_sec), Transaction_duration_ms=max(Transaction_duration_ms),  Query_duration_ms=max(Query_duration_ms),arg_max(TimeGenerated,lastState=State) by ProcessId,BackendStartTime, BackendType\r\n   //| where Transaction_duration_ms> {MIN_SESSION_TIME_SEC_THRESHOLD_FOR_LONG_SESSIONS}\r\n  | order by Transaction_duration_ms desc, ProcessId asc\r\n  | where lastState=='idle in transaction'\r\n  ",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "high cpu other parameterss"
    },
    {
      "type": 1,
      "content": {
        "json": "\r\n**Long running transactions found (Transactions > {LONG_RUNNING_QUERY_SEC_DURATION_THRESHOLD} Seconds)**\r\n\r\n",
        "style": "warning"
      },
      "conditionalVisibility": {
        "parameterName": " HighCPUQueries",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "name": "high cpu long transaction warning"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "### Query store is currently disabled\r\nThis troubleshooting guide depends on query store data. You need to enable it by setting the dynamic server parameter `pg_qs.query_capture_mode` to either ALL or TOP. Refer to [monitor performance with query store](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-query-store) for further details.\r\n",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "isQueryStoreEnabled",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high cpu qs error"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL query store runtime logs are not being transmitted to the log analytics workspace\r\nThe query store data is not being sent to the log analytics workspace, which is necessary to use this Troubleshooting guide. To configure the logging settings for query store categoy `PostgreSQL query store runtime` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "isQueryStoreEnabled",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "high cpu qs la error"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Server Logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL server logs data is not being sent to the log analytics workspace, which is necessary to use this Troubleshooting guide. To configure the logging settings for category `PostgreSQL Server Logs` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsPostgreSQLLogsSentToLogAnalytics",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high cpu pglogs error"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Sessions data logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL Sessions logs data is not being sent to the log analytics workspace, which is necessary to use this Troubleshooting guide. To configure the logging settings for category `PostgreSQL Sessions data` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high cpu pgsessionerror"
          },
          {
            "type": 1,
            "content": {
              "json": "### The server metrics data is not being transmitted to the log analytics workspace\r\nThe server metrics data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `AllMetrics` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsAllMetricsSentToLogAnalytics",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high cpu pgmetrics Error"
          },
          {
            "type": 1,
            "content": {
              "json": "### Enhanced metrics are currently disabled.\r\nThis Troubleshooting guide requires the use of enhanced metrics. To activate these metrics, simply enable the dynamic server parameter `metrics.collector_database_activity`.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsMetricsCollectordatabaseActivityOn",
              "comparison": "isNotEqualTo",
              "value": "ON"
            },
            "name": "high cpu enahanced metric error"
          },
          {
            "type": 1,
            "content": {
              "json": "### Query tracking through `log_min_duration_statement` is currently disabled\r\nTo enable query tracking, you can set an appropriate threshold for the `log_min_duration_statement` parameter through the Azure portal. This dynamic parameter determines the minimum duration of a query before it's logged in the PostgreSQL server logs. \r\n",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsLogMinDurationStatementEnabled",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "text - 2"
          }
        ],
        "exportParameters": true
      },
      "name": "high cpu log min error"
    },
    {
      "type": 1,
      "content": {
        "json": "### Potential excessive logging detected\r\n\r\nOur system has detected that your PostgreSQL configuration may be set to excessive logging. This can impact the performance of your queries and the overall system performance.\r\n\r\nWe have identified the following parameters in your configuration that may be contributing to this issue:\r\n\r\n{has_excessive_logging_enabled}\r\n\r\nWe recommend reviewing these settings and adjusting them, if necessary, to reduce the volume of logs and improve performance.\r\n\r\n> **Note**: If the query store feature is already enabled on your server, it's recommended to leverage it for monitoring the workload instead of relying solely on these logging settings. query store provides a more efficient and comprehensive way to track and optimize your database performance. Please refer to the [Azure PostgreSQL Flexible Server query store documentation](https://learn.microsoft.com/azure/postgresql/flexible-server/concepts-query-store) to learn about this feature.\r\n",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "has_excessive_logging_enabled",
        "comparison": "isNotEqualTo",
        "value": ""
      },
      "name": "ExecessiveLoggingInsightText"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "tabStyle": "bigger",
        "links": [
          {
            "id": "561184d2-fedd-44f8-9fe1-5a5bca468465",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "CPU",
            "subTarget": "usage",
            "style": "link"
          },
          {
            "id": "53a4d309-f616-49ac-b3f8-01f9b81c712f",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "Workload",
            "subTarget": "workload",
            "style": "link"
          },
          {
            "id": "1cb86df9-058f-4ea3-a646-888e89b1fb39",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "Transactions",
            "subTarget": "transactions",
            "style": "link"
          },
          {
            "id": "065516f7-e3d8-4ff6-a120-568403493106",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "Long running transactions",
            "subTarget": "longtransactions",
            "style": "link"
          },
          {
            "id": "c9da01bb-faab-4428-b968-8dfcf6ababbc",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "Queries",
            "subTarget": "hightimequeries",
            "style": "link"
          },
          {
            "id": "68f9ff2d-6068-4537-88f0-96c59fe3bb9a",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "User connections",
            "subTarget": "connections",
            "style": "link"
          },
          {
            "id": "72429625-f0c4-4db4-bc69-da3093632ed3",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "Locking and blocking",
            "subTarget": "locks",
            "style": "link"
          },
          {
            "id": "55d0fb38-350f-4a90-bb6d-c15ea5f61312",
            "cellValue": "cputab",
            "linkTarget": "parameter",
            "linkLabel": "Insights",
            "subTarget": "insight",
            "style": "link"
          }
        ]
      },
      "name": "high cpu tabs"
    },
    {
      "type": 1,
      "content": {
        "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "LessThanOneHourInterval",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "x",
          "comparison": "isEqualTo",
          "value": "y"
        }
      ],
      "name": "high cpu cpu utiization metric time interval"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookda363094-1a87-4922-a088-e257cf971b6c",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Saturation-cpu_percent",
            "aggregation": 3
          }
        ],
        "title": "Maximum percentage of CPU in use",
        "showCreateAlertRule": true,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "usage"
      },
      "name": "high cpu cpu utilization"
    },
    {
      "type": 1,
      "content": {
        "json": "### Burstable tier metrics\r\n\r\n#### CPU credits consumed\r\n- This metric tracks the number of CPU credits your server has used during a given time period. In the Burstable tier, credits are consumed when the server exceeds its baseline CPU performance. For example, if your server has a baseline of 20% CPU and your workload spikes to 80%, credits are used to support that burst.\r\n\r\n#### CPU credits remaining\r\n- This metric shows how many credits are still available for future bursts. If your workload stays below the baseline, credits accumulate. If it goes above, credits are spent. Once credits are exhausted, the server is throttled back to its baseline performance until it earns more credits.\r\n\r\n---\r\n\r\n### How to evaluate these metrics\r\nIf your workload is consistently above baseline and **cpu_credits_remaining** is low or zero, the server may be throttled, leading to degraded performance.\r\nIf cpu_credits_consumed is high but cpu_credits_remaining stays healthy, your workload is bursting efficiently.\r\n\r\n---\r\n\r\n### Recommendations\r\n- Use Burstable tier for low-duty or dev/test workloads.\r\n- Switch to General Purpose tier if credits run out often.\r\n- Review workload patterns to optimize cost vs. performance.\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "usage"
        },
        {
          "parameterName": "IsServerBurstable",
          "comparison": "isEqualTo",
          "value": "Burstable"
        }
      ],
      "name": "Burstable info"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookda363094-1a87-4922-a088-e257cf971b6c",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Saturation-cpu_credits_consumed",
            "aggregation": 4
          }
        ],
        "title": "Number of credits used by the flexible server.",
        "showCreateAlertRule": true,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "usage"
        },
        {
          "parameterName": "IsServerBurstable",
          "comparison": "isEqualTo",
          "value": "Burstable"
        }
      ],
      "customWidth": "50",
      "name": "high cpu burstable metrics"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookda363094-1a87-4922-a088-e257cf971b6c",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Saturation-cpu_credits_remaining",
            "aggregation": 4
          }
        ],
        "title": "Number of credits available to burst.",
        "showCreateAlertRule": true,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "usage"
        },
        {
          "parameterName": "IsServerBurstable",
          "comparison": "isEqualTo",
          "value": "Burstable"
        }
      ],
      "customWidth": "50",
      "name": "high cpu burstable metrics1"
    },
    {
      "type": 1,
      "content": {
        "json": "### Enhanced metrics are currently disabled.\r\nThis Troubleshooting guide requires the use of enhanced metrics. To activate these metrics, simply enable the dynamic server parameter `metrics.collector_database_activity`.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isNotEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high cpu workload enhanced metric"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "links": [
          {
            "id": "bbd1eb36-7b53-4cf3-9eb3-b7d578ac6f69",
            "cellValue": "child-tab",
            "linkTarget": "parameter",
            "linkLabel": "Read workload",
            "subTarget": "readworkload",
            "style": "link"
          },
          {
            "id": "8269efc0-6814-4c74-b446-b6197ce51d5b",
            "cellValue": "child-tab",
            "linkTarget": "parameter",
            "linkLabel": "Write workload",
            "subTarget": "writeworkload",
            "style": "link"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        }
      ],
      "name": "high cpu workload tab"
    },
    {
      "type": 1,
      "content": {
        "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "LessThanOneHourInterval",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "x",
          "comparison": "isEqualTo",
          "value": "y"
        }
      ],
      "name": "high cpu workload tab time interval"
    },
    {
      "type": 1,
      "content": {
        "json": "## Read workload details\r\n\r\n**tup_fetched** and **tup_returned** are two metrics that measure the number of rows read from a table.\r\n\r\n**tup_returned** represents the number of live rows fetched by sequential scans and index entries returned by index scans in this database.\r\n\r\n**tup_fetched** measures the number of live rows fetched by index scans in this database.\r\n\r\nBy monitoring these two metrics, you can gain a better understanding of the performance of your PostgreSQL read workloads.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        }
      ],
      "name": "high cpu workload read info"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook4dc9d840-2afc-4e9d-b0e6-bba4664c2631",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_fetched",
            "aggregation": 1
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_returned",
            "aggregation": 1
          }
        ],
        "title": "Read workload metrics",
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        }
      ],
      "name": "high cpu workload readworkload metric"
    },
    {
      "type": 1,
      "content": {
        "json": "**The read workload metric calculates the total number of tuples fetched and returned for all databases, except for system databases like `azure_sys` and `azure_maintenance`.**",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        }
      ],
      "name": "high cpu workload readworkload info"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook7a7c3cb2-9d2d-45e7-a9bf-cb0db0f38dc9",
        "version": "MetricsItem/2.0",
        "size": 1,
        "chartType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_fetched",
            "aggregation": 1,
            "splitBy": [
              "DatabaseName"
            ],
            "splitBySortOrder": -1,
            "splitByLimit": 50
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_returned",
            "aggregation": 1,
            "splitBy": [
              "DatabaseName"
            ],
            "splitBySortOrder": -1,
            "splitByLimit": 50
          }
        ],
        "title": "Tuples (rows) fetched and returned by database",
        "gridFormatType": 2,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "Subscription",
              "formatter": 5
            },
            {
              "columnMatch": "Name",
              "formatter": 5,
              "formatOptions": {
                "linkTarget": "Resource"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_fetched",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_fetched Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_returned",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_returned Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": ".*\\/Tuples Returned (Preview)$",
              "formatter": 1
            },
            {
              "columnMatch": ".*\\/Tuples Fetched (Preview)$",
              "formatter": 1
            }
          ],
          "rowLimit": 10000,
          "labelSettings": [
            {
              "columnId": "Segment",
              "label": "database"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_fetched",
              "label": "fetched (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_fetched Timeline",
              "label": "fetched (sum) [timeline]"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_returned",
              "label": "returned (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_returned Timeline",
              "label": "returned (sum) [timeline]"
            }
          ]
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        }
      ],
      "name": "high cpu workload readworkload grid"
    },
    {
      "type": 1,
      "content": {
        "json": "## Write workload details\r\nThe number of tuples that have been inserted, updated, or deleted are critical for understanding the overall performance of the database and for identifying potential inefficiencies.\r\n\r\n\r\nBy monitoring these metrics, you can gain insights into the performance of your PostgreSQL write workloads and make data-driven decisions to optimize the database.\r\n\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu workload write info"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook4f1a52ad-86d1-4a5a-83e7-7caef0b1658b",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_inserted",
            "aggregation": 1
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_updated",
            "aggregation": 1
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_deleted",
            "aggregation": 1
          }
        ],
        "title": "Write workload metrics",
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu workload writeworkload metric"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Write workload details are not available for replica servers.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        }
      ],
      "name": "high cpu workload writeworkload readreplica"
    },
    {
      "type": 1,
      "content": {
        "json": "**The write workload metric calculates the total number of tuples inserted, updated, and deleted for all databases, except for system databases like `azure_sys` and `azure_maintenance`.**\r\n\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu workload writeworkload reco."
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook840cc26a-4a5b-4641-9a39-c0186fc4b983",
        "version": "MetricsItem/2.0",
        "size": 1,
        "chartType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_inserted",
            "aggregation": 1,
            "splitBy": [
              "DatabaseName"
            ],
            "splitBySortOrder": -1,
            "splitByLimit": 50
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_updated",
            "aggregation": 1,
            "splitBy": [
              "DatabaseName"
            ],
            "splitBySortOrder": -1,
            "splitByLimit": 50
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_deleted",
            "aggregation": 1,
            "splitBy": [
              "DatabaseName"
            ],
            "splitBySortOrder": -1,
            "splitByLimit": 50
          }
        ],
        "title": "Tuples (rows) inserted, updated and deleted by database",
        "gridFormatType": 2,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "Subscription",
              "formatter": 5
            },
            {
              "columnMatch": "Name",
              "formatter": 5
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_inserted",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_inserted Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_updated",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_updated Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_deleted",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_deleted Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            }
          ],
          "rowLimit": 10000,
          "labelSettings": [
            {
              "columnId": "Segment",
              "label": "database"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_inserted",
              "label": "inserted (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_inserted Timeline",
              "label": "inserted (sum) [timeline]"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_updated",
              "label": "updated (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_updated Timeline",
              "label": "updated (sum) [timeline]"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_deleted",
              "label": "deleted (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-tup_deleted Timeline",
              "label": "deleted (sum) [timeline]"
            }
          ]
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu workload writeworkload grid"
    },
    {
      "type": 1,
      "content": {
        "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "LessThanOneHourInterval",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "x",
          "comparison": "isEqualTo",
          "value": "y"
        }
      ],
      "name": "high cpu workload writeworkload grid time interval"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "links": [
          {
            "id": "cb78e5e9-2ef1-4f4c-832f-6ddc98ae5c6f",
            "cellValue": "connection-tab-2",
            "linkTarget": "parameter",
            "linkLabel": "Transaction trend ",
            "subTarget": "TT",
            "style": "link"
          },
          {
            "id": "ce889247-43cd-4b4b-affb-b0753d5173ee",
            "cellValue": "connection-tab-2",
            "linkTarget": "parameter",
            "linkLabel": "Transactions per second",
            "subTarget": "TPS",
            "style": "link"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "transactions"
      },
      "name": "high cpu transaction tab"
    },
    {
      "type": 1,
      "content": {
        "json": "### Enhanced metrics are currently disabled.\r\nThis Troubleshooting guide requires the use of enhanced metrics. To activate these metrics, simply enable the dynamic server parameter `metrics.collector_database_activity`.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isNotEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "connection-tab-2",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "transactions"
        }
      ],
      "name": "high cpu transaction enahanced metric"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookb2527b03-3e5b-4b92-9042-92b7c0628157",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-xact_commit",
            "aggregation": 1
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-database (Preview)-xact_rollback",
            "aggregation": 1
          }
        ],
        "title": "Transactions committed vs transactions rolled back",
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricsCollectordatabaseActivityOn",
          "comparison": "isEqualTo",
          "value": "ON"
        },
        {
          "parameterName": "connection-tab-2",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "transactions"
        }
      ],
      "name": "high cpu transaction trend metric"
    },
    {
      "type": 1,
      "content": {
        "json": "### The server metrics data is not being transmitted to the log analytics workspace\r\nThe server metrics data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `AllMetrics` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsAllMetricsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "connection-tab-2",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "transactions"
        }
      ],
      "name": "high cpu transaction lano"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsAllMetricsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-2",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "transactions"
        },
        {
          "parameterName": "IsMetricDataExists",
          "comparison": "isEqualTo",
          "value": "No"
        }
      ],
      "name": "high cpu transaction layes"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n//let graph_grain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nlet graph_grain={TimeRange:grain};\r\n{MetricsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where MetricName == 'xact_total'\r\n| distinct Total,TimeGenerated\r\n//| summarize tps = sum(tolong(Total))/60 by bin(TimeGenerated,1m)\r\n| summarize total_xact = sum(tolong(Total)) by bin(TimeGenerated,1m)\r\n| extend tps = total_xact /60\r\n| make-series xact_per_second = max(tps) default = 0 on TimeGenerated from Start_Time to End_Time step graph_grain \r\n| render timechart",
        "size": 0,
        "aggregation": 2,
        "title": "Transactions per second",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "timechart",
        "chartSettings": {
          "yAxis": [
            "xact_per_second"
          ]
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-2",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "transactions"
        }
      ],
      "name": "high cpu transaction tps"
    },
    {
      "type": 1,
      "content": {
        "json": "### High number of transactions per second (tps) ##\r\n\r\nIf you notice a recent peak in the `Transactions per second` graph in correlation with high CPU utilization, it could indicate that the server is experiencing an increased workload. You may want to consider upgrading to a higher SKU.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-2",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "transactions"
        }
      ],
      "name": "high cpu transaction tps reco"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "4ca62ad2-ee86-498b-924c-86b92ba5a231",
            "version": "KqlParameterItem/1.0",
            "name": "existsLongRunningTransactionsData",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 and State !='idle' and BackendType !='autovacuum worker'\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|count\r\n|extend hasdata =iff(Count>0,'Yes','No')\r\n|project hasdata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        },
        {
          "parameterName": "x",
          "comparison": "isEqualTo",
          "value": "y"
        }
      ],
      "name": "high cpu longsessions existsdata"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions noexists data"
    },
    {
      "type": 1,
      "content": {
        "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": ""
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions lanone"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": ""
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions layep"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "98d4f3a7-4057-400a-a84f-cbd61df98051",
            "version": "KqlParameterItem/1.0",
            "name": "TopTransactions",
            "type": 2,
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n { \"value\":\"10\", \"label\":\"10\",\"selected\":true },\r\n  { \"value\":\"20\", \"label\":\"20\" },\r\n    { \"value\":\"30\", \"label\":\"30\" },\r\n     { \"value\":\"40\", \"label\":\"40\" },\r\n  { \"value\":\"50\", \"label\":\"50\" }\r\n]",
            "timeContext": {
              "durationMs": 86400000
            },
            "label": "Maximum processes"
          },
          {
            "id": "58670e06-5b7c-430f-b471-9074ef67b788",
            "version": "KqlParameterItem/1.0",
            "name": "idle_in_transaction_state_pids",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 and State !='idle' and BackendType !='autovacuum worker'\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('millisecond',CollectionTime,BackendStartTime), Query_duration_ms = datetime_diff('millisecond',CollectionTime,QueryStartTime),  Transaction_duration_ms=datetime_diff('millisecond',CollectionTime,TransactionStartTime)\r\n   | summarize Connection_duration_sec=max(Connection_duration_sec), Transaction_duration_ms=max(Transaction_duration_ms),  Query_duration_ms=max(Query_duration_ms),arg_max(TimeGenerated,lastState=State) by ProcessId,BackendStartTime, BackendType\r\n   //| where Transaction_duration_ms> {MIN_SESSION_TIME_SEC_THRESHOLD_FOR_LONG_SESSIONS}\r\n  | order by Transaction_duration_ms desc, ProcessId asc\r\n  | limit {TopTransactions}\r\n  | where lastState=='idle in transaction'\r\n  | project ProcessId\r\n  ",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "check_long_idle_in_transacton_state",
            "type": 1,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 and State !='idle' and BackendType !='autovacuum worker'\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('millisecond',CollectionTime,BackendStartTime), Query_duration_ms = datetime_diff('millisecond',CollectionTime,QueryStartTime),  Transaction_duration_ms=datetime_diff('millisecond',CollectionTime,TransactionStartTime)\r\n   | summarize Connection_duration_sec=max(Connection_duration_sec), Transaction_duration_ms=max(Transaction_duration_ms),  Query_duration_ms=max(Query_duration_ms),arg_max(TimeGenerated,lastState=State) by ProcessId,BackendStartTime, BackendType\r\n   //| where Transaction_duration_ms> {MIN_SESSION_TIME_SEC_THRESHOLD_FOR_LONG_SESSIONS}\r\n  | order by Transaction_duration_ms desc, ProcessId asc\r\n  | limit {TopTransactions}\r\n  | where lastState=='idle in transaction'\r\n    |count\r\n    | extend long_idle_in_transaction_state = iff(Count>0, 'Yes', 'No')\r\n    | project long_idle_in_transaction_state\r\n  ",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "id": "f219e794-a495-4898-b730-04cdc7556fc2"
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions toptran"
    },
    {
      "type": 1,
      "content": {
        "json": "\r\n### `idle_in_transactions` sessions state detected for PIDs {idle_in_transaction_state_pids}\r\n\r\nIf you notice long idle_in_transaction session, We recommend setting `idle_in_transactions_session_timeout` to prevent unintentional open transactions.\r\n\r\nThe `idle_in_transaction_session_timeout` parameter in PostgreSQL controls the amount of time an idle transaction waits before its stopped. Here are some recommendations:\r\n\r\n- The default value for this parameter is 0 milliseconds, which means that idle transactions are never stopped. This can lead to long-running transactions that consume resources and slow down the system.\r\n- To avoid such issues, you can set the `idle_in_transaction_session_timeout` parameter to a value that makes sense for your application. For example, you might set it to 5 minutes (300 seconds) so that any transaction that is left idle for more than 5 minutes will be automatically stopped.\r\n\r\nRemember, setting the appropriate value for `idle_in_transaction_session_timeout` can help ensure that your application performs optimally. Its always a good idea to monitor your systems performance and adjust this setting as needed.\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "check_long_idle_in_transacton_state",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "Long_idle_in_transaction_warning_text"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 and State !='idle' and BackendType !='autovacuum worker'\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('millisecond',CollectionTime,BackendStartTime), Query_duration_ms = datetime_diff('millisecond',CollectionTime,QueryStartTime),  Transaction_duration_ms=datetime_diff('millisecond',CollectionTime,TransactionStartTime)\r\n   | summarize Connection_duration_sec=max(Connection_duration_sec), Transaction_duration_ms=max(Transaction_duration_ms),  Query_duration_ms=max(Query_duration_ms),arg_max(TimeGenerated,lastState=State) by ProcessId,BackendStartTime, BackendType\r\n   //| where Transaction_duration_ms> {MIN_SESSION_TIME_SEC_THRESHOLD_FOR_LONG_SESSIONS}\r\n  | order by Transaction_duration_ms desc, ProcessId asc\r\n  | limit {TopTransactions}",
        "size": 1,
        "aggregation": 2,
        "title": "Top {TopTransactions} PIDs by transaction duration. Blue - connection duration; Green - transaction duration. The state shown in the tile is the last state from telemetry snapshot, historically the state could have changed multiple times.",
        "noDataMessage": "No data available during the period selected",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "tiles",
        "gridSettings": {
          "sortBy": [
            {
              "itemKey": "Backend_type_s",
              "sortOrder": 1
            }
          ]
        },
        "sortBy": [
          {
            "itemKey": "Backend_type_s",
            "sortOrder": 1
          }
        ],
        "tileSettings": {
          "titleContent": {
            "columnMatch": "ProcessId",
            "formatter": 1,
            "numberFormat": {
              "unit": 0,
              "options": {
                "style": "decimal",
                "useGrouping": false
              }
            }
          },
          "subtitleContent": {
            "columnMatch": "lastState",
            "formatter": 1
          },
          "leftContent": {
            "columnMatch": "Connection_duration_sec",
            "formatter": 3,
            "formatOptions": {
              "palette": "blue"
            },
            "numberFormat": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": false,
                "maximumFractionDigits": 2
              }
            },
            "tooltipFormat": {
              "tooltip": "{1}"
            }
          },
          "rightContent": {
            "columnMatch": "Transaction_duration_ms",
            "formatter": 3,
            "formatOptions": {
              "palette": "green"
            },
            "numberFormat": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": true
              },
              "emptyValCustomText": "Transaction Duration"
            },
            "tooltipFormat": {
              "tooltip": "Transaction Duration"
            }
          },
          "secondaryContent": {
            "columnMatch": "BackendType",
            "formatter": 1
          },
          "showBorder": true,
          "sortCriteriaField": "Transaction_duration_ms",
          "sortOrderField": 2,
          "size": "auto"
        },
        "graphSettings": {
          "type": 0,
          "topContent": {
            "columnMatch": "Session_duration",
            "formatter": 1
          },
          "centerContent": {
            "columnMatch": "Pid",
            "formatter": 1,
            "numberFormat": {
              "unit": 17,
              "options": {
                "maximumSignificantDigits": 3,
                "maximumFractionDigits": 2
              }
            }
          }
        },
        "chartSettings": {
          "showLegend": true,
          "xSettings": {
            "numberFormatSettings": {
              "unit": 0,
              "options": {
                "style": "decimal",
                "useGrouping": true
              }
            }
          },
          "ySettings": {
            "numberFormatSettings": {
              "unit": 24,
              "options": {
                "style": "decimal",
                "useGrouping": false
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions query"
    },
    {
      "type": 1,
      "content": {
        "json": "## Statistics on long running transactions\r\n\r\n**Important: In the troubleshooting guide we consider any transaction which is running for more than {LONG_RUNNING_QUERY_SEC_DURATION_THRESHOLD} seconds as a long running transaction.** \r\n\r\nNote:\r\n\r\n* Connection duration **(blue)**: Duration of session or connection `(collection_time - backend_start)`. You will notice higher value if you are using connection pool.\r\n\r\n* Transaction duration **(green)**: Duration of transaction `(collection_time - xact_start)`.\r\n\r\nLong running transactions are identified through the information provided by the pg_stat_activity view in PostgreSQL. If you want to know more about the semantics of these columns, please refer to the [official documentation](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW).",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions query reco"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "e4b37b70-1891-4de7-b916-349a7ad5ae25",
            "version": "KqlParameterItem/1.0",
            "name": "SessionPid",
            "label": "Show snapshot of PID",
            "type": 2,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 and State !='idle' and BackendType !='autovacuum worker'\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('second',CollectionTime,BackendStartTime), Query_duration_ms = datetime_diff('millisecond',CollectionTime,QueryStartTime),  Transaction_duration_ms=datetime_diff('millisecond',CollectionTime,TransactionStartTime)\r\n| summarize  Connection_duration_sec=max(Connection_duration_sec), Query_duration_ms=max(Query_duration_ms),Transaction_duration_ms=max(Transaction_duration_ms)  by ProcessId,BackendStartTime\r\n| order by Transaction_duration_ms desc, ProcessId asc\r\n| limit {TopTransactions}\r\n| extend uniquePidkeys=strcat(toint(ProcessId),'-',BackendStartTime)\r\n| project uniquePidkeys,ProcessId\r\n| serialize Rank = row_number()\r\n| project value = uniquePidkeys, label = strcat(' ', toint(ProcessId)), selected = iff(Rank == 1, true, false)",
            "crossComponentResources": [
              "{Resource}"
            ],
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "value": null
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions  rank query"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime,StateChangeTime,DatabaseId,DatabaseName,UserId,ClientIpAddress\r\n| extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n| where uniquePidkeys =='{SessionPid}'\r\n| extend Connection_Duration=iff(CollectionTime-BackendStartTime<time(00:00:00.00),0, datetime_diff('millisecond',CollectionTime,BackendStartTime))\r\n| extend StateLastChanged_ms=iff(CollectionTime-StateChangeTime<time(00:00:00.00),0, datetime_diff('millisecond',CollectionTime,StateChangeTime))\r\n| extend Xact_duration_ms=iff(CollectionTime-TransactionStartTime<time(00:00:00.00), datetime_diff('millisecond',TransactionStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,TransactionStartTime))\r\n| extend Query_duration_ms=iff(CollectionTime-QueryStartTime<time(00:00:00.00),datetime_diff('millisecond',TransactionStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,QueryStartTime))\r\n| extend dummy_row=1\r\n| summarize max(Connection_Duration), max(Query_duration_ms), max(Xact_duration_ms),sum(dummy_row)  by ProcessId,BackendStartTime, DatabaseId, DatabaseName, UserId, ClientIpAddress, BackendType\r\n| project ['process identifier'] = ProcessId, ['backend type'] = BackendType, ['database identifier'] = DatabaseId, ['database name'] = DatabaseName, ['user identifier'] = UserId, ['client ip address'] = ClientIpAddress, ['backend start time'] = BackendStartTime, ['connection duration'] = max_Connection_Duration, ['longest transaction duration'] = max_Xact_duration_ms, ['longest query duration'] = max_Query_duration_ms, ['sampled data points'] = sum_dummy_row",
        "size": 4,
        "title": "Summary as of {GlobalEndTime} UTC",
        "noDataMessage": "No data available during the period selected",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "backend start time",
              "formatter": 6
            },
            {
              "columnMatch": "connection duration",
              "formatter": 1,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "longest transaction duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "longest query duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ]
        },
        "sortBy": [],
        "tileSettings": {
          "titleContent": {
            "columnMatch": "process identifier",
            "formatter": 1
          },
          "subtitleContent": {
            "columnMatch": "backend start time",
            "formatter": 6,
            "dateFormat": {
              "showUtcTime": null,
              "formatName": "fullDateTimePattern"
            }
          },
          "leftContent": {
            "columnMatch": "database name",
            "formatter": 1
          },
          "showBorder": false
        },
        "graphSettings": {
          "type": 0,
          "topContent": {
            "columnMatch": "backend start time",
            "formatter": 1
          },
          "centerContent": {
            "columnMatch": "process identifier",
            "formatter": 1,
            "numberFormat": {
              "unit": 17,
              "options": {
                "maximumSignificantDigits": 3,
                "maximumFractionDigits": 2
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions rollup query"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| distinct TimeGenerated, ProcessId, BackendStartTime,State\r\n    | extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n    | where uniquePidkeys =='{SessionPid}'\r\n| extend workingState=iff(State in ('active','idle','idle in transaction','idle in transaction (aborted)'), State, 'other')\r\n| summarize count() by State=workingState",
        "size": 4,
        "title": "Overall state of the PID for the period analyzed. Data is sampled each 5 minutes.",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "piechart",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "Backend_start",
              "formatter": 6
            },
            {
              "columnMatch": "TotalConnectionDuration",
              "formatter": 1,
              "numberFormat": {
                "unit": 24,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "LongestTransactionDuration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "LongestQueryDuration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ]
        },
        "sortBy": [],
        "tileSettings": {
          "titleContent": {
            "columnMatch": "Pid",
            "formatter": 1
          },
          "subtitleContent": {
            "columnMatch": "Backend_start",
            "formatter": 6,
            "dateFormat": {
              "showUtcTime": null,
              "formatName": "fullDateTimePattern"
            }
          },
          "leftContent": {
            "columnMatch": "database_name",
            "formatter": 1
          },
          "showBorder": false
        },
        "graphSettings": {
          "type": 0,
          "topContent": {
            "columnMatch": "Backend_start",
            "formatter": 1
          },
          "centerContent": {
            "columnMatch": "Pid",
            "formatter": 1,
            "numberFormat": {
              "unit": 17,
              "options": {
                "maximumSignificantDigits": 3,
                "maximumFractionDigits": 2
              }
            }
          }
        },
        "chartSettings": {
          "showLegend": true
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "customWidth": "50",
      "name": "high cpu longsessions history query"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| distinct TimeGenerated, ProcessId, BackendStartTime,State,WaitEventType,WaitEvent\r\n    | extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n    | where uniquePidkeys =='{SessionPid}'\r\n|  summarize count() by WaitEventType,WaitEvent\r\n|project iff(isempty(WaitEventType),'No Waits',strcat(WaitEventType,':',WaitEvent)),count_",
        "size": 4,
        "title": "Overall wait events of the process (PID) for the period analyzed. Data is sampled each 5 minutes.",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "piechart",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "Backend_start",
              "formatter": 6
            },
            {
              "columnMatch": "TotalConnectionDuration",
              "formatter": 1,
              "numberFormat": {
                "unit": 24,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "LongestTransactionDuration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "LongestQueryDuration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ]
        },
        "sortBy": [],
        "tileSettings": {
          "titleContent": {
            "columnMatch": "Pid",
            "formatter": 1
          },
          "subtitleContent": {
            "columnMatch": "Backend_start",
            "formatter": 6,
            "dateFormat": {
              "showUtcTime": null,
              "formatName": "fullDateTimePattern"
            }
          },
          "leftContent": {
            "columnMatch": "database_name",
            "formatter": 1
          },
          "showBorder": false
        },
        "graphSettings": {
          "type": 0,
          "topContent": {
            "columnMatch": "Backend_start",
            "formatter": 1
          },
          "centerContent": {
            "columnMatch": "Pid",
            "formatter": 1,
            "numberFormat": {
              "unit": 17,
              "options": {
                "maximumSignificantDigits": 3,
                "maximumFractionDigits": 2
              }
            }
          }
        },
        "chartSettings": {
          "showLegend": true
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "customWidth": "50",
      "name": "qhigh cpu longsessions waitevents"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| distinct TimeGenerated,ProcessId, CollectionTime, ApplicationName , State, WaitEventType , WaitEvent , TransactionId , OldestTransactionId,BackendStartTime,StateChangeTime,TransactionStartTime,QueryStartTime\r\n    | extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n    | where uniquePidkeys =='{SessionPid}'\r\n| extend Connection_Duration=iff(CollectionTime-BackendStartTime<time(00:00:00.00),datetime_diff('second',BackendStartTime,CollectionTime), datetime_diff('second',CollectionTime,BackendStartTime))\r\n| extend StateLastChanged_ms=iff(CollectionTime-StateChangeTime<time(00:00:00.00),datetime_diff('millisecond',StateChangeTime,CollectionTime), datetime_diff('millisecond',CollectionTime,StateChangeTime))\r\n| extend Xact_duration_ms=iff(CollectionTime-TransactionStartTime<time(00:00:00.00),datetime_diff('millisecond',TransactionStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,TransactionStartTime))\r\n| extend Query_duration_ms=iff(CollectionTime-QueryStartTime<time(00:00:00.00),datetime_diff('millisecond',QueryStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,QueryStartTime))\r\n| order by Connection_Duration asc \r\n| serialize \r\n| extend rn=row_number()\r\n| extend prev_Application=(prev(ApplicationName,1))\r\n| extend prev_State=(prev(State,1))\r\n| extend prev_Waitevtype=(prev(WaitEventType,1))\r\n| extend prev_Waitev=(prev(WaitEvent,1))\r\n| extend prev_xid=(prev(TransactionId,1))\r\n| extend prev_xmin=(prev(OldestTransactionId,1))\r\n| extend isApp_change=iff( rn>1 and ApplicationName != prev_Application,1,0)\r\n| extend isState_change=iff( rn>1 and State != prev_State,1,0)\r\n| extend isWaitevtype_change=iff( rn>1 and WaitEventType != prev_Waitevtype,1,0)\r\n| extend isWaitev_change=iff( rn>1 and WaitEvent != prev_Waitev,1,0)\r\n| extend isxid_change=iff( rn>1 and TransactionId != prev_xid,1,0)\r\n| extend isxmin_change=iff( rn>1 and OldestTransactionId != prev_xmin,1,0)\r\n| extend breakPoint=iff (isApp_change>0 or isState_change>0 or isWaitevtype_change>0 or isWaitev_change>0 or isxid_change>0 or isxmin_change>0, 0, rn)\r\n| project CollectionTime,ProcessId,ApplicationName,Connection_Duration, State, prev_State, WaitEvent, prev_Waitev, WaitEventType, prev_Waitevtype, rn, breakPoint,TransactionId , OldestTransactionId,Xact_duration_ms,StateLastChanged_ms\r\n| scan with_match_id=change_id declare (TheRank: long) with \r\n(\r\n    step buildRank: true => TheRank = iff(isnull(buildRank.TheRank), rn, buildRank.TheRank);\r\n    step endRank output=none: breakPoint==0;\r\n)\r\n| summarize min(Connection_Duration),max(Connection_Duration),min(CollectionTime),max(CollectionTime), SampledCounter=count(), max(Xact_duration_ms), avg(Xact_duration_ms), max(StateLastChanged_ms)  by change_id, ApplicationName, State,WaitEvent,WaitEventType,ProcessId, TransactionId , OldestTransactionId\r\n| extend WaitEvent=iff(isempty(WaitEventType),'No Waits',strcat(WaitEventType,':',WaitEvent))\r\n| project ['process identifier'] = ProcessId, ['from'] = min_CollectionTime, ['to'] = max_CollectionTime, ['from connection start'] = min_Connection_Duration, ['application name'] = ApplicationName, ['state'] = State, ['wait event'] = WaitEvent, ['transaction identifier'] = TransactionId, ['oldest transaction identifier'] = OldestTransactionId, ['maximum transaction duration'] = max_Xact_duration_ms, ['sampled data points'] = SampledCounter",
        "size": 0,
        "title": "Full history of the PID for the period analyzed",
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "from",
              "formatter": 6
            },
            {
              "columnMatch": "to",
              "formatter": 6
            },
            {
              "columnMatch": "from connection start",
              "formatter": 19,
              "formatOptions": {
                "palette": "blue",
                "timelineSettings": {
                  "timelineStartColumn": "from connection start"
                }
              },
              "numberFormat": {
                "unit": 24,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum transaction duration",
              "formatter": 1,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "from connection start",
              "formatter": 0,
              "numberFormat": {
                "unit": 24,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ],
          "rowLimit": 10000,
          "filter": true
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions fullhistory query"
    },
    {
      "type": 1,
      "content": {
        "json": "**Recommendations**\r\n\r\n* As a long term approach, consider leveraging [index tuning](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-index-tuning) feature to get index recommendations that would optimize your workload.\r\nYou can also use EXPLAIN ANALYZE to manually tune the queries identified from the above PIDs.\r\nMore information on EXPLAIN command can be found [here](https://www.postgresql.org/docs/current/sql-explain.html).\r\n\r\n\r\n* As a short term option you can terminate or cancel the sessions by executing below commands:\r\n\r\nFrom the PIDs retrieved above, execute the following query on the server, to terminate the session:\r\n\r\n\tSELECT pg_terminate_backend(<pid>);\r\n\r\nYou can also cancel the running queries by executing the following query:\r\n\r\n\tselect pg_cancel_backend(<pid>); \r\n\r\n\r\nLong-running sessions can consume excessive CPU and memory. To manage this, configure timeout parameters such as:\r\n\r\n- `statement_timeout`: Limits query execution time  \r\n- `idle_session_timeout`: Ends idle sessions (PostgreSQL 14+)  \r\n- `idle_in_transaction_session_timeout`: Ends idle transactions  \r\n- `transaction_timeout`: Limits total transaction duration (PostgreSQL 17)\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "existsLongRunningTransactionsData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "longtransactions"
        }
      ],
      "name": "high cpu longsessions tuning reco"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "ee74b24a-700f-49ed-9739-eff7891c5da2",
            "version": "KqlParameterItem/1.0",
            "name": "GetDataFrom",
            "label": "Get queries data from",
            "type": 10,
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n   \r\n    { \"value\":\"QueryStore\", \"label\":\"QueryStore\"},\r\n     { \"value\":\"log_min_duration_statement\", \"label\":\"log_min_duration_statement\",\"selected\":true }\r\n]",
            "timeContext": {
              "durationMs": 86400000
            }
          }
        ],
        "style": "formHorizontal",
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        }
      ],
      "name": "queries options group"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Note: To start viewing query-level data in this section, ensure the following server parameters are configured in your Azure Database for PostgreSQL flexible server:\r\n\r\n- Set **log_line_prefix**: `\"time=%t, session=%c, pid=%p, user=%u, db=%d, client=%h, app=%a \"`, *(Copy everything between the double quotes exactly.)*.\r\n- Set **log_min_duration_statement**: Set this to a threshold value (e.g., `100ms`) to log slow-running queries.\r\n- Ensure PostgreSQL server logs are being sent to your **Log Analytics workspace**..",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "GetDataFrom",
          "comparison": "isEqualTo",
          "value": "log_min_duration_statement"
        }
      ],
      "name": "log_min_duration_statement_configuration_message"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Telemetry data is limited for the selected time window.\r\n`log_min_duration_statement` is currently disabled, but older logs are still available in the workspace. To resume capturing query duration data, please re-enable the setting.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "GetDataFrom",
          "comparison": "isEqualTo",
          "value": "log_min_duration_statement"
        },
        {
          "parameterName": "IsLogMinDurationDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "fetch_log_min_duration_statement",
          "comparison": "isEqualTo",
          "value": "-1"
        }
      ],
      "name": "log_min_duration_statement_no_data_message1"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 9,
            "content": {
              "version": "KqlParameterItem/1.0",
              "parameters": [
                {
                  "id": "6f32682f-345f-457a-a520-5af97346253d",
                  "version": "KqlParameterItem/1.0",
                  "name": "duration",
                  "label": "select exec duration",
                  "type": 2,
                  "isRequired": true,
                  "typeSettings": {
                    "additionalResourceOptions": [],
                    "showDefault": false
                  },
                  "jsonData": "\r\n\r\n [\r\n    { \"label\": \">1 ms\", \"value\": 1 },\r\n    { \"label\": \">10 ms\", \"value\": 10 },\r\n    { \"label\": \">50 ms\", \"value\": 50 },\r\n    { \"label\": \">100 ms\", \"value\": 100, \"selected\": true },\r\n    { \"label\": \">200 ms\", \"value\": 200 },\r\n    { \"label\": \">400 ms\", \"value\": 400 },\r\n    { \"label\": \">800 ms\", \"value\": 800 },\r\n    { \"label\": \">1 sec\", \"value\": 1000 },\r\n    { \"label\": \">10 sec\", \"value\": 10000 },\r\n    { \"label\": \">1 min\", \"value\": 60000 },\r\n    { \"label\": \">2 min\", \"value\": 120000 },\r\n    { \"label\": \">5 min\", \"value\": 300000 }\r\n  ]\r\n",
                  "timeContext": {
                    "durationMs": 86400000
                  }
                }
              ],
              "style": "pills",
              "queryType": 0,
              "resourceType": "microsoft.operationalinsights/workspaces"
            },
            "name": "logmindurationfilters"
          },
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "tabs",
              "links": [
                {
                  "id": "2ed4fc78-b2e6-40fa-9bc5-2b47c85ba33f",
                  "cellValue": "logmindurationtab",
                  "linkTarget": "parameter",
                  "linkLabel": "Queries by total duration",
                  "subTarget": "total",
                  "style": "link"
                },
                {
                  "id": "1e78a655-9635-406a-b4c7-e202c6ef3cd6",
                  "cellValue": "logmindurationtab",
                  "linkTarget": "parameter",
                  "linkLabel": "Queries by mean duration",
                  "subTarget": "mean",
                  "style": "link"
                },
                {
                  "id": "a2e173a2-5be3-46a5-8a25-b49022c8d474",
                  "cellValue": "logmindurationtab",
                  "linkTarget": "parameter",
                  "linkLabel": "Queries by calls",
                  "subTarget": "calls",
                  "style": "link"
                }
              ]
            },
            "name": "logmindurationtabs"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graph_grain = iff({TimeRange:grain} < 5m, 5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet TopN = 25;\r\n\r\nlet base_logs = \r\n    {PGServerLogsTable}\r\n    | where TimeGenerated between (Start_Time .. End_Time)\r\n    | where Message has \"duration\"\r\n    | where Message !contains 'bind' and Message !contains 'parse'\r\n    | parse Message with * \"duration: \" duration_ms:double \" ms\" *\r\n    | extend statement = coalesce(\r\n      extract(@\"statement:\\s*((.|\\n)*)\", 1, Message),\r\n      extract(@\"execute\\s+[^\\s]+:\\s*((.|\\n)*)\", 1, Message))\r\n    | where isnotempty(statement)\r\n    | extend database = extract(\"db=([^,]+)\", 1, Message)\r\n    | extend application = extract(\"app=([^ ,]+)\", 1, Message)\r\n    | extend user = extract(\"user=([^,]+)\", 1, Message)\r\n    | where database !in('azure_sys', 'azure_maintenance')\r\n    | where user!=\"azuresu\"\r\n    | where duration_ms > {duration}\r\n    | project TimeGenerated, statement, duration_ms, database, application, user;\r\n\r\nlet summary = \r\n    base_logs\r\n    | summarize \r\n        calls = count(), \r\n        total_duration_ms = round(sum(duration_ms), 2), \r\n        avg_duration_ms = round(avg(duration_ms), 2),\r\n        p95_duration_ms = percentile(duration_ms, 95)\r\n      by statement, database, application, user;\r\n\r\nlet trends = \r\n    base_logs\r\n    | make-series \r\n        call_count = count(), \r\n        total_duration = sum(duration_ms),\r\n        p95_duration_trend = percentile(duration_ms, 95)\r\n        on TimeGenerated from Start_Time to End_Time step graph_grain\r\n        by statement, database, application, user;\r\n\r\ntrends\r\n| join kind=inner (summary) on statement, database, application, user\r\n| project statement, database, application, user, \r\n       calls, \r\n       ['calls trend'] = call_count, \r\n       ['total duration'] = total_duration_ms, \r\n       ['total duration trend'] = total_duration, \r\n       ['avg duration'] = avg_duration_ms, \r\n       ['p95 duration'] = p95_duration_ms, \r\n       ['p95 duration trend'] = p95_duration_trend\r\n| order by ['total duration'] desc\r\n| serialize\r\n| extend rank = row_number()\r\n| project rank, statement, database, application, user, \r\n         calls, \r\n         ['total duration'], \r\n         ['avg duration'], \r\n         ['p95 duration'], \r\n         ['calls trend'], \r\n         ['total duration trend'], \r\n         ['p95 duration trend']\r\n| limit TopN\r\n\r\n",
              "size": 0,
              "noDataMessage": "The query returned no data. Try reducing the execution duration threshold to include more results.",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "statement",
                    "formatter": 7,
                    "formatOptions": {
                      "linkTarget": "CellDetails",
                      "linkIsContextBlade": true
                    }
                  },
                  {
                    "columnMatch": "calls",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": false
                      }
                    }
                  },
                  {
                    "columnMatch": "total duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "avg duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "p95 duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "calls trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  },
                  {
                    "columnMatch": "total duration trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  },
                  {
                    "columnMatch": "p95 duration trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  }
                ],
                "filter": true
              }
            },
            "conditionalVisibility": {
              "parameterName": "logmindurationtab",
              "comparison": "isEqualTo",
              "value": "total"
            },
            "name": "queriesfromlogstotalduration"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graph_grain = iff({TimeRange:grain} < 5m, 5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet TopN = 25;\r\n\r\nlet base_logs = \r\n    {PGServerLogsTable}\r\n    | where TimeGenerated between (Start_Time .. End_Time)\r\n    | where Message has \"duration\"\r\n    | where Message !contains 'bind' and Message !contains 'parse'\r\n    | parse Message with * \"duration: \" duration_ms:double \" ms\" *\r\n    | extend statement = coalesce(\r\n      extract(@\"statement:\\s*((.|\\n)*)\", 1, Message),\r\n      extract(@\"execute\\s+[^\\s]+:\\s*((.|\\n)*)\", 1, Message))\r\n    | where isnotempty(statement)\r\n    | extend database = extract(\"db=([^,]+)\", 1, Message)\r\n    | extend application = extract(\"app=([^ ,]+)\", 1, Message)\r\n    | extend user = extract(\"user=([^,]+)\", 1, Message)\r\n    | where database !in('azure_sys', 'azure_maintenance')\r\n    | where user!=\"azuresu\"\r\n    | where duration_ms >{duration}\r\n    | project TimeGenerated, statement, duration_ms, database, application, user;\r\n\r\nlet summary = \r\n    base_logs\r\n    | summarize \r\n        calls = count(), \r\n        avg_duration_ms = round(avg(duration_ms), 2),\r\n        total_duration_ms = round(sum(duration_ms), 2),\r\n        p95_duration_ms = percentile(duration_ms, 95)\r\n      by statement, database, application, user;\r\n\r\nlet trends = \r\n    base_logs\r\n    | make-series \r\n        call_count = count(), \r\n        avg_duration_trend = avg(duration_ms),\r\n        p95_duration_trend = percentile(duration_ms, 95)\r\n        on TimeGenerated from Start_Time to End_Time step graph_grain\r\n        by statement, database, application, user;\r\n\r\n\r\ntrends\r\n| join kind=inner (summary) on statement, database, application, user\r\n| project statement, database, application, user, \r\n         calls, \r\n         ['calls trend'] = call_count, \r\n         ['avg duration'] = avg_duration_ms, \r\n         ['total duration'] = total_duration_ms, \r\n         ['p95 duration'] = p95_duration_ms, \r\n         ['avg duration trend'] = avg_duration_trend, \r\n         ['p95 duration trend'] = p95_duration_trend\r\n| order by ['avg duration'] desc\r\n| serialize\r\n| extend rank = row_number()\r\n| project rank, statement, database, application, user, \r\n         calls, \r\n         ['avg duration'], \r\n         ['total duration'], \r\n         ['p95 duration'], \r\n         ['calls trend'], \r\n         ['avg duration trend'], \r\n         ['p95 duration trend']\r\n| limit TopN\r\n\r\n",
              "size": 0,
              "noDataMessage": "The query returned no data. Try reducing the execution duration threshold to include more results.",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "statement",
                    "formatter": 7,
                    "formatOptions": {
                      "linkTarget": "CellDetails",
                      "linkIsContextBlade": true
                    }
                  },
                  {
                    "columnMatch": "calls",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": false
                      }
                    }
                  },
                  {
                    "columnMatch": "avg duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "total duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "p95 duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "avg duration trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  },
                  {
                    "columnMatch": "p95 duration trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  },
                  {
                    "columnMatch": "calls trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  }
                ],
                "filter": true
              },
              "sortBy": []
            },
            "conditionalVisibility": {
              "parameterName": "logmindurationtab",
              "comparison": "isEqualTo",
              "value": "mean"
            },
            "name": "queriesfromlogsbymeanduration"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graph_grain = iff({TimeRange:grain} < 5m, 5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet TopN = 25;\r\n\r\nlet base_logs = \r\n    {PGServerLogsTable}\r\n    | where TimeGenerated between (Start_Time .. End_Time)\r\n    | where Message has \"duration\"\r\n    | where Message !contains 'bind' and Message !contains 'parse'\r\n    | parse Message with * \"duration: \" duration_ms:double \" ms\" *\r\n    | extend statement = coalesce(\r\n      extract(@\"statement:\\s*((.|\\n)*)\", 1, Message),\r\n      extract(@\"execute\\s+[^\\s]+:\\s*((.|\\n)*)\", 1, Message))\r\n    | where isnotempty(statement)\r\n    | extend database = extract(\"db=([^,]+)\", 1, Message)\r\n    | extend application = extract(\"app=([^ ,]+)\", 1, Message)\r\n    | extend user = extract(\"user=([^,]+)\", 1, Message)\r\n    | where database !in('azure_sys', 'azure_maintenance')\r\n    | where user!=\"azuresu\"\r\n    | where duration_ms > {duration}\r\n    | project TimeGenerated, statement, duration_ms, database, application, user;\r\n\r\nlet summary = \r\n    base_logs\r\n    | summarize \r\n        calls = count(), \r\n        avg_duration_ms = round(avg(duration_ms), 2),\r\n        total_duration_ms = round(sum(duration_ms), 2),\r\n        p95_duration_ms = percentile(duration_ms, 95)\r\n      by statement, database, application, user\r\n    | extend calls_per_minute = round(calls / (datetime_diff('minute', End_Time, Start_Time)), 2);\r\n\r\nlet trends = \r\n    base_logs\r\n    | make-series \r\n        call_count = count(), \r\n        avg_duration_trend = avg(duration_ms),\r\n        p95_duration_trend = percentile(duration_ms, 95)\r\n        on TimeGenerated from Start_Time to End_Time step graph_grain\r\n        by statement, database, application, user;\r\n\r\ntrends\r\n| join kind=inner (summary) on statement, database, application, user\r\n| project statement, database, application, user, \r\n         calls, \r\n         ['calls per minute'] = calls_per_minute, \r\n         ['calls trend'] = call_count, \r\n         ['avg duration'] = avg_duration_ms, \r\n         ['total duration'] = total_duration_ms, \r\n         ['p95 duration'] = p95_duration_ms, \r\n         ['avg duration trend'] = avg_duration_trend, \r\n         ['p95 duration trend'] = p95_duration_trend\r\n| order by calls desc\r\n| serialize\r\n| extend rank = row_number()\r\n| project rank, statement, database, application, user, \r\n         calls, \r\n         ['calls per minute'], \r\n         ['avg duration'], \r\n         ['total duration'], \r\n         ['p95 duration'], \r\n         ['calls trend'], \r\n         ['avg duration trend'], \r\n         ['p95 duration trend']\r\n| limit TopN\r\n",
              "size": 0,
              "noDataMessage": "The query returned no data. Try reducing the execution duration threshold to include more results.",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "statement",
                    "formatter": 7,
                    "formatOptions": {
                      "linkTarget": "CellDetails",
                      "linkIsContextBlade": true
                    }
                  },
                  {
                    "columnMatch": "calls",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal",
                        "useGrouping": false
                      }
                    }
                  },
                  {
                    "columnMatch": "calls per minute",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "avg duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "total duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "p95 duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "calls trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    },
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "avg duration trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  },
                  {
                    "columnMatch": "p95 duration trend",
                    "formatter": 21,
                    "formatOptions": {
                      "palette": "blue"
                    }
                  }
                ],
                "filter": true
              }
            },
            "conditionalVisibility": {
              "parameterName": "logmindurationtab",
              "comparison": "isEqualTo",
              "value": "calls"
            },
            "name": "queriesfromlogs"
          },
          {
            "type": 1,
            "content": {
              "json": "> **Note:**  \r\n> High log volume may cause query failures. This often happens when `log_min_duration_statement` is set to `0`, logging every query.  \r\n> To fix this, try increasing the **execution duration filter** or raise the `log_min_duration_statement` value to reduce log noise.\r\n",
              "style": "info"
            },
            "name": "text - 5"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "GetDataFrom",
          "comparison": "isEqualTo",
          "value": "log_min_duration_statement"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "IsLogMinDurationDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "queriesfromlogsGroup"
    },
    {
      "type": 1,
      "content": {
        "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": ""
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu longsessions lana"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": ""
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu longsessions layes"
    },
    {
      "type": 1,
      "content": {
        "json": "#### No telemetry data available for the selected time window.\r\nIt appears that there are currently no entries in the Log Analytics workspace. If you've recently configured `log_min_duration_statement` on your server, If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "GetDataFrom",
          "comparison": "isEqualTo",
          "value": "log_min_duration_statement"
        },
        {
          "parameterName": "IsLogMinDurationDataExists",
          "comparison": "isNotEqualTo",
          "value": "Yes"
        }
      ],
      "name": "log_min_duration_statement_no_data_message"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu qs layes "
    },
    {
      "type": 1,
      "content": {
        "json": "#### Query store is not enabled on the server. ",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu qs layes  - Copy"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "98d4f3a7-4057-400a-a84f-cbd61df98051",
            "version": "KqlParameterItem/1.0",
            "name": "TopTimeConsumingQueries",
            "label": "Maximum queries",
            "type": 2,
            "isRequired": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "jsonData": "[\r\n { \"value\":\"5\", \"label\":\"5\",\"selected\":true },\r\n  { \"value\":\"10\", \"label\":\"10\" },\r\n    { \"value\":\"20\", \"label\":\"20\" }\r\n]",
            "timeContext": {
              "durationMs": 86400000
            }
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "phigh cpu qs maxcount"
    },
    {
      "type": 1,
      "content": {
        "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "LessThanOneHourInterval",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs time interval"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "links": [
          {
            "id": "cb78e5e9-2ef1-4f4c-832f-6ddc98ae5c6f",
            "cellValue": "connection-tab-3",
            "linkTarget": "parameter",
            "linkLabel": "Top queries by mean duration",
            "subTarget": "TT",
            "style": "link"
          },
          {
            "id": "ce889247-43cd-4b4b-affb-b0753d5173ee",
            "cellValue": "connection-tab-3",
            "linkTarget": "parameter",
            "linkLabel": "Top queries by calls ",
            "subTarget": "TPS",
            "style": "link"
          },
          {
            "id": "000c095e-321a-46cb-8b9a-2269a2eac0ba",
            "cellValue": "connection-tab-3",
            "linkTarget": "parameter",
            "linkLabel": "Top queries by total duration",
            "subTarget": "TotalTime",
            "style": "link"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs tab"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet TopQueryIDs = \r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(MeanExecDurationMs) by QueryId\r\n| top {TopTimeConsumingQueries} by max_MeanExecDurationMs desc\r\n| project QueryId;\r\n{QueryStoreTable} \r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user  \r\n| where QueryId in (TopQueryIDs)\r\n |distinctEndTime,MeanExecDurationMs,QueryId\r\n| extend  EVENT_TIME_GRAPHGRAIN = bin(EndTime, 1m)\r\n//| extend  EVENT_TIME_GRAPHGRAIN = bin(todatetime(End_time_t), graphgrain)\r\n| make-series maxiotime=max(MeanExecDurationMs) default=0 on EVENT_TIME_GRAPHGRAIN from TimeStart to TimeEnd step graphgrain by QueryId=strcat('',QueryId)\r\n",
        "size": 0,
        "aggregation": 2,
        "title": "Top {TopTimeConsumingQueries} slowest queries from query store. Data is plotted at a granularity of {ChartGrain}",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "areachart",
        "chartSettings": {
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": true
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs chart"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet TopQueryIDs = \r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(TotalExecDurationMs) by QueryId\r\n| top {TopTimeConsumingQueries} by max_TotalExecDurationMs desc\r\n| project QueryId;\r\n{QueryStoreTable} \r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user  \r\n| where QueryId in (TopQueryIDs)\r\n |distinctEndTime,TotalExecDurationMs,QueryId\r\n| extend  EVENT_TIME_GRAPHGRAIN = bin(EndTime, 1m)\r\n//| extend  EVENT_TIME_GRAPHGRAIN = bin(todatetime(End_time_t), graphgrain)\r\n| make-series maxiotime=max(TotalExecDurationMs) default=0 on EVENT_TIME_GRAPHGRAIN from TimeStart to TimeEnd step graphgrain by QueryId=strcat('',QueryId)\r\n",
        "size": 0,
        "aggregation": 2,
        "title": "Top {TopTimeConsumingQueries} slow queries by total duration from query store. Data is plotted at a granularity of {ChartGrain}",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "areachart",
        "chartSettings": {
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": true
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TotalTime"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "QueryStoreTotalTimeChart"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet TopQueryIDs = \r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(Calls) by QueryId\r\n| top {TopTimeConsumingQueries} by max_Calls desc\r\n| project QueryId;\r\n{QueryStoreTable} \r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n | where QueryId in (TopQueryIDs)\r\n |distinctEndTime,Calls,QueryId\r\n| extend  EVENT_TIME_GRAPHGRAIN = bin(EndTime, graphgrain)\r\n//| extend  EVENT_TIME_GRAPHGRAIN = bin(todatetime(End_time_t), graphgrain)\r\n| make-series maxiotime=sum(Calls) default=0 on EVENT_TIME_GRAPHGRAIN from TimeStart to TimeEnd step graphgrain by QueryId=strcat('',QueryId)\r\n",
        "size": 0,
        "title": "Top {TopTimeConsumingQueries} queries by calls. Data is plotted at a granularity of {ChartGrain}",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "areachart",
        "chartSettings": {
          "showLegend": true
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs rollup"
    },
    {
      "type": 1,
      "content": {
        "json": "**Shown above is the mean execution duration of the {TopTimeConsumingQueries} slowest queries.** \r\n\r\n\r\nBad performing queries or queries that take too long to complete might be the ones that consume more CPU. Details on these queries, identified by their query identifier, are shown below.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs chart info"
    },
    {
      "type": 1,
      "content": {
        "json": "**Shown above is the total execution duration of the {TopTimeConsumingQueries} slowest queries for the period analyzed. ** \r\n\r\n\r\nBad performing queries or queries that take too long to complete might be the ones that consume more CPU. Details on these queries, identified by their query identifier, are shown below.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TotalTime"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "QueryStoreTotalTimeChartFooter"
    },
    {
      "type": 1,
      "content": {
        "json": "**Shown above is the number of calls of the top {TopTimeConsumingQueries} slowest queries.** \r\n\r\n\r\nQueries with high execution counts might be the ones which consume CPU. Details on these queries, identified by their query identifier, are shown below.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs rollup info"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "98d4f3a7-4057-400a-a84f-cbd61df98051",
            "version": "KqlParameterItem/1.0",
            "name": "QueryIdsByTime",
            "label": "Snapshot for query id",
            "type": 2,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= Start_Time and EndTime <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(MeanExecDurationMs) by QueryId\r\n| top {TopTimeConsumingQueries} by max_MeanExecDurationMs desc\r\n| project QueryId\r\n| serialize Rank = row_number()\r\n| project value = QueryId, label = QueryId, selected = iff(Rank == 1, true, false)",
            "crossComponentResources": [
              "{Resource}"
            ],
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "value": null
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs rank query"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "65163611-1b30-4c2f-b2a8-2338473becdb",
            "version": "KqlParameterItem/1.0",
            "name": "QueryIdsByTotalTime",
            "label": "Snapshot for query id",
            "type": 2,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= Start_Time and EndTime <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(TotalExecDurationMs) by QueryId\r\n| top {TopTimeConsumingQueries} by max_TotalExecDurationMs desc\r\n| project QueryId\r\n| serialize Rank = row_number()\r\n| project value = QueryId, label = QueryId, selected = iff(Rank == 1, true, false)",
            "crossComponentResources": [
              "{Resource}"
            ],
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "value": null
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TotalTime"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "QueryStoreTotalTimeSnapshotDropDown"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "a6fd4d67-8fe0-4d80-a680-a7aadf93d2ed",
            "version": "KqlParameterItem/1.0",
            "name": "QueryIdsbyCalls",
            "label": "Snapshot for query id",
            "type": 2,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= Start_Time and EndTime <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(Calls) by QueryId \r\n    | top {TopTimeConsumingQueries} by max_Calls desc\r\n| project QueryId\r\n| serialize Rank = row_number()\r\n| project value = QueryId, label = QueryId, selected = iff(Rank == 1, true, false)",
            "crossComponentResources": [
              "{Resource}"
            ],
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "value": null
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls snaphot"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| where QueryId == {QueryIdsByTime}\r\n| distinct MeanExecDurationMs, MaxExecDurationMs, MinExecDurationMs, Calls, QueryId, QueryType, RuntimeStatsEntryId \r\n| summarize ['mean execution duration'] = avg(MeanExecDurationMs), ['maximum execution duration'] = max(MaxExecDurationMs), ['minimum execution duration'] = min(MinExecDurationMs), ['total calls'] = sum(Calls) by QueryId, QueryType\r\n| project-rename ['query identifier'] = QueryId, ['query type'] = QueryType\r\n\r\n",
        "size": 4,
        "title": "Summary for query with identifier {QueryIdsByTime} for the period analyzed",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "mean execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "minimum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "total calls",
              "formatter": 8,
              "formatOptions": {
                "palette": "green"
              }
            },
            {
              "columnMatch": "query identifier",
              "formatter": 1
            },
            {
              "columnMatch": "query type",
              "formatter": 1
            }
          ],
          "rowLimit": 10000
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls rollup"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| where QueryId == {QueryIdsByTotalTime}\r\n|distinctTotalExecDurationMs,MeanExecDurationMs,MaxExecDurationMs,MinExecDurationMs,Calls,QueryId,QueryType,RuntimeStatsEntryId \r\n| summarize ['total execution duration'] = sum(TotalExecDurationMs), ['mean execution duration'] = avg(MeanExecDurationMs), ['maximum execution duration'] = max(MaxExecDurationMs), ['minimum execution duration'] = min(MinExecDurationMs), ['total calls'] = sum(Calls) by QueryId,QueryType\r\n| project-rename ['query identifier'] = QueryId, ['query type'] = QueryType\r\n\r\n",
        "size": 4,
        "title": "Summary for query with identifier {QueryIdsByTotalTime} for the period analyzed",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "total execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "mean execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "minimum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "total calls",
              "formatter": 8,
              "formatOptions": {
                "palette": "green"
              }
            },
            {
              "columnMatch": "query identifier",
              "formatter": 1
            },
            {
              "columnMatch": "query type",
              "formatter": 1
            }
          ],
          "rowLimit": 10000
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TotalTime"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "QueryStoreTotalTimeSnapshotHistoryGrid"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| where QueryId == {QueryIdsbyCalls}\r\n| distinct MeanExecDurationMs,MaxExecDurationMs,MinExecDurationMs,Calls,QueryId,QueryType,RuntimeStatsEntryId\r\n| summarize ['mean execution duration'] = avg(MeanExecDurationMs), ['maximum execution duration'] = max(MaxExecDurationMs), ['minimum execution duration'] = min(MinExecDurationMs), ['total calls'] = sum(Calls) by QueryId,QueryType\r\n| project-rename ['query identifier'] = QueryId, ['query type'] = QueryType",
        "size": 4,
        "title": "Summary for query with identifier {QueryIdsbyCalls} for the period analyzed",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "mean execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "minimum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "total calls",
              "formatter": 8,
              "formatOptions": {
                "palette": "green"
              }
            },
            {
              "columnMatch": "query identifier",
              "formatter": 1
            },
            {
              "columnMatch": "query type",
              "formatter": 1
            }
          ],
          "rowLimit": 10000
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls sumup query"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet DatabaseName = \r\n{SessionsTable}\r\n|distinct DatabaseName,DatabaseId;\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10\r\n| where QueryId == {QueryIdsByTime}\r\n| distinct MeanExecDurationMs,MaxExecDurationMs,MinExecDurationMs,Calls,QueryId,QueryType,Rows,TotalExecDurationMs,StartTime,EndTime,PlanId,DatabaseId,UserId,RuntimeStatsEntryId\r\n| summarize WindowStart=min(StartTime), WindowEnd=max(EndTime),MeanRows=sum(Rows)/sum(Calls),MeanExecutionTime=avg(MeanExecDurationMs),MinExecutionTime=min(MinExecDurationMs),MaxExecutionTime=max(MaxExecDurationMs),TotalCalls=sum(Calls),TotalExecutionTime=sum(TotalExecDurationMs),TotalRows=sum(Rows) by bin(EndTime, graphgrain),QueryId,QueryType,PlanId,DatabaseId,UserId\r\n| join kind=leftouter DatabaseName on $left.DatabaseId == $right.DatabaseId\r\n| project ['query identifier'] = QueryId, ['query type'] = QueryType, ['plan identifier'] = PlanId, ['database name'] = iff(isempty(DatabaseName), strcat('oid::', DatabaseId), DatabaseName), ['user identifier'] = UserId, ['window start'] = WindowStart, ['window end'] = WindowEnd, ['mean rows'] = MeanRows, ['mean execution duration'] = MeanExecutionTime, ['minimum execution duration'] = MinExecutionTime, ['maximum execution duration'] = MaxExecutionTime, ['total calls'] = TotalCalls, ['total execution duration'] = TotalExecutionTime, ['total rows'] = TotalRows\r\n| order by ['window start'] asc\r\n\r\n\r\n",
        "size": 0,
        "title": "Runtime statistics for query with identifier {QueryIdsByTime} split by time buckets of {ChartGrain}",
        "noDataMessage": "No data available during the period selected",
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "window start",
              "formatter": 6
            },
            {
              "columnMatch": "window end",
              "formatter": 6
            },
            {
              "columnMatch": "total rows",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "mean execution duration",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              },
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "minimum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "total calls",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "total execution duration",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              },
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "query identifier",
              "formatter": 1
            },
            {
              "columnMatch": "query type",
              "formatter": 1
            }
          ],
          "rowLimit": 10000,
          "filter": true
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls history"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet DatabaseName = \r\n{SessionsTable}\r\n|distinct DatabaseName,DatabaseId;\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10   \r\n| where QueryId == {QueryIdsByTotalTime}\r\n|distinctMeanExecDurationMs,MaxExecDurationMs,MinExecDurationMs,Calls,QueryId,QueryType,Rows,TotalExecDurationMs,StartTime,EndTime,PlanId,DatabaseId,UserId,RuntimeStatsEntryId      \r\n| summarize WindowStart=min(StartTime), WindowEnd=max(EndTime),MeanRows=sum(Rows)/sum(Calls),TotalExecutionTime=sum(TotalExecDurationMs),MeanExecutionTime=avg(MeanExecDurationMs),MinExecutionTime=min(MinExecDurationMs),MaxExecutionTime=max(MaxExecDurationMs),TotalCalls=sum(Calls),TotalRows=sum(Rows) by bin(EndTime, graphgrain),QueryId,QueryType,PlanId,DatabaseId,UserId    \r\n| join kind=leftouter DatabaseName on $left.DatabaseId == $right.DatabaseId\r\n| project ['query identifier'] =  QueryId, ['query type'] = QueryType, ['plan identifier'] = PlanId, ['database name'] = iff(isempty(DatabaseName), strcat('oid::', DatabaseId), DatabaseName), ['user identifier'] = UserId, ['window start'] = WindowStart, ['window end'] = WindowEnd, ['total calls'] = TotalCalls, ['total execution duration'] = TotalExecutionTime, ['total rows'] = TotalRows  \r\n|order by ['window start'] asc",
        "size": 0,
        "title": "Runtime statistics for query with identifier {QueryIdsByTotalTime} split by time buckets of {ChartGrain}",
        "noDataMessage": "No data available during the period selected",
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "window start",
              "formatter": 6
            },
            {
              "columnMatch": "window end",
              "formatter": 6
            },
            {
              "columnMatch": "mean execution duration",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              },
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "minimum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "total calls",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "total rows",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "total execution durationduration",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              },
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "query identifier",
              "formatter": 1
            },
            {
              "columnMatch": "query type",
              "formatter": 1
            }
          ],
          "rowLimit": 10000,
          "filter": true
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TotalTime"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "QueryStoreTotalTimeHistoryGrid"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain} < 15m, 15m, {TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet DatabaseName = \r\n{SessionsTable}\r\n| distinct DatabaseName,DatabaseId;\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n|  where UserId != 10   \r\n| where QueryId == {QueryIdsbyCalls}\r\n| distinct MeanExecDurationMs, MaxExecDurationMs, MinExecDurationMs, Calls, QueryId, QueryType, Rows, TotalExecDurationMs, StartTime, EndTime, PlanId, DatabaseId, UserId, RuntimeStatsEntryId\r\n| summarize WindowStart = min(StartTime), WindowEnd = max(EndTime), MeanRows = sum(Rows)/sum(Calls), MeanExecutionTime = avg(MeanExecDurationMs), MinExecutionTime = min(MinExecDurationMs), MaxExecutionTime = max(MaxExecDurationMs), TotalCalls = sum(Calls), TotalExecutionTime = sum(TotalExecDurationMs), TotalRows = sum(Rows) by bin(EndTime, graphgrain), QueryId, QueryType, PlanId, DatabaseId, UserId\r\n| join kind=leftouter DatabaseName on $left.DatabaseId == $right.DatabaseId\r\n| project ['query identifier'] = QueryId, ['query type'] = QueryType, ['plan identifier'] = PlanId, ['database name'] = iff(isempty(DatabaseName), strcat('oid::', DatabaseId), DatabaseName), ['user identifier'] = UserId, ['window start'] = WindowStart, ['window end'] = WindowEnd, ['mean rows'] = MeanRows, ['mean execution duration'] = MeanExecutionTime, ['minimum execution duration'] = MinExecutionTime, ['maximum execution duration'] = MaxExecutionTime, ['total calls'] = TotalCalls, ['total execution duration'] = TotalExecutionTime, ['total rows'] = TotalRows\r\n| order by ['window start'] asc",
        "size": 0,
        "title": "Runtime statistics for query with identifier {QueryIdsbyCalls} split by time buckets of {ChartGrain}",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "EndTime",
              "formatter": 5
            },
            {
              "columnMatch": "window start",
              "formatter": 6
            },
            {
              "columnMatch": "window end",
              "formatter": 6
            },
            {
              "columnMatch": "total rows",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "mean execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "minimum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "maximum execution duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "total calls",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "total rows",
              "formatter": 8,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "TotalExecutionTime",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "End_time",
              "formatter": 5
            },
            {
              "columnMatch": "query identifier",
              "formatter": 1
            },
            {
              "columnMatch": "user identifier",
              "formatter": 1
            },
            {
              "columnMatch": "query type",
              "formatter": 1
            }
          ],
          "rowLimit": 10000,
          "filter": true
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls all query"
    },
    {
      "type": 1,
      "content": {
        "json": "**How can you retrieve the text for a specific query?**\r\n\r\nTo retrieve the text for a specific query, you need to follow these steps:\r\n\r\n1. Connect to the server using the **`azure_sys`** database, in which query store persists the information it collects. For example, you can use the following command:\r\n```SQL\r\npsql -h <server_name>.postgres.database.azure.com -U <admin_user_name> -d azure_sys\r\n```\r\n\r\n2. Use the generated `query text` column to retrieve the text of the query associated with the query identifier.\r\n\r\nIt is important to note that the retention period for query store applies when querying the database, and older data gets deleted based on the server parameter `pg_qs.retention_period_in_days`. However, our telemetry has a higher retention period.\r\n\r\n**To retrieve the text of the query for a given query identifier, use the following SQL:**",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls querytext info"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= Start_Time and EndTime <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(MeanExecDurationMs) by QueryId\r\n| top {TopTimeConsumingQueries} by max_MeanExecDurationMs desc\r\n| extend GetQueryText = strcat(\"SELECT query_sql_text FROM query_store.query_texts_view WHERE query_text_id=\",QueryId,\";\")\r\n| project ['query text'] = GetQueryText",
        "size": 1,
        "title": "Get text of a query using its identifier",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TT"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxcalls querytext query"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= Start_Time and EndTime <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(TotalExecDurationMs) by QueryId\r\n| top {TopTimeConsumingQueries} by max_TotalExecDurationMs desc\r\n| extend GetQueryText = strcat(\"SELECT query_sql_text FROM query_store.query_texts_view WHERE query_text_id=\",QueryId,\";\")\r\n| project ['query text'] = GetQueryText",
        "size": 1,
        "title": "Get text of a query using its identifier",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TotalTime"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "QueryStoreTotalTimeSQLStatementsGrid"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= Start_Time and EndTime <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| summarize max(Calls) by QueryId\r\n| top {TopTimeConsumingQueries} by max_Calls desc\r\n| extend GetQueryText = strcat(\"SELECT query_sql_text FROM query_store.query_texts_view WHERE query_text_id=\",QueryId,\";\")\r\n| project ['query text'] = GetQueryText",
        "size": 1,
        "title": "Get text of a query using its identifier",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab-3",
          "comparison": "isEqualTo",
          "value": "TPS"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs maxtime query text query"
    },
    {
      "type": 1,
      "content": {
        "json": "**General recommendations to tune high CPU consuming queries**\r\n\r\n1) As a long term approach, consider leveraging [index tuning](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-index-tuning) feature to get index recommendations that would optimize your workload.\r\n\r\n2) You can also use EXPLAIN ANALYZE to manually tune the queries identified above. More information on EXPLAIN command can be found [here](https://www.postgresql.org/docs/current/sql-explain.html).\r\n\r\n3) High bloat on the tables can also lead to considerable IO & CPU utilization. As a one off case consider carrying manual vacuum analyze of the tables used in the slow running queries using the below command on the database:\r\n\r\n\tVACUUM (ANALYZE, VERBOSE) <table_name> \r\n\r\n4) Indexes and joins: Consider creating indexes and reduce the joins in the query, if applicable.\r\n\r\n5) Consider tuning server parameters like `max_connections`, `max_parallel_workers_per_gather`. Please, make the changes with caution and testing as setting a very high value of both parameters could lead to CPU depletion issues.\r\n\r\n6) Table design needs to considered.\r\n\t* Large tables can be partitioned.\r\n\t* Remove unneccesary constraints.\r\n\t* Have indexes on foreign keys in child tables.\r\n\t* If possible consider to denormalize the tables.\r\n\t* Disable triggers during large dataloads as triggers on tables affect especially during writes on the server",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "isQueryStoreEnabled",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "HighCPUQueries",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        }
      ],
      "name": "high cpu qs recomendation"
    },
    {
      "type": 1,
      "content": {
        "json": "### Query store's capabilities are not functioning on the replica server.\r\n#### After analysis, we have determined that this server is a replica server, which means that the query store functionality is not available. However, there are alternative methods you can use to monitor long-running sessions on the replica server.\r\n- To help pinpoint possible performance issues, a recommended solution is to adjust the `log_min_duration_statement` parameter to the desired threshold and properly configure `log_line_prefix` to include the relevant details such as **%t-%c user=%u,db=%d,app=%a,client=%h**. This will enable the logging of slow queries in the PostgreSQL logs. By doing so, you can easily access the top queries and review the slow queries that may require optimization.\r\n- Another option is to configure `pg_stat_statements`, which allows you to view information about your query performance on the replica server. However, Please keep in mind that you need to execute the `CREATE EXTENSION pg_stat_statements` command on the primary server database. For more informaiton, please visit [PostgreSQL documentation](https://www.postgresql.org/docs/current/pgstatstatements.html).\r\n- You can also monitor the ongoing workload on the replica server by using the `pg_stat_activity` catalog view.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "hightimequeries"
        },
        {
          "parameterName": "GetDataFrom",
          "comparison": "isEqualTo",
          "value": "QueryStore"
        }
      ],
      "name": "high cpu qs read replica"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Sessions data logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL Sessions logs data is not being sent to the log analytics workspace, which is necessary to use this workbook. To configure the logging settings for category `PostgreSQL Sessions data` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsConnectionDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high cpu connections lno"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Sessions data logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL Sessions logs data is not being sent to the log analytics workspace, which is necessary to use this workbook. To configure the logging settings for category `PostgreSQL Sessions data` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsConnectionDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "high cpu connections layno replica"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graph_grain=iff({TimeRange:grain}<5m,5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Category ==\"PostgreSQLFlexSessions\"\r\n| where Usesysid_d != 10\r\n| where isnotempty(Datid_d) and Database_name_s !in('template1','template0', 'azure_maintenance','azure_sys')\r\n| where State_s !=\"\"\r\n| distinct TimeGenerated,Backend_start_t,Pid_d,State_s\r\n|summarize count_state=count() by bin(TimeGenerated,5m),State_s\r\n| make-series max_count= max(count_state) default=0 on TimeGenerated from Start_Time to End_Time step graph_grain by State_s\r\n|render timechart ",
              "size": 0,
              "aggregation": 2,
              "showAnnotations": true,
              "title": "Summary of total connection by state. Data is plotted at a granularity of {ChartGrainMin5}",
              "noDataMessage": "No data available during the period selected",
              "noDataMessageStyle": 4,
              "timeBrushParameterName": "TimeRange",
              "timeBrushExportOnlyWhenBrushed": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "timechart",
              "chartSettings": {
                "showLegend": true
              }
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsConnectionDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high cpu connections summary chart"
          },
          {
            "type": 1,
            "content": {
              "json": "### **Dealing with high number of connections**\r\n\r\nIf you are experiencing a high number of connections on your PostgreSQL database, consider following these recommendations:\r\n\r\n\r\n#### **Adjust server parameters**\r\n\r\nSet the `statement_timeout`, `idle_in_transaction_session_timeout` and `idle_session_timeout` (only available from version 14 of PostgreSQL) server parameters to appropriate values. These can help manage connections and prevent idle connections from consuming resources.\r\n\r\nFor more information, refer to [Connection handling best practices with PostgreSQL](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/connection-handling-best-practice-with-postgresql/ba-p/790883).\r\n\r\n#### **Consider using connection pooling**\r\n\r\nIn situations where there are a lot of idle connections or connections that are consuming CPU resources, consider using a connection pooler like PgBouncer.\r\n\r\nFor more details on PgBouncer and how it works, check out this reference on [connection pooler](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/not-all-postgres-connection-pooling-is-equal/ba-p/825717).\r\n\r\n##### **Set up PgBouncer**\r\n\r\nIf you're using Azure database for Flexible Server, you can take advantage of PgBouncer as a built-in connection pooling solution. For more information on how to set it up, see this resource: [PgBouncer in Azure database for PostgreSQL Flexible Server](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-pgbouncer).\r\n\r\n##### **Recommended settings for PgBouncer on Flexible Server**\r\n\r\n##### **Pool mode (`pool_mode`):**\r\n- `Transaction` pool mode is generally considered to be the most suitable mode for higher TPS scenarios, as it provides a new connection for each transaction and releases the connection immediately after the transaction is complete. This approach can help reduce connection overhead and improve performance, especially for systems with a high number of short-lived transactions.\r\n- In `session` pool mode, a client is assigned a server connection for the entire duration of its connection, and the connection is returned to the pool when the client disconnects. This approach can help reduce the overhead of establishing new connections, which can be beneficial for systems with a high number of relatively long-lived connections. Also, This mode supports all PostgreSQL features.\r\n\r\n**Pool size (`default_pool_size`):** Adjust the size of the pool based on your workload. Note that this setting is per user/database pair.\r\n\r\n**Timeouts:** To ensure that idle connections are closed and long running queries are terminated, set the `server_idle_timeout` and `query_timeout` parameters according to your workload needs.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsConnectionDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high cpu connections reco"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionstate"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "name": "high cpu connections conn tab"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "links": [
          {
            "id": "ce889247-43cd-4b4b-affb-b0753d5173ee",
            "cellValue": "connection-tab",
            "linkTarget": "parameter",
            "linkLabel": "Connections by state",
            "subTarget": "connectionstate",
            "style": "link"
          },
          {
            "id": "cb78e5e9-2ef1-4f4c-832f-6ddc98ae5c6f",
            "cellValue": "connection-tab",
            "linkTarget": "parameter",
            "linkLabel": "Connections by duration",
            "subTarget": "connectionsduration",
            "style": "link"
          },
          {
            "id": "aa67c695-80e1-4588-8b3a-99f43f151d20",
            "cellValue": "connection-tab",
            "linkTarget": "parameter",
            "linkLabel": "PgBouncer connections statistics",
            "subTarget": "pgbouncer",
            "style": "link"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "connections"
      },
      "name": "high cpu connections - links"
    },
    {
      "type": 1,
      "content": {
        "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "LessThanOneHourInterval",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high cpu connections time interval"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionstate"
        }
      ],
      "name": "high cpu connections nodata"
    },
    {
      "type": 1,
      "content": {
        "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionstate"
        },
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": ""
        }
      ],
      "name": "high cpu connections connectionsno"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionstate"
        },
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": ""
        }
      ],
      "name": "high cpu connections layes"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graph_grain=iff({TimeRange:grain}<5m,5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('template1','template0', 'azure_maintenance','azure_sys')\r\n| where State !=\"\"\r\n| distinct TimeGenerated,BackendStartTime,ProcessId,State\r\n|summarize count_state=count() by bin(TimeGenerated,1m),State\r\n| make-series max_count= max(count_state) default=0 on TimeGenerated from Start_Time to End_Time step graph_grain by State\r\n//|render timechart ",
        "size": 0,
        "aggregation": 2,
        "showAnnotations": true,
        "title": "Summary of total connection by state",
        "noDataMessage": "No data available during the period selected",
        "noDataMessageStyle": 4,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "timechart",
        "chartSettings": {
          "showLegend": true
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionstate"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "name": "high cpu connections consummary by state"
    },
    {
      "type": 1,
      "content": {
        "json": "### **Dealing with high number of connections**\r\n\r\nIf you are experiencing a high number of connections on your PostgreSQL database, consider following these recommendations:\r\n\r\n\r\n#### **Adjust server parameters**\r\n\r\nSet the `statement_timeout`, `idle_in_transaction_session_timeout` and `idle_session_timeout` (only available from version 14 of PostgreSQL) server parameters to appropriate values. These can help manage connections and prevent idle connections from consuming resources.\r\n\r\nFor more information, refer to [Connection handling best practices with PostgreSQL](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/connection-handling-best-practice-with-postgresql/ba-p/790883).\r\n\r\n#### **Consider using connection pooling**\r\n\r\nIn situations where there are a lot of idle connections or connections that are consuming CPU resources, consider using a connection pooler like PgBouncer.\r\n\r\nFor more details on PgBouncer and how it works, check out this reference on [connection pooler](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/not-all-postgres-connection-pooling-is-equal/ba-p/825717).\r\n\r\n##### **Set up PgBouncer**\r\n\r\nIf you're using Azure database for Flexible Server, you can take advantage of PgBouncer as a built-in connection pooling solution. For more information on how to set it up, see this resource: [PgBouncer in Azure database for PostgreSQL Flexible Server](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-pgbouncer).\r\n\r\n##### **Recommended settings for PgBouncer on Flexible Server**\r\n\r\n##### **Pool mode (`pool_mode`):**\r\n- `Transaction` pool mode is generally considered to be the most suitable mode for higher TPS scenarios, as it provides a new connection for each transaction and releases the connection immediately after the transaction is complete. This approach can help reduce connection overhead and improve performance, especially for systems with a high number of short-lived transactions.\r\n- In `session` pool mode, a client is assigned a server connection for the entire duration of its connection, and the connection is returned to the pool when the client disconnects. This approach can help reduce the overhead of establishing new connections, which can be beneficial for systems with a high number of relatively long-lived connections. Also, This mode supports all PostgreSQL features.\r\n\r\n**Pool size (`default_pool_size`):** Adjust the size of the pool based on your workload. Note that this setting is per user/database pair.\r\n\r\n**Timeouts:** To ensure that idle connections are closed and long running queries are terminated, set the `server_idle_timeout` and `query_timeout` parameters according to your workload needs.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionstate"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "name": "high cpu connections conbystate reco"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLServerLogsDataExists",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionsduration"
        }
      ],
      "name": "high cpu connections conduration lano"
    },
    {
      "type": 1,
      "content": {
        "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLServerLogsDataExists",
          "comparison": "isEqualTo",
          "value": ""
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionsduration"
        },
        {
          "parameterName": "IsPostgreSQLLogsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "No"
        }
      ],
      "name": "high cpu connections conduration launknown"
    },
    {
      "type": 1,
      "content": {
        "json": "#### There is no data available in the telemetry for the chosen window or you may have recently configured logging for the server in question. Kindly allow 15 minutes to 30 minutes for the telemetry data to become visible.\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLServerLogsDataExists",
          "comparison": "isEqualTo",
          "value": ""
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionsduration"
        },
        {
          "parameterName": "IsPostgreSQLLogsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "thigh cpu connections conduration layes"
    },
    {
      "type": 1,
      "content": {
        "json": "This chart shows the count of connections categorized by their duration: **short** (less than 1 second), **normal** (between 1 second and 20 minutes), and **long** (greater than 20 minutes). These are calculated using disconnection messages extracted from PostgreSQL logs.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLServerLogsDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsConnectionDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionsduration"
        }
      ],
      "name": "high cpu connections conduration info"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"disconnection\"\r\n| distinct TimeGenerated,Message\r\n| extend DisconnectTime=TimeGenerated\r\n| extend allmatches=extract_all(@'session.time:(.+)user=(.+)database=(.+)host=(.+).port', Message)\r\n| extend duration=totime(allmatches[0][0])\r\n| extend user=trim(@\" \",tostring(allmatches[0][1]) )\r\n| extend database=tostring(allmatches[0][2])\r\n| extend IP=tostring(allmatches[0][3])\r\n| where user !in ('azuresu','replication')\r\n| extend ts = totimespan(duration)\r\n| extend DurationInSeconds = ts / 1s\r\n| extend ConnType=iff(DurationInSeconds <= 60, 'short', iff(DurationInSeconds > 60 and DurationInSeconds < 1200, 'normal','long'))\r\n| make-series Connections=count() default=0 on DisconnectTime from Start_Time to End_Time step {TimeRange:grain} by ConnType\r\n",
        "size": 0,
        "aggregation": 2,
        "title": "Summary of connections by duration",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "timechart",
        "chartSettings": {
          "showLegend": true
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLServerLogsDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "ConnectionDurationData",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionsduration"
        }
      ],
      "name": "high cpu connections conduration query chart"
    },
    {
      "type": 1,
      "content": {
        "json": "### **Dealing with high number of connections**\r\n\r\nIf you are experiencing a high number of connections on your PostgreSQL database, consider following these recommendations:\r\n\r\n\r\n#### **Adjust server parameters**\r\n\r\nSet the `statement_timeout`, `idle_in_transaction_session_timeout` and `idle_session_timeout` (only available from version 14 of PostgreSQL) server parameters to appropriate values. These can help manage connections and prevent idle connections from consuming resources.\r\n\r\nFor more information, refer to [Connection handling best practices with PostgreSQL](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/connection-handling-best-practice-with-postgresql/ba-p/790883).\r\n\r\n#### **Consider using connection pooling**\r\n\r\nIn situations where there are a lot of idle connections or connections that are consuming CPU resources, consider using a connection pooler like PgBouncer.\r\n\r\nFor more details on PgBouncer and how it works, check out this reference on [connection pooler](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/not-all-postgres-connection-pooling-is-equal/ba-p/825717).\r\n\r\n##### **Set up PgBouncer**\r\n\r\nIf you're using Azure database for Flexible Server, you can take advantage of PgBouncer as a built-in connection pooling solution. For more information on how to set it up, see this resource: [PgBouncer in Azure database for PostgreSQL Flexible Server](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-pgbouncer).\r\n\r\n##### **Recommended settings for PgBouncer on Flexible Server**\r\n\r\n##### **Pool mode (`pool_mode`):**\r\n- `Transaction` pool mode is generally considered to be the most suitable mode for higher TPS scenarios, as it provides a new connection for each transaction and releases the connection immediately after the transaction is complete. This approach can help reduce connection overhead and improve performance, especially for systems with a high number of short-lived transactions.\r\n- In `session` pool mode, a client is assigned a server connection for the entire duration of its connection, and the connection is returned to the pool when the client disconnects. This approach can help reduce the overhead of establishing new connections, which can be beneficial for systems with a high number of relatively long-lived connections. Also, This mode supports all PostgreSQL features.\r\n\r\n**Pool size (`default_pool_size`):** Adjust the size of the pool based on your workload. Note that this setting is per user/database pair.\r\n\r\n**Timeouts:** To ensure that idle connections are closed and long running queries are terminated, set the `server_idle_timeout` and `query_timeout` parameters according to your workload needs.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsPostgreSQLServerLogsDataExists",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "connectionsduration"
        }
      ],
      "name": "high cpu connections conduration recofinal",
      "styleSettings": {
        "padding": "0px"
      }
    },
    {
      "type": 1,
      "content": {
        "json": "#### PgBouncer metrics are disabled by default. For PgBouncer metrics to be emitted, both server parameters `pgbouncer.enabled` and `metrics.pgbouncer_diagnostics` must be enabled. These parameters are dynamic and don't require a restart of the server.\r\n\r\n#### Note: PgBouncer feature is currently not supported with the Burstable server compute tier.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "name": "pgbouncer connection stats note"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook34fd5643-2462-4b4a-bf8a-48e7807602fe",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-PgBouncer metrics-client_connections_active",
            "aggregation": 3
          }
        ],
        "title": "Active client connections (those that are either linked to server connections or are idle with no queries waiting to be processed)",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "customWidth": "50",
      "name": "pgbouncer active client connections chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook34fd5643-2462-4b4a-bf8a-48e7807602fe",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-PgBouncer metrics-client_connections_waiting",
            "aggregation": 3
          }
        ],
        "title": "Waiting client connections (those that have sent queries but have not yet got a server connection)",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "customWidth": "50",
      "name": "pgbouncer waiting client connection chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook34fd5643-2462-4b4a-bf8a-48e7807602fe",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-PgBouncer metrics-server_connections_idle",
            "aggregation": 3
          }
        ],
        "title": "Active server connections (server connections that are linked to a client)",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "customWidth": "50",
      "name": "pgbouncer active server connection chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook34fd5643-2462-4b4a-bf8a-48e7807602fe",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-PgBouncer metrics-server_connections_idle",
            "aggregation": 3
          }
        ],
        "title": "Idle server connections (those that are unused and immediately usable for client queries)",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "customWidth": "50",
      "name": "pgbouncer idle server connections chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook34fd5643-2462-4b4a-bf8a-48e7807602fe",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-PgBouncer metrics-total_pooled_connections",
            "aggregation": 3
          }
        ],
        "title": "Total pooled connections (current number of pooled connections)",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "customWidth": "50",
      "name": "pgbouncer total pooled connections chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook34fd5643-2462-4b4a-bf8a-48e7807602fe",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-PgBouncer metrics-num_pools",
            "aggregation": 3
          }
        ],
        "title": "Number of connection pools",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        }
      ],
      "customWidth": "50",
      "name": "pgbouncer number of connection pools chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 1,
      "content": {
        "json": "### Recommendations\r\n\r\n#### Scenario 1: Large number of clients waiting connections and active server connections is closer to default pool size\r\n\r\nIf the number of active server connections is close to the default pool size, and the number of client waiting connections is high, it generally indicates that PgBouncer is waiting for the queries to complete and cannot create any more connections.\r\n\r\n**Recommendation**: Identify slow queries and tune them. Additionally, consider configuring fixed query timeouts at the application level or at the database level.\r\n\r\n#### Scenario 2: Indications that you need more than one PgBouncer\r\n\r\nPgBouncer operates as a single-threaded process, implying that it utilizes only one CPU. Regardless of the size of your server, even if its a 32 or 64 core server, you can only allocate one of your processors to PgBouncer.\r\n\r\nSigns that a single PgBouncer instance is struggling include:\r\n\r\n- The wait times for application queries increase when the PgBouncer port (6432) is in use, and the default port (5432) performs better.\r\n- There are high active client connections and you are noticing an increase in waiting client connections.\r\n\r\n**Recommendation**: \r\n\r\n- Distribute the connection load across multiple PgBouncer instances on your own deployed and maintained Azure VMs.\r\n- Consider alternative solutions, including multithreaded solutions like PgCat, also on your own deployed and maintained Azure VMs.\r\n\r\n> Note: These are general recommendations and may need to be adjusted based on your specific use case and environment. Always monitor your system's performance and adjust as necessary.\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "connections"
        },
        {
          "parameterName": "connection-tab",
          "comparison": "isEqualTo",
          "value": "pgbouncer"
        },
        {
          "parameterName": "evaluate_pgbouncer_metrics_data",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "pgbouncer metric recommendations"
    },
    {
      "type": 1,
      "content": {
        "json": "## Locking and blocking\r\n\r\nThis tab offers a detailed analysis of the locking mechanisms in your PostgreSQL server. The data displayed here is based on the `log_lock_waits` & `metrics.collector_database_activity` parameters, `log_lock_waits` triggers a log message when a session's wait time to acquire a lock exceeds the `deadlock_timeout (default: 1s)`.\r\n\r\nThe main sections of this tab include:\r\n\r\n- **Sessions by lock wait event**: This metric provides a count of sessions that are waiting due to a `Lock` wait event.\r\n- **Duration of acquired locks categorized by lock type**: This chart displays the duration of locks that have been acquired in the system during a specified time window, categorized by lock type.\r\n- **Overview of waiting and acquired locks**: This grid view provides information about both acquired and waiting locks. It displays the duration for acquired locks. Notice that it doesn't  show the duration of waiting locks for sessions that have disconnected from the server without acquiring the lock.\r\n- **Blocking information**: This grid provides information about sessions that are still waiting to acquire a lock in the system during the specified time window.\r\n\r\n> **Note**: The `log_lock_waits` and `metrics.collector_database_activity` parameters are disabled by default. These are dynamic settings and, as such, changing them do not rquire a server restart.\r\n",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "Locks Header Message"
    },
    {
      "type": 1,
      "content": {
        "json": "#### The following chart presents a metric that represents the count of sessions in a lock wait_event. In PostgreSQL, a lock wait_event occurs when a session is waiting for a resource that is locked by another session.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "session count by lock wait chart info"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookb734d2e2-c7f7-4bcf-b81a-c06cebde236b",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 86400000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Activity-sessions_by_wait_event_type",
            "aggregation": 3
          }
        ],
        "title": "Sessions by lock wait event (number of sessions that currently have the \"Lock\" wait event type)",
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "2",
            "key": "WaitEventType",
            "operator": 0,
            "values": [
              "lock"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "heavyweight lock trend chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graph_grain=iff({TimeRange:grain}<5m,5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"still waiting for\"\r\n| distinct TimeGenerated,Message\r\n| extend LockType = extract(\"waiting for (\\\\w+)\", 1, Message)\r\n| extend Duration = extract(\"after ([\\\\d\\\\.]+) ms\", 1, Message)\r\n| project LockType, Duration, TimeGenerated\r\n| make-series Count=count() default=0 on TimeGenerated from Start_Time to End_Time step graph_grain by LockType",
        "size": 0,
        "title": "Distribution of waiting locks categorized by lock type",
        "noDataMessage": "No data available during the period selected",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "linechart",
        "chartSettings": {
          "showLegend": true
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "cputab",
          "comparison": "isEqualTo",
          "value": "locks"
        },
        {
          "parameterName": "xx",
          "comparison": "isEqualTo",
          "value": "y"
        }
      ],
      "customWidth": "50",
      "name": "WaitingLocksChart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 1,
      "content": {
        "json": "## Duration of acquired locks categorized by lock type\r\n\r\n#### The following chart presents the duration of acquired locks in a PostgreSQL database. Theses durations are logged when the `log_lock_waits` parameter is enabled.\r\n\r\nNotice that the chart doesn't display the duration of waiting locks for sessions that disconnected from the system prior to lock acquisition. For instance, if a long blocked session is noticed and subsequently terminated by an administrator, the duration of such lock wait will not be visible in this chart.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "Duration of locktype summary note"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graph_grain=iff({TimeRange:grain}<5m,5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"acquired\"\r\n| distinct TimeGenerated,Message\r\n| extend LockType = extract(\"acquired (\\\\w+)\", 1, Message)\r\n| extend Duration = extract(\"after ([\\\\d\\\\.]+) ms\", 1, Message)\r\n| project  TimeGenerated, LockType, Duration=todecimal(Duration)\r\n//| summarize max(todecimal(Duration)) by bin(TimeGenerated,graph_grain), LockType\r\n| make-series Duration=max(Duration) on TimeGenerated from Start_Time to End_Time step graph_grain by LockType",
        "size": 0,
        "aggregation": 2,
        "noDataMessage": "No data available during the period selected",
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "linechart",
        "chartSettings": {
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": true
              }
            }
          }
        }
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "AcquiredLocksDurationChartTrend",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 1,
      "content": {
        "json": "## Overview of waiting and acquired locks\r\n\r\nThe following grid shows duration of locks by waiting and acquired stage.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "Duration of lock grid view info"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graph_grain=iff({TimeRange:grain}<5m,5m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"acquired\" or  Message contains \"still waiting for\"\r\n| distinct TimeGenerated,Message, Statement, DetailLog, ProcessId, Context\r\n| extend timestamp = todatetime(extract(\"(\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2})\", 1, Message))\r\n| extend ConnectionId = extract(\"UTC-(.*?)\\\\-\", 1, Message)\r\n| extend BlockingProcessId = extract(\"Process holding the lock: (\\\\d+)\", 1, DetailLog)\r\n| extend Command = toupper(tostring(split(Statement, \" \")[0]))\r\n| extend LockType = case( Message contains \"waiting for\", extract(\"waiting for (.*?) on\", 1, Message),\r\n    Message contains \"acquired\", extract(\"acquired (.*?) on\", 1, Message),\r\n    \"Unknown\")\r\n| extend Duration = todecimal(extract(\"after ([\\\\d\\\\.]+) ms\", 1, Message))\r\n| summarize min(timestamp), max(timestamp), max(BlockingProcessId), Duration=max(Duration) by ProcessId, ConnectionId, Command, Statement, LockType, Context\r\n| join kind=leftouter (\r\n    {PGServerLogsTable}\r\n    | where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n    | where Message contains \"acquired\"\r\n    | distinct TimeGenerated,Message, Statement, Context\r\n    | extend ProcessId = toint(extract(\"process (\\\\d+)\", 1, Message))\r\n    | extend ConnectionId = extract(\"UTC-(.*?)\\\\-\", 1, Message)\r\n    | extend LockType = extract(\"acquired (.*)Lock\", 1, Message)\r\n    | extend LockAcquired = iif(isnull(LockType), 'No', 'Yes')\r\n    | summarize by ProcessId, LockType, ConnectionId, LockAcquired, Statement, Context\r\n) on ProcessId, ConnectionId,Statement, Context\r\n| extend LockAcquired = iif(isempty(LockAcquired), 'No', 'Yes')\r\n| extend Duration = iff(LockAcquired=='No',\"\",tostring(Duration))\r\n| project ['from'] = min_timestamp, ['to'] = max_timestamp, ['connection identifier'] = ConnectionId, ['process identifier'] = ProcessId, ['lock type'] = LockType, ['acquired'] = LockAcquired, ['command type'] = Command, ['blocking process identifier'] = max_BlockingProcessId, ['duration'] = todecimal(Duration), ['statement'] = Statement\r\n| sort by ['duration'] desc",
        "size": 0,
        "aggregation": 2,
        "noDataMessage": "No data available during the period selected",
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "table",
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "acquired",
              "formatter": 18,
              "formatOptions": {
                "thresholdsOptions": "colors",
                "thresholdsGrid": [
                  {
                    "operator": "==",
                    "thresholdValue": "No",
                    "representation": "blue",
                    "text": "{0}{1}"
                  },
                  {
                    "operator": "Default",
                    "thresholdValue": null,
                    "text": "{0}{1}"
                  }
                ]
              }
            },
            {
              "columnMatch": "duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "Duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "statement",
              "formatter": 1,
              "formatOptions": {
                "linkTarget": "CellDetails",
                "linkIsContextBlade": true
              }
            }
          ],
          "rowLimit": 10000,
          "filter": true,
          "sortBy": [
            {
              "itemKey": "$gen_number_duration_8",
              "sortOrder": 2
            }
          ]
        },
        "sortBy": [
          {
            "itemKey": "$gen_number_duration_8",
            "sortOrder": 2
          }
        ],
        "chartSettings": {
          "showLegend": true,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 23,
              "options": {
                "style": "decimal",
                "useGrouping": true
              }
            }
          }
        }
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "AcquiredLocksDurationGridView",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 1,
      "content": {
        "json": "## Blocking information\r\nThe grid below displays the current blocking sessions present in the system. It checks the logs during the specified time window and indicates if there is any process ID waiting to acquire a lock in the system.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "Blocking sesions info"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet maxCollectionTime = toscalar( \r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| summarize max(CollectionTime)\r\n);\r\n\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where  Message contains \"still waiting for\"\r\n| distinct TimeGenerated,Message, DetailLog, Statement, Context\r\n| extend ProcessId = toint(extract(\"process (\\\\d+)\", 1, Message))\r\n| extend LockType = extract(\"waiting for (.*)Lock\", 1, Message)\r\n| extend LogTime = todatetime(TimeGenerated)\r\n| extend ConnectionId = extract(\"UTC-(.*?)\\\\-\", 1, Message)\r\n| extend WaitingDuration = totimespan(End_Time - LogTime)/totimespan(1ms)\r\n| extend BlockingProcessId = extract(\"Process holding the lock: (\\\\d+)\", 1, DetailLog)\r\n| extend Command = toupper(tostring(split(Statement, \" \")[0]))\r\n| summarize by ProcessId, LockType, LogTime, WaitingDuration, BlockingProcessId,Statement,ConnectionId, Command, Context\r\n| join kind=anti (\r\n    {PGServerLogsTable}\r\n    | where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n    | where Message contains \"acquired\"\r\n    | distinct TimeGenerated,Message, Statement\r\n    | extend ProcessId = toint(extract(\"process (\\\\d+)\", 1, Message))\r\n    | extend ConnectionId = extract(\"UTC-(.*?)\\\\-\", 1, Message)\r\n    | extend LockType = extract(\"acquired (.*)Lock\", 1, Message)\r\n    | summarize by ProcessId, LockType,ConnectionId\r\n) on ProcessId, LockType, ConnectionId\r\n|join kind=anti (\r\n{PGServerLogsTable}\r\n    | where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n    | where SqlErrorCode != '00000'\r\n    | extend ConnectionId = extract(\"UTC-(.*?)\\\\-\", 1, Message)\r\n    | summarize by ProcessId, SqlErrorCode, ConnectionId\r\n    ) on ProcessId, ConnectionId\r\n|join kind=innerunique (\r\n{SessionsTable}\r\n    | where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n    | where CollectionTime == maxCollectionTime\r\n    | where isnotempty(DatabaseName)\r\n    | project ProcessId\r\n    ) on ProcessId\r\n| project ProcessId, LockType, WaitingDuration, BlockingProcessId, ConnectionId, Command, Statement\r\n| summarize WaitingDuration=max(WaitingDuration) by ProcessId, LockType, BlockingProcessId, ConnectionId, Command, Statement\r\n| project ['duration'] = WaitingDuration, ['process identifier'] = ProcessId, ['lock type'] = LockType, ['blocking process identifier'] = BlockingProcessId, ['connection identifier'] = ConnectionId, ['command type'] = Command, ['statement'] = Statement",
        "size": 1,
        "title": "Blocking information",
        "noDataMessage": "No data available during the period selected",
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "duration",
              "formatter": 0,
              "numberFormat": {
                "unit": 23,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ]
        },
        "sortBy": []
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "locks"
      },
      "name": "Blocking PIDs Grid View",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 9,
            "content": {
              "version": "KqlParameterItem/1.0",
              "crossComponentResources": [
                "{Resource}"
              ],
              "parameters": [
                {
                  "id": "3eb7f151-c647-4caa-be40-dd1ca0a95ecd",
                  "version": "KqlParameterItem/1.0",
                  "name": "ConectionSurgeInsight",
                  "type": 1,
                  "query": "// ===============================\r\n// Parameters\r\n// ===============================\r\nlet binSize=iff({TimeRange:grain}<5m,1m, 1m);\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet curStart = Start_Time;\r\nlet curEnd   = End_Time;\r\nlet endTime   = End_Time;\r\nlet userWindow = End_Time-Start_Time;\r\nlet prevStart = curStart - userWindow;\r\nlet prevEnd   = curStart;\r\nlet sensitivity = 3;     // anomaly detection sensitivity (lower => more sensitive)\r\nlet surgeWindow = 10m;    //  window around surge for contributors\r\nlet maxList = 5;        // top-N contributors shown\r\n\r\n// Optional filters\r\nlet excludeDbs = dynamic(['template1','template0','azure_maintenance','azure_sys']);\r\nlet excludeUserId = 10;\r\n\r\n// ===============================\r\n// Time anchors (single 'now()' for reproducibility)\r\n// ===============================\r\n\r\n\r\n// ===============================\r\n// Helpers\r\n// ===============================\r\nlet Fmt = (dt:datetime) { format_datetime(dt, 'yyyy-MM-dd HH:mm') };\r\nlet SafeDiv = (num:real, den:real) { iif(den == 0.0, real(null), num / den) };\r\nlet DeltaPct = (cur:real, prev:real) { round(100.0 * SafeDiv(cur - prev, prev), 2) };\r\nlet SessionsTable = {SessionTableInsight};\r\n\r\n// ===============================\r\n// Current Window\r\n// ===============================\r\nlet Cur_SessionData =\r\n    SessionsTable\r\n    | where TimeGenerated between (curStart .. curEnd)\r\n    | where UserId != excludeUserId\r\n    | where isnotempty(ClientIpAddress)\r\n    | where isnotempty(DatabaseId) and DatabaseName !in (excludeDbs);\r\n\r\nlet Cur_FirstSeenPerPid =\r\n    Cur_SessionData\r\n    | summarize FirstSeen = min(TimeGenerated),\r\n                anyDb = any(DatabaseName),\r\n                anyApp = any(ApplicationName),\r\n                anyClient = any(ClientIpAddress)\r\n      by ProcessId;\r\n\r\nlet Cur_ActiveSeries =\r\n    Cur_SessionData\r\n    | summarize Active = dcount(ProcessId) by ts = bin(TimeGenerated, binSize)\r\n    | make-series Active = max(Active) default=0 on ts from curStart to curEnd step binSize;\r\n\r\nlet Cur_PeakActive =\r\n    toscalar(\r\n        Cur_ActiveSeries\r\n        | mv-expand Active to typeof(long)\r\n        | summarize Peak = max(Active)\r\n        | project toint(Peak)\r\n    );\r\nlet Cur_AvgActive =\r\n    toscalar(\r\n        Cur_ActiveSeries\r\n        | mv-expand Active to typeof(long)\r\n        | summarize Avg = avg(todouble(Active))\r\n        | project round(Avg, 2)\r\n    );\r\n\r\nlet Cur_Anoms =\r\n    Cur_ActiveSeries\r\n    | extend (anoms, score, baseline) = series_decompose_anomalies(Active, sensitivity, -1, 'linefit')\r\n    | mv-expand ts to typeof(datetime), Active to typeof(long), anoms to typeof(long), score to typeof(double), baseline to typeof(double)\r\n    | where anoms > 0\r\n    | project SurgeTime = ts, Active, Baseline = baseline, AnomalyScore = round(score, 2)\r\n    | order by SurgeTime desc;\r\n\r\nlet Cur_hasSurge = toscalar(Cur_Anoms | count) > 0;\r\nlet Cur_LatestSurge = Cur_Anoms | top 1 by SurgeTime desc;\r\nlet Cur_SurgeTime   = toscalar(Cur_LatestSurge | project SurgeTime);\r\nlet Cur_Surge_Active   = iif(Cur_hasSurge, toint(toscalar(Cur_LatestSurge | project Active)), int(null));\r\nlet Cur_Surge_Baseline = iif(Cur_hasSurge, toint(toscalar(Cur_LatestSurge | project Baseline)), int(null));\r\nlet Cur_Surge_Score    = iif(Cur_hasSurge, toreal(toscalar(Cur_LatestSurge | project AnomalyScore)), real(null));\r\n\r\nlet Cur_Contrib_Active =\r\n    Cur_SessionData\r\n    | where Cur_hasSurge\r\n    | where TimeGenerated between (Cur_SurgeTime - surgeWindow .. Cur_SurgeTime + surgeWindow)\r\n    | summarize ActiveAtSurge = dcount(ProcessId)\r\n        by DatabaseName, ApplicationName, ClientIpAddress;\r\n\r\nlet Cur_Contrib_New =\r\n    Cur_FirstSeenPerPid\r\n    | where Cur_hasSurge\r\n    | where FirstSeen between (Cur_SurgeTime - surgeWindow .. Cur_SurgeTime + surgeWindow)\r\n    | summarize NewConnections = count()\r\n        by DatabaseName = tostring(anyDb),\r\n           ApplicationName = tostring(anyApp),\r\n           ClientIpAddress = tostring(anyClient);\r\n\r\n// IMPORTANT: keep original column names for join\r\nlet Cur_Contributors =\r\n    Cur_Contrib_Active\r\n    | join kind=leftouter Cur_Contrib_New on DatabaseName, ApplicationName, ClientIpAddress\r\n    | extend NewConnections = coalesce(NewConnections, 0)\r\n    | order by ActiveAtSurge desc, NewConnections desc\r\n    | take toint(maxList)\r\n    | project DatabaseName, ApplicationName, ClientIpAddress, ActiveAtSurge, NewConnections;\r\n\r\n// ===============================\r\n// Previous Window\r\n// ===============================\r\nlet Prev_SessionData =\r\n    SessionsTable\r\n    | where TimeGenerated between (prevStart .. prevEnd)\r\n    | where UserId != excludeUserId\r\n    | where isnotempty(DatabaseId) and DatabaseName !in (excludeDbs);\r\n\r\nlet Prev_FirstSeenPerPid =\r\n    Prev_SessionData\r\n    | summarize FirstSeen = min(TimeGenerated),\r\n                anyDb = any(DatabaseName),\r\n                anyApp = any(ApplicationName),\r\n                anyClient = any(ClientIpAddress)\r\n      by ProcessId;\r\n\r\nlet Prev_ActiveSeries =\r\n    Prev_SessionData\r\n    | summarize Active = dcount(ProcessId) by ts = bin(TimeGenerated, binSize)\r\n    | make-series Active = max(Active) default=0 on ts from prevStart to prevEnd step binSize;\r\n\r\nlet Prev_PeakActive =\r\n    toscalar(\r\n        Prev_ActiveSeries\r\n        | mv-expand Active to typeof(long)\r\n        | summarize Peak = max(Active)\r\n        | project toint(Peak)\r\n    );\r\nlet Prev_AvgActive =\r\n    toscalar(\r\n        Prev_ActiveSeries\r\n        | mv-expand Active to typeof(long)\r\n        | summarize Avg = avg(todouble(Active))\r\n        | project round(Avg, 2)\r\n    );\r\n\r\nlet Prev_Anoms =\r\n    Prev_ActiveSeries\r\n    | extend (anoms, score, baseline) = series_decompose_anomalies(Active, sensitivity, -1, 'linefit')\r\n    | mv-expand ts to typeof(datetime), Active to typeof(long), anoms to typeof(long), score to typeof(double), baseline to typeof(double)\r\n    | where anoms > 0\r\n    | project SurgeTime = ts, Active, Baseline = baseline, AnomalyScore = round(score, 2)\r\n    | order by SurgeTime desc;\r\n\r\nlet Prev_hasSurge = toscalar(Prev_Anoms | count) > 0;\r\nlet Prev_LatestSurge = Prev_Anoms | top 1 by SurgeTime desc;\r\nlet Prev_SurgeTime   = toscalar(Prev_LatestSurge | project SurgeTime);\r\nlet Prev_Surge_Active   = iif(Prev_hasSurge, toint(toscalar(Prev_LatestSurge | project Active)), int(null));\r\nlet Prev_Surge_Baseline = iif(Prev_hasSurge, toint(toscalar(Prev_LatestSurge | project Baseline)), int(null));\r\nlet Prev_Surge_Score    = iif(Prev_hasSurge, toreal(toscalar(Prev_LatestSurge | project AnomalyScore)), real(null));\r\n\r\nlet Prev_Contrib_Active =\r\n    Prev_SessionData\r\n    | where Prev_hasSurge\r\n    | where TimeGenerated between (Prev_SurgeTime - surgeWindow .. Prev_SurgeTime + surgeWindow)\r\n    | summarize ActiveAtSurge = dcount(ProcessId)\r\n        by DatabaseName, ApplicationName, ClientIpAddress;\r\n\r\nlet Prev_Contrib_New =\r\n    Prev_FirstSeenPerPid\r\n    | where Prev_hasSurge\r\n    | where FirstSeen between (Prev_SurgeTime - surgeWindow .. Prev_SurgeTime + surgeWindow)\r\n    | summarize NewConnections = count()\r\n        by DatabaseName = tostring(anyDb),\r\n           ApplicationName = tostring(anyApp),\r\n           ClientIpAddress = tostring(anyClient);\r\n\r\n// Keep original names for join consistency\r\nlet Prev_Contributors =\r\n    Prev_Contrib_Active\r\n    | join kind=leftouter Prev_Contrib_New on DatabaseName, ApplicationName, ClientIpAddress\r\n    | extend NewConnections = coalesce(NewConnections, 0)\r\n    | project DatabaseName, ApplicationName, ClientIpAddress, ActiveAtSurge, NewConnections;\r\n\r\n// ===============================\r\n// Deltas\r\n// ===============================\r\nlet Peak_Delta   = Cur_PeakActive - Prev_PeakActive;\r\nlet Peak_DeltaPc = DeltaPct(toreal(Cur_PeakActive), toreal(Prev_PeakActive));\r\n\r\nlet Avg_Delta    = Cur_AvgActive - Prev_AvgActive;\r\nlet Avg_DeltaPc  = DeltaPct(toreal(Cur_AvgActive), toreal(Prev_AvgActive));\r\n\r\n// Fullouter join requires consistent column names on both sides\r\nlet Contrib_Delta =\r\n    Cur_Contributors\r\n    | join kind=fullouter Prev_Contributors on DatabaseName, ApplicationName, ClientIpAddress\r\n    | extend CurActive  = toint(coalesce(ActiveAtSurge, 0)),\r\n             CurNew     = toint(coalesce(NewConnections, 0)),\r\n             PrevActive = toint(coalesce(ActiveAtSurge1, 0)),\r\n             PrevNew    = toint(coalesce(NewConnections1, 0))\r\n    | extend dActive = CurActive - PrevActive,\r\n             dNew    = CurNew - PrevNew\r\n    | project DatabaseName = coalesce(DatabaseName, DatabaseName1),\r\n              ApplicationName = coalesce(ApplicationName, ApplicationName1),\r\n              ClientIpAddress = coalesce(ClientIpAddress, ClientIpAddress1),\r\n              CurActive, CurNew, PrevActive, PrevNew, dActive, dNew\r\n    | order by dActive desc, dNew desc\r\n    | take toint(maxList);\r\n\r\n// ===============================\r\n// Markdown Tables Builder\r\n// ===============================\r\n\r\n// -- Windows overview (plain text, not a table)\r\nlet md_windows = strcat(\r\n  \"Current Window(UTC): \", Fmt(curStart), \"  \", Fmt(curEnd), \" (bin \", tostring(binSize), \")\\n\\n\",\r\n  \"Previous Window(UTC): \", Fmt(prevStart), \"  \", Fmt(prevEnd), \"\\n\\n\"\r\n);\r\n\r\n// -- Summary Metrics table (2 rows)\r\nlet sm_cur_peak = iif(isnull(Cur_PeakActive), \"N/A\", tostring(Cur_PeakActive));\r\nlet sm_prev_peak = iif(isnull(Prev_PeakActive), \"N/A\", tostring(Prev_PeakActive));\r\nlet sm_delta_peak = iif(isnull(Prev_PeakActive), \"N/A\", tostring(Peak_Delta));\r\nlet sm_deltaPc_peak = iif(isnull(Prev_PeakActive), \"N/A\", strcat(tostring(Peak_DeltaPc), \"%\"));\r\n\r\nlet sm_cur_avg = iif(isnull(Cur_AvgActive), \"N/A\", tostring(Cur_AvgActive));\r\nlet sm_prev_avg = iif(isnull(Prev_AvgActive), \"N/A\", tostring(Prev_AvgActive));\r\nlet sm_delta_avg = iif(isnull(Prev_AvgActive), \"N/A\", tostring(Avg_Delta));\r\nlet sm_deltaPc_avg = iif(isnull(Prev_AvgActive), \"N/A\", strcat(tostring(Avg_DeltaPc), \"%\"));\r\n\r\nlet md_summary_table = strcat(\r\n  \"### Summary Metrics\\n\",\r\n  \"| Metric | Current | Previous |  | % | Summary |\\n\",\r\n  \"|---|---:|---:|---:|---:|---|\\n\",\r\n  strcat(\"| Peak Active | \", sm_cur_peak, \" | \", sm_prev_peak, \" | \", sm_delta_peak, \" | \", sm_deltaPc_peak, \" | Maximum active connections observed |\\n\"),\r\n  \"\\n\"\r\n);\r\n\r\n// -- Current Window  Latest Surge (single row table)\r\nlet surge_time_s = iif(Cur_hasSurge, Fmt(Cur_SurgeTime), \"N/A\");\r\nlet surge_active_s = iif(Cur_hasSurge, tostring(Cur_Surge_Active), \"N/A\");\r\nlet surge_base_s   = iif(Cur_hasSurge, tostring(Cur_Surge_Baseline), \"N/A\");\r\nlet surge_score_s  = iif(Cur_hasSurge, tostring(Cur_Surge_Score), \"N/A\");\r\nlet surge_summary  = iif(Cur_hasSurge,\r\n                         strcat(\"Spike of \", tostring(Cur_Surge_Active), \" vs baseline \", tostring(Cur_Surge_Baseline)),\r\n                         \"No surge detected\");\r\n\r\nlet md_surge_table = strcat(\r\n  \"### Current Window  Latest Surge\\n\",\r\n  \"| Time | Active | Baseline | Score | Summary |\\n\",\r\n  \"|---|---:|---:|---:|---|\\n\",\r\n  \"| \", surge_time_s, \" | \", surge_active_s, \" | \", surge_base_s, \" | \", surge_score_s, \" | \", surge_summary, \" |\\n\\n\"\r\n);\r\n\r\n// -- Top Contributors near surge (table or fallback)\r\n// rename only for display here\r\nlet md_contrib_table =\r\n  strcat(\r\n    \"### Top Contributors near surge (\", tostring(surgeWindow), \")\\n\",\r\n    iif(Cur_hasSurge and toscalar(Cur_Contributors | count) > 0,\r\n        strcat(\r\n          \"| Application | Database | Client | Active@Surge | New | Summary |\\n\",\r\n          \"|---|---|---|---:|---:|---|\\n\",\r\n          toscalar(\r\n            Cur_Contributors\r\n            | extend Application = iif(isempty(ApplicationName), \"(unknown app)\", ApplicationName),\r\n                     Database    = iif(isempty(DatabaseName), \"(unknown db)\", DatabaseName),\r\n                     Client      = iif(isempty(ClientIpAddress), \"(client ?)\", ClientIpAddress),\r\n                     Summary     = strcat(tostring(ActiveAtSurge), \" active; \", tostring(NewConnections), \" new\")\r\n            | extend line = strcat(\"| \", Application, \" | \", Database, \" | \", Client, \" | \",\r\n                                   tostring(ActiveAtSurge), \" | \", tostring(NewConnections), \" | \", Summary, \" |\\n\")\r\n            | summarize strcat_array(make_list(line), \"\")\r\n          )\r\n        ),\r\n        \"_No contributors in current window._\\n\"\r\n    ),\r\n    \"\\n\"\r\n  );\r\n\r\n// -- Contributor changes (table or fallback)\r\n// rename only for display here\r\nlet md_contrib_delta_table = strcat(\r\n  \"### Contributor changes (current vs previous near their respective surges)\\n\",\r\n  iif(toscalar(Contrib_Delta | count) > 0,\r\n     strcat(\r\n       \"| Application | Database | Client | Cur Active | Cur New | Prev Active | Prev New |  Active |  New | Summary |\\n\",\r\n       \"|---|---|---|---:|---:|---:|---:|---:|---:|---|\\n\",\r\n       toscalar(\r\n         Contrib_Delta\r\n         | extend Application = iif(isempty(ApplicationName), \"(unknown app)\", ApplicationName),\r\n                  Database    = iif(isempty(DatabaseName), \"(unknown db)\", DatabaseName),\r\n                  Client      = iif(isempty(ClientIpAddress), \"(client ?)\", ClientIpAddress),\r\n                  dActiveS    = strcat(iif(dActive >= 0, \"+\", \"\"), tostring(dActive)),\r\n                  dNewS       = strcat(iif(dNew >= 0, \"+\", \"\"), tostring(dNew))\r\n        | extend Summary     = strcat(\"Active  \", dActiveS, \" (\", tostring(PrevActive), \"\", tostring(CurActive),\r\n                                       \"); New  \", dNewS, \" (\", tostring(PrevNew), \"\", tostring(CurNew), \")\")\r\n         | extend line = strcat(\"| \", Application, \" | \", Database, \" | \", Client, \" | \",\r\n                                tostring(CurActive), \" | \", tostring(CurNew), \" | \",\r\n                                tostring(PrevActive), \" | \", tostring(PrevNew), \" | \",\r\n                                dActiveS, \" | \", dNewS, \" | \", Summary, \" |\\n\")\r\n         | summarize strcat_array(make_list(line), \"\")\r\n       )\r\n     ),\r\n     \"_No comparable contributors (no surges or no overlap)._\"\r\n  ),\r\n  \"\\n\"\r\n);\r\n\r\nprint MD = iif(Cur_hasSurge,\r\n    strcat(\r\n        \"## Connection surge\\n\\n\",\r\n        md_windows,\r\n        md_summary_table,\r\n        md_surge_table,\r\n        md_contrib_table,\r\n        md_contrib_delta_table\r\n    ),\r\n    \"\"\r\n)\r\n| where MD != \"\"\r\n",
                  "crossComponentResources": [
                    "{Resource}"
                  ],
                  "isHiddenWhenLocked": true,
                  "queryType": 0,
                  "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                },
                {
                  "id": "b4dfee1a-69d5-4e2f-9aa1-e8292eed9c67",
                  "version": "KqlParameterItem/1.0",
                  "name": "WaitEventInsight",
                  "type": 1,
                  "query": "// ---------- TUNABLES ----------\r\nlet topN = 5;                          // How many waits to show\r\nlet sampleInterval = 5m;               // Your sampling cadence\r\nlet minAbsDelta = 1;                   // Ignore tiny changes (absolute )\r\nlet requireNonIdle = false;            // Set true to drop State == \"idle\"\r\nlet includeTypes = dynamic([]);        // e.g., [\"Lock\",\"IO\"]; empty => no filter\r\nlet excludeTypes = dynamic([\"Activity\"]);        // e.g., [\"Client\"]\r\nlet excludeEvents = dynamic([]);       // e.g., [\"ClientRead\",\"ClientWrite\"]\r\n\r\n// Impact modes: \"samples\" (), \"minutes\" (  cadence in minutes), \"per_minute\" (  window minutes), \"custom\" (  scale)\r\nlet impactMode  = \"minutes\";\r\nlet impactScale = 1.0;\r\n\r\n// ---------- TIME WINDOWS ----------\r\nlet endTime   = todatetime('{GlobalEndTime}');\r\nlet startTime = todatetime('{GlobalStartTime}');\r\nlet duration  = endTime - startTime;\r\nlet prevStart = startTime - duration;\r\nlet prevEnd   = startTime;\r\nlet durMins   = toreal(max_of(1.0, duration / 1m));    // safety\r\n\r\n// ---------- SOURCE ----------\r\nlet SessionsTable = {SessionTableInsight};\r\n\r\n// ---------- CLEAN & NORMALIZE ----------\r\nlet Clean =\r\n    SessionsTable\r\n    | extend SampleTime = coalesce(todatetime(CollectionTime), todatetime(TimeGenerated))\r\n    | where isnotempty(WaitEvent) or isnotempty(WaitEventType)\r\n    | where (array_length(includeTypes) == 0 or tostring(WaitEventType) in (includeTypes))\r\n          and (tostring(WaitEventType) !in (excludeTypes))\r\n          and (tostring(WaitEvent) !in (excludeEvents))\r\n          and (requireNonIdle == false or tostring(State) !in (\"idle\"))\r\n    | extend KeyType  = trim(' ', tostring(WaitEventType)),\r\n             KeyEvent = trim(' ', tostring(WaitEvent))\r\n    | extend KeyEvent = iff(isempty(KeyEvent), \"\", KeyEvent)\r\n;\r\n\r\n// ---------- CURRENT vs PREVIOUS COUNTS ----------\r\nlet Curr =\r\n    Clean\r\n    | where SampleTime between (startTime .. endTime)\r\n    | summarize cur = count() by KeyType, KeyEvent;\r\n\r\nlet Prev =\r\n    Clean\r\n    | where SampleTime between (prevStart .. prevEnd)\r\n    | summarize prev = count() by KeyType, KeyEvent;\r\n\r\n// ---------- DELTAS & IMPACT ----------\r\nlet Deltas =\r\n    Curr\r\n    | join kind=fullouter Prev on KeyType, KeyEvent\r\n    | extend cur  = tolong(coalesce(cur, 0)),\r\n             prev = tolong(coalesce(prev, 0))\r\n    | extend delta = cur - prev\r\n    | where delta > 0 and delta >= minAbsDelta\r\n    | extend delta_pct = 100.0 * iff(prev == 0, todouble(cur), todouble(delta)) / iff(prev == 0, 1.0, todouble(prev))\r\n    | extend impact =\r\n        case(\r\n            impactMode == \"minutes\",    todouble(delta) * todouble(sampleInterval / 1m),\r\n            impactMode == \"per_minute\", todouble(delta) / durMins,\r\n            impactMode == \"custom\",     todouble(delta) * impactScale,\r\n            todouble(delta)\r\n        )\r\n    | extend Wait = strcat(KeyType, \":\", iff(isempty(KeyEvent), KeyType, KeyEvent))\r\n    // Color-coded quick interpretation\r\n    | extend Summary =\r\n        case(\r\n            prev == 0 and cur > 0, \" New in window\",\r\n            delta_pct > 1000,       \" Massive increase\",\r\n            delta_pct > 500,        \" Significant increase\",\r\n            delta_pct > 100,        \" Moderate increase\",\r\n            \" Slight increase\"\r\n        )\r\n    | extend Commentary = strcat(\r\n        Summary, \"  Event '\", Wait, \"' (Prev=\", tostring(prev),\r\n        \", Curr=\", tostring(cur), \", =\", tostring(delta),\r\n        \", Impact=\", tostring(round(impact, 1)), \").\"\r\n    )\r\n    | project Wait, prev, cur, delta, delta_pct = round(delta_pct, 1), impact = round(impact, 1), Summary, Commentary\r\n    | order by impact desc, delta desc\r\n;\r\n\r\n// ---------- TOP N ----------\r\nlet TopDeltas =\r\n    Deltas\r\n    | serialize rn = row_number()\r\n    | where rn <= topN\r\n    | project Wait, prev, cur, delta, delta_pct, impact, Summary, Commentary\r\n;\r\n\r\n\r\n// ---------- Do we have anything to show? ----------\r\nlet HasWaits = toscalar(TopDeltas | summarize has = count() > 0);\r\n\r\n// Result set #1: tabular grid\r\n\r\nlet MarkdownContent = toscalar(\r\nTopDeltas\r\n// ---------- Markdown Output ----------\r\n| project _md_row = strcat(\"| \", Wait, \" | \", tostring(prev), \" | \", tostring(cur), \" | \", tostring(delta), \" | \", tostring(delta_pct), \"% | \", tostring(impact), \" | \", Summary, \" |\")\r\n| summarize Lines = make_list(_md_row, 4096)\r\n| extend mdTitle = \"## Top impactful wait events (vs. previous window)\\n\"\r\n| extend mdLegend = \"**Severity legend**\\n\\n-  Massive increase: % > 1000\\n-  Significant increase: % > 500\\n-  Moderate increase: % > 100\\n-  Slight increase: otherwise\\n-  New in window: previous count = 0\\n\\n\"\r\n| extend mdSub   = strcat(\r\n    \"Current window (UTC): \", format_datetime(startTime, \"yyyy-MM-dd HH:mm\"), \"  \", format_datetime(endTime, \"yyyy-MM-dd HH:mm\"),\r\n    \"    Previous window (UTC): \", format_datetime(prevStart, \"yyyy-MM-dd HH:mm\"), \"  \", format_datetime(prevEnd, \"yyyy-MM-dd HH:mm\"), \"\\n\\n\"\r\n)\r\n| extend mdHeader = \"| Wait | Prev | Cur |  | % | Impact | Summary |\\n|:--|--:|--:|--:|--:|--:|:--|\\n\"\r\n| extend mdBody   = strcat_array(Lines, \"\\n\")\r\n| extend mdColSummary = \"\\n\\n**Column summary**\\n\\n| Column | Meaning |\\n|:--|:--|\\n| Wait | Combined `WaitEventType` and `WaitEvent` |\\n| Prev | Count of events in the previous window |\\n| Cur | Count of events in the current window |\\n|  | Difference (`Cur - Prev`) |\\n| % | Percentage change from previous to current |\\n| Impact | Weighted impact based on `impactMode` (e.g., minutes =   cadence) |\\n| Summary | Color-coded interpretation of change |\\n\"\r\n| extend mdNote = strcat(\"\\n> Impact mode: **\", impactMode, \"**. Cadence: **\", tostring(sampleInterval / 1m), \" min**.\\n\")\r\n| extend mdIntroStatic = \"**What this insight shows:**\\nThis report compares database wait events between the current and previous time windows. It highlights which waits increased the most, their percentage change, and an estimated impact in minutes (based on sampling cadence). Use this to quickly spot performance bottlenecks and prioritize tuning efforts.\\n\\n\"\r\n| project Markdown = strcat(mdTitle,mdIntroStatic, mdSub,mdLegend,mdHeader, mdBody, mdColSummary, mdNote));\r\n\r\nprint Markdown = iif(HasWaits, MarkdownContent, \"\")",
                  "crossComponentResources": [
                    "{Resource}"
                  ],
                  "isHiddenWhenLocked": true,
                  "queryType": 0,
                  "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                }
              ],
              "style": "pills",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers"
            },
            "name": "CpuInsightsParameters"
          },
          {
            "type": 1,
            "content": {
              "json": "#### No insights are available for the selected time period.",
              "style": "success"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "ConectionSurgeInsight",
                "comparison": "isEqualTo"
              },
              {
                "parameterName": "WaitEventInsight",
                "comparison": "isEqualTo"
              }
            ],
            "name": "NoInsightMessage"
          },
          {
            "type": 1,
            "content": {
              "json": "{WaitEventInsight}",
              "style": "warning"
            },
            "conditionalVisibility": {
              "parameterName": "WaitEventInsight",
              "comparison": "isNotEqualTo"
            },
            "name": "ConectionSurgeInsightWarning - Copy"
          },
          {
            "type": 1,
            "content": {
              "json": "{ConectionSurgeInsight}",
              "style": "warning"
            },
            "conditionalVisibility": {
              "parameterName": "ConectionSurgeInsight",
              "comparison": "isNotEqualTo"
            },
            "name": "ConectionSurgeInsightWarning"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "cputab",
        "comparison": "isEqualTo",
        "value": "insight"
      },
      "name": "InsightsGroup"
    }
  ],
  "fallbackResourceIds": [],
  "$schema": "https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json"
}