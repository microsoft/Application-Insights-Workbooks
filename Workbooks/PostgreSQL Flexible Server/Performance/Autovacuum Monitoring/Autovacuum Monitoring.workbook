{
  "version": "Notebook/1.0",
  "items": [
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "## Autovacuum monitoring\r\n\r\nThis troubleshooting guide is designed to assess the health of autovacuum or vacuum on Azure Database for PostgreSQL Flexible Server. During the execution of autovacuum, it removes dead tuples, which can free up disk space and improve query performance. Additionally, it updates the visibility map to keep track of pages that do not contain any outdated or deleted data, helping to reduce unnecessary I/O operations. \r\n\r\nAnother critical function of autovacuum is to prevent transaction ID wraparound situations, which could result in data loss. \r\n\r\nBy analyzing the results of this troubleshooting guide, you can take proactive steps to optimize autovacuum and maintain the long-term health of your database.",
              "style": "info"
            },
            "name": "introduction to the workbook"
          },
          {
            "type": 1,
            "content": {
              "json": "Step | Description\r\n--- | ---\r\n**Analysis period** | Choose the time interval that you wish to analyze.\r\n**Database** | Choose the database that you wish to analyze. You can select **All** to view the metrics for all databases available on server or you can select a particular database if you want to narrow the analysis to that single database.\r\n**Bloat** | Understand what is the database bloat ratio.\r\n**Tuples** | Identify count of live vs dead tuples, and the number of inserted, updated, and deleted tuples.\r\n**Vacuum and analyze** | Identify count of tables vacuumed and tables analyzed on each database.\r\n**Autovacuum workers** | Monitor autovacuum workers execution count.\r\n**Autovacuum per table** | Monitor execution history of autovacuum on each table.\r\n**Enhanced metrics** | Monitor the highest count of transaction identifiers in use by active transactions, and the value of the oldest Xmin.\r\n\r\n"
            },
            "name": "table of contents"
          }
        ],
        "exportParameters": true
      },
      "name": "workbook top"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Start by setting the following parameters:"
      },
      "name": "parameters for the workbook"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "09ae6e10-24ff-4eb0-964c-78c3bebf6b0b",
            "version": "KqlParameterItem/1.0",
            "name": "MIN_TIME_WINDOW_SEC",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "3600"
                }
              }
            ]
          },
          {
            "id": "9ebd8e9a-5e9c-496a-bdb1-e41b9faaf9ad",
            "version": "KqlParameterItem/1.0",
            "name": "TimeRange",
            "type": 4,
            "isRequired": true,
            "isGlobal": true,
            "value": {
              "durationMs": 86400000
            },
            "typeSettings": {
              "selectableValues": [
                {
                  "durationMs": 3600000
                },
                {
                  "durationMs": 14400000
                },
                {
                  "durationMs": 43200000
                },
                {
                  "durationMs": 86400000
                },
                {
                  "durationMs": 172800000
                },
                {
                  "durationMs": 259200000
                },
                {
                  "durationMs": 604800000
                },
                {
                  "durationMs": 1209600000
                },
                {
                  "durationMs": 2419200000
                }
              ],
              "allowCustom": true
            },
            "timeContext": {
              "durationMs": 86400000
            },
            "label": "Analysis period (local time)"
          },
          {
            "id": "af775476-7170-4279-a661-d41ee3581495",
            "version": "KqlParameterItem/1.0",
            "name": "Resource",
            "type": 5,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false,
              "componentIdOnly": true
            }
          },
          {
            "id": "b57a9e87-cce3-4416-8456-965aece843ca",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalEndTime",
            "type": 1,
            "isGlobal": true,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\n\r\nlet dt = {TimeRange:end};\r\nprint iff(dt<now(), dt, now())\r\n\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "331f2446-d717-413a-b8f6-27d2996ec4fc",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalStartTime",
            "type": 1,
            "isGlobal": true,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\nprint iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime('{GlobalEndTime}')-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start})",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "baf42514-5816-4480-863c-e3bbc27d4cc3",
            "version": "KqlParameterItem/1.0",
            "name": "WRAPAROUND_LOOK_BACK_DAYS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "4d"
                }
              }
            ]
          },
          {
            "id": "93dbd56c-6477-461b-95cc-96b40686d791",
            "version": "KqlParameterItem/1.0",
            "name": "EMERGENCY_AV_THRES",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "200"
                }
              }
            ]
          },
          {
            "id": "f3814683-6847-4337-aedb-6c0c165bf0fd",
            "version": "KqlParameterItem/1.0",
            "name": "WRAPAROUND_THRES",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "45"
                }
              }
            ]
          },
          {
            "id": "39a79938-e8f9-486f-b3ec-f26258dcf87e",
            "version": "KqlParameterItem/1.0",
            "name": "AV_LOOK_BACK_DAYS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7d"
                }
              }
            ]
          },
          {
            "id": "4de34e71-1a41-4aac-8c41-5365578f3ea5",
            "version": "KqlParameterItem/1.0",
            "name": "LongRunningTransaction",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7200"
                }
              }
            ]
          },
          {
            "id": "7e695ecf-8ee9-4a2a-9d2e-9f8487a9e7e6",
            "version": "KqlParameterItem/1.0",
            "name": "Replication_Threshold",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "10737418240"
                }
              }
            ]
          },
          {
            "id": "eea7ca7c-4a7c-43cf-b11b-2aa1f3a90386",
            "version": "KqlParameterItem/1.0",
            "name": "MAX_XACTS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "2147483647"
                }
              }
            ]
          },
          {
            "id": "679af9cd-5d73-4f5b-b0e2-643e50383876",
            "version": "KqlParameterItem/1.0",
            "name": "AV_BLOAT_THRESHOLD",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "50"
                }
              }
            ]
          },
          {
            "id": "8997b9e7-7516-4acb-b707-cc4269fea130",
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLFlexTableStats",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category =='PostgreSQLFlexTableStats' | project TimeGenerated, Resource, DatabaseName = tostring(     iff(isnotempty(AdditionalFields.DatabaseName), AdditionalFields.DatabaseName,         column_ifexists('DatabaseName_s',            column_ifexists('DatabaseName', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.Schemaname), AdditionalFields.Schemaname,         column_ifexists('Schemaname_s',            column_ifexists('Schemaname', \"\")         )     ) ), LiveRowsCount = tolong(     iff(isnotempty(AdditionalFields.N_live_tup), AdditionalFields.N_live_tup,         column_ifexists('N_live_tup_d',             column_ifexists('N_live_tup',                 column_ifexists('N_live_tup_s', \"\")             )         )     ) ), DeadRowsCount = tolong(     iff(isnotempty(AdditionalFields.N_dead_tup), AdditionalFields.N_dead_tup,         column_ifexists('N_dead_tup_d',             column_ifexists('N_dead_tup',                 column_ifexists('N_dead_tup_s', \"\")             )         )     ) ), SeqentialScansCount = tolong(     iff(isnotempty(AdditionalFields.Seq_scan), AdditionalFields.Seq_scan,         column_ifexists('Seq_scan_d',             column_ifexists('Seq_scan',                 column_ifexists('Seq_scan_s', \"\")             )         )     ) ), RowsFromSeqentialScansCount = tolong(     iff(isnotempty(AdditionalFields.Seq_tup_read), AdditionalFields.Seq_tup_read,         column_ifexists('Seq_tup_read_d',             column_ifexists('Seq_tup_read',                 column_ifexists('Seq_tup_read_s', \"\")             )         )     ) ), IndexScansCount = tolong(     iff(isnotempty(AdditionalFields.Idx_scan), AdditionalFields.Idx_scan,         column_ifexists('Idx_scan_d',             column_ifexists('Idx_scan',                 column_ifexists('Idx_scan_s', \"\")             )         )     ) ), RowsFromIndexScansCount = tolong(     iff(isnotempty(AdditionalFields.Idx_tup_fetch), AdditionalFields.Idx_tup_fetch,         column_ifexists('Idx_tup_fetch_d',             column_ifexists('Idx_tup_fetch',                 column_ifexists('Idx_tup_fetch_s', \"\")             )         )     ) ), RowsInsertedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_ins), AdditionalFields.N_tup_ins,         column_ifexists('N_tup_ins_d',             column_ifexists('N_tup_ins',                 column_ifexists('N_tup_ins_s', \"\")             )         )     ) ), RowsUpdatedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_upd), AdditionalFields.N_tup_upd,         column_ifexists('N_tup_upd_d',             column_ifexists('N_tup_upd',                 column_ifexists('N_tup_upd_s', \"\")             )         )     ) ), RowsDeletedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_del), AdditionalFields.N_tup_del,         column_ifexists('N_tup_del_d',             column_ifexists('N_tup_del',                 column_ifexists('N_tup_del_s', \"\")             )         )     ) ), RowsHotUpdatedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_hot_upd), AdditionalFields.N_tup_hot_upd,         column_ifexists('N_tup_hot_upd_d',             column_ifexists('N_tup_hot_upd',                 column_ifexists('N_tup_hot_upd_s', \"\")             )         )     ) ), ModificationsSinceAnalyzeCount = tolong(     iff(isnotempty(AdditionalFields.N_mod_since_analyze), AdditionalFields.N_mod_since_analyze,         column_ifexists('N_mod_since_analyze_d',             column_ifexists('N_mod_since_analyze',                 column_ifexists('N_mod_since_analyze_s', \"\")             )         )     ) ), VacuumCount = tolong(     iff(isnotempty(AdditionalFields.Vacuum_count), AdditionalFields.Vacuum_count,         column_ifexists('Vacuum_count_d',             column_ifexists('Vacuum_count',                 column_ifexists('Vacuum_count_s', \"\")             )         )     ) ), AutovacuumCount = tolong(     iff(isnotempty(AdditionalFields.Autovacuum_count), AdditionalFields.Autovacuum_count,         column_ifexists('Autovacuum_count_d',             column_ifexists('Autovacuum_count',                 column_ifexists('Autovacuum_count_s', \"\")             )         )     ) ), AnalyzeCount = tolong(     iff(isnotempty(AdditionalFields.Analyze_count), AdditionalFields.Analyze_count,         column_ifexists('Analyze_count_d',             column_ifexists('Analyze_count',                 column_ifexists('Analyze_count_s', \"\")             )         )     ) ), AutoanalyzeCount = tolong(     iff(isnotempty(AdditionalFields.Autoanalyze_count), AdditionalFields.Autoanalyze_count,         column_ifexists('Autoanalyze_count_d',             column_ifexists('Autoanalyze_count',                 column_ifexists('Autoanalyze_count_s', \"\")             )         )     ) ), TablesCount = tolong(     iff(isnotempty(AdditionalFields.Tables_counter), AdditionalFields.Tables_counter,         column_ifexists('Tables_counter_d',             column_ifexists('Tables_counter',                 column_ifexists('Tables_counter_s', \"\")             )         )     ) ), TablesVacuumedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_vacuumed), AdditionalFields.Tables_vacuumed,         column_ifexists('Tables_vacuumed_d',             column_ifexists('Tables_vacuumed',                 column_ifexists('Tables_vacuumed_s', \"\")             )         )     ) ), TablesAutovacuumedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_autovacuumed), AdditionalFields.Tables_autovacuumed,         column_ifexists('Tables_autovacuumed_d',             column_ifexists('Tables_autovacuumed',                 column_ifexists('Tables_autovacuumed_s', \"\")             )         )     ) ), TablesAnalyzedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_analyzed), AdditionalFields.Tables_analyzed,         column_ifexists('Tables_analyzed_d',             column_ifexists('Tables_analyzed',                 column_ifexists('Tables_analyzed_s', \"\")             )         )     ) ), TablesAutoanalyzedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_autoanalyzed), AdditionalFields.Tables_autoanalyzed,         column_ifexists('Tables_autoanalyzed_d',             column_ifexists('Tables_autoanalyzed',                 column_ifexists('Tables_autoanalyzed_s', \"\")             )         )     ) )"
                }
              }
            ]
          },
          {
            "id": "b545dd79-d31d-43f8-bcbe-7a681acb80d2",
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLLogs",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category =='PostgreSQLLogs' | project TimeGenerated, Resource, Timestamp = tostring(     iff(isnotempty(AdditionalFields.timestamp), AdditionalFields.timestamp,         column_ifexists('timestamp_s',            column_ifexists('timestamp', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.processId), AdditionalFields.processId,         column_ifexists('processId_d',             column_ifexists('processId_s',                 column_ifexists('processId', \"\")             )         )     ) ), ErrorLevel = tostring(     iff(isnotempty(AdditionalFields.errorLevel), AdditionalFields.errorLevel,         column_ifexists('errorLevel_s',            column_ifexists('errorLevel', \"\")         )     ) ), SqlErrorCode = tostring(     iff(isnotempty(AdditionalFields.sqlerrcode), AdditionalFields.sqlerrcode,         column_ifexists('sqlerrcode_s',            column_ifexists('sqlerrcode', \"\")         )     ) ), Message = tostring(     iff(isnotempty(AdditionalFields.message), AdditionalFields.message,         column_ifexists('Message',            column_ifexists('message_s', \"\")         )     ) ), Detail = tostring(     iff(isnotempty(AdditionalFields.detail), AdditionalFields.detail,         column_ifexists('detail_s',            column_ifexists('detail', \"\")         )     ) ), Hint = tostring(     iff(isnotempty(AdditionalFields.hint), AdditionalFields.hint,         column_ifexists('hint_s',            column_ifexists('hint', \"\")         )     ) ), Query = tostring(     iff(isnotempty(AdditionalFields.query), AdditionalFields.query,         column_ifexists('query_s',            column_ifexists('query', \"\")         )     ) ), Context = tostring(     iff(isnotempty(AdditionalFields.context), AdditionalFields.context,         column_ifexists('context_s',            column_ifexists('context', \"\")         )     ) ), Statement = tostring(     iff(isnotempty(AdditionalFields.statement), AdditionalFields.statement,         column_ifexists('statement_s',            column_ifexists('statement', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.schema_name), AdditionalFields.schema_name,         column_ifexists('schema_name_s',            column_ifexists('schema_name', \"\")         )     ) ), TableName = tostring(     iff(isnotempty(AdditionalFields.table_name), AdditionalFields.table_name,         column_ifexists('table_name_s',            column_ifexists('table_name', \"\")         )     ) ), ColumnName = tostring(     iff(isnotempty(AdditionalFields.column_name), AdditionalFields.column_name,         column_ifexists('column_name_s',            column_ifexists('column_name', \"\")         )     ) ), DatatypeName = tostring(     iff(isnotempty(AdditionalFields.datatype_name), AdditionalFields.datatype_name,         column_ifexists('datatype_name_s',            column_ifexists('datatype_name', \"\")         )     ) ), ConstraintName = tostring(     iff(isnotempty(AdditionalFields.constraint_name), AdditionalFields.constraint_name,         column_ifexists('constraint_name_s',            column_ifexists('constraint_name', \"\")         )     ) )"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLFlexDatabaseXacts",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category =='PostgreSQLFlexDatabaseXacts' | project TimeGenerated, Resource, DatabaseName = tostring(     iff(isnotempty(AdditionalFields.DatabaseName), AdditionalFields.DatabaseName,         column_ifexists('DatabaseName_s',            column_ifexists('DatabaseName', \"\")         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Datdba), AdditionalFields.Datdba,         column_ifexists('Datdba_d',             column_ifexists('Datdba',                 column_ifexists('Datdba_s', \"\")             )         )     )     ), ConnectionsLimit = toint(     iff(isnotempty(AdditionalFields.DatConnLimit), AdditionalFields.DatConnLimit,         column_ifexists('DatConnLimit_d',             column_ifexists('DatConnLimit',                 column_ifexists('DatConnLimit_s', \"\")             )         )     ) ), MinMultixactId = tolong(     iff(isnotempty(AdditionalFields.DatMinmxid), AdditionalFields.DatMinmxid,         column_ifexists('DatMinmxid_d',             column_ifexists('DatMinmxid',                 column_ifexists('DatMinmxid_s', \"\")             )         )     ) ), MinMultixactIdAge = tolong(     iff(isnotempty(AdditionalFields.Age_DatMinmxid), AdditionalFields.Age_DatMinmxid,         column_ifexists('Age_DatMinmxid_d',             column_ifexists('Age_DatMinmxid',                 column_ifexists('Age_DatMinmxid_s', \"\")             )         )     ) ), TransactionIdFrozen = tolong(     iff(isnotempty(AdditionalFields.DatFrozenxid), AdditionalFields.DatFrozenxid,         column_ifexists('DatFrozenxid_d',             column_ifexists('DatFrozenxid',                 column_ifexists('DatFrozenxid_s', \"\")             )         )     ) ), TransactionIdFrozenAge = tolong(     iff(isnotempty(AdditionalFields.Age_DatFrozenxid), AdditionalFields.Age_DatFrozenxid,         column_ifexists('Age_DatFrozenxid_d',             column_ifexists('Age_DatFrozenxid',                 column_ifexists('Age_DatFrozenxid_s', \"\")             )         )     ) ), VacuumFreezeMinAge = toint(     iff(isnotempty(AdditionalFields.Vacuum_freeze_min_age), AdditionalFields.Vacuum_freeze_min_age,         column_ifexists('Vacuum_freeze_min_age_d',             column_ifexists('Vacuum_freeze_min_age',                 column_ifexists('Vacuum_freeze_min_age_s', \"\")             )         )     ) ), AutovacuumFreezeMaxAge = toint(     iff(isnotempty(AdditionalFields.Autovacuum_freeze_max_age), AdditionalFields.Autovacuum_freeze_max_age,         column_ifexists('Autovacuum_freeze_max_age_d',             column_ifexists('Autovacuum_freeze_max_age',                 column_ifexists('Autovacuum_freeze_max_age_s', \"\")             )         )     ) ), RemainingTransactionIds = tolong(     iff(isnotempty(AdditionalFields.Total_remaining_xids), AdditionalFields.Total_remaining_xids,         column_ifexists('Total_remaining_xids_d',             column_ifexists('Total_remaining_xids',                 column_ifexists('Total_remaining_xids_s', \"\")             )         )     ) ), RemainingTransactionIdsTillEmergencyAV = tolong(     iff(isnotempty(AdditionalFields.Remaining_xids_till_emergency_autovacuum), AdditionalFields.Remaining_xids_till_emergency_autovacuum,         column_ifexists('Remaining_xids_till_emergency_autovacuum_d',             column_ifexists('Remaining_xids_till_emergency_autovacuum',                 column_ifexists('Remaining_xids_till_emergency_autovacuum_s', \"\")             )         )     ) ), RemainingTransactionIdsTillWraparound = tolong(     iff(isnotempty(AdditionalFields.Remaining_xids_till_wraparound), AdditionalFields.Remaining_xids_till_wraparound,         column_ifexists('Remaining_xids_till_wraparound_d',             column_ifexists('Remaining_xids_till_wraparound',                 column_ifexists('Remaining_xids_till_wraparound_s', \"\")             )         )     ) ), VacuumMultixactFreezeMinAge = toint(     iff(isnotempty(AdditionalFields.Vacuum_multixact_freeze_min_age), AdditionalFields.Vacuum_multixact_freeze_min_age,         column_ifexists('Vacuum_multixact_freeze_min_age_d',             column_ifexists('Vacuum_multixact_freeze_min_age',                 column_ifexists('Vacuum_multixact_freeze_min_age_s', \"\")             )         )     ) ), AutovacuumMultixactFreezeMaxAge = toint(     iff(isnotempty(AdditionalFields.Autovacuum_multixact_freeze_max_age), AdditionalFields.Autovacuum_multixact_freeze_max_age,         column_ifexists('Autovacuum_multixact_freeze_max_age_d',             column_ifexists('Autovacuum_multixact_freeze_max_age',                 column_ifexists('Autovacuum_multixact_freeze_max_age_s', \"\")             )         )     ) ), RemainingMultixactIds = tolong(     iff(isnotempty(AdditionalFields.Total_remaining_mxids), AdditionalFields.Total_remaining_mxids,         column_ifexists('Total_remaining_mxids_d',             column_ifexists('Total_remaining_mxids',                 column_ifexists('Total_remaining_mxids_s', \"\")             )         )     ) ), RemainingMultixactIdsTillEmergencyAV = tolong(     iff(isnotempty(AdditionalFields.Remaining_mxids_till_emergency_autovacuum), AdditionalFields.Remaining_mxids_till_emergency_autovacuum,         column_ifexists('Remaining_mxids_till_emergency_autovacuum_d',             column_ifexists('Remaining_mxids_till_emergency_autovacuum',                 column_ifexists('Remaining_mxids_till_emergency_autovacuum_s', \"\")             )         )     ) ), RemainingMultixactIdsTillWraparound = tolong(     iff(isnotempty(AdditionalFields.Remaining_mxids_till_wraparound), AdditionalFields.Remaining_mxids_till_wraparound,         column_ifexists('Remaining_mxids_till_wraparound_d',             column_ifexists('Remaining_mxids_till_wraparound',                 column_ifexists('Remaining_mxids_till_wraparound_s', \"\")             )         )     ) )"
                }
              }
            ],
            "id": "2528752f-7b83-45ee-93f2-73b59982a215"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLFlexSessions",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category =='PostgreSQLFlexSessions' | project TimeGenerated, Resource, DatabaseId = toint(     iff(isnotempty(AdditionalFields.Datid), AdditionalFields.Datid,         column_ifexists('Datid_d',             column_ifexists('Datid_s',                 column_ifexists('Datid', \"\")             )         )     )     ), DatabaseName = tostring(     iff(isnotempty(AdditionalFields.Database_name), AdditionalFields.Database_name,         column_ifexists('Database_name_s',            column_ifexists('Database_name', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.Pid), AdditionalFields.Pid,         column_ifexists('Pid_d',            column_ifexists('Pid', \"\")         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Usesysid), AdditionalFields.Usesysid,         column_ifexists('Usesysid_d',             column_ifexists('Usesysid_s',                 column_ifexists('Usesysid', \"\")             )         )     )     ), ApplicationName = tostring(     iff(isnotempty(AdditionalFields.Application_name), AdditionalFields.Application_name,         column_ifexists('Application_name_s',            column_ifexists('Application_name', \"\")         )     ) ), ClientIpAddress = tostring(     iff(isnotempty(AdditionalFields.Client_addr), AdditionalFields.Client_addr,         column_ifexists('Client_addr_s',            column_ifexists('Client_addr', \"\")         )     ) ), State = tostring(     iff(isnotempty(AdditionalFields.State), AdditionalFields.State,         column_ifexists('State_s',            column_ifexists('State', \"\")         )     ) ), WaitEventType = tostring(     iff(isnotempty(AdditionalFields.Wait_event_type), AdditionalFields.Wait_event_type,         column_ifexists('Wait_event_type_s',            column_ifexists('Wait_event_type', \"\")         )     ) ), WaitEvent = tostring(     iff(isnotempty(AdditionalFields.Wait_event), AdditionalFields.Wait_event,         column_ifexists('Wait_event_s',            column_ifexists('Wait_event', \"\")         )     ) ), BackendStartTime = todatetime(     iff(isnotempty(AdditionalFields.Backend_start), AdditionalFields.Backend_start,         column_ifexists('Backend_start_t',             column_ifexists('Backend_start',                 column_ifexists('Backend_start_s', \"\")             )         )     ) ), TransactionStartTime = todatetime(     iff(isnotempty(AdditionalFields.Xact_start), AdditionalFields.Xact_start,         column_ifexists('Xact_start_t',             column_ifexists('Xact_start_s',                 column_ifexists('Xact_start', \"\")             )         )     ) ), QueryStartTime = todatetime(     iff(isnotempty(AdditionalFields.Query_start), AdditionalFields.Query_start,         column_ifexists('Query_start_t',             column_ifexists('Query_start_s',                 column_ifexists('Query_start', \"\")             )         )     ) ), StateChangeTime = todatetime(     iff(isnotempty(AdditionalFields.State_change), AdditionalFields.State_change,         column_ifexists('State_change_t',             column_ifexists('State_change_s',                 column_ifexists('State_change', \"\")             )         )     ) ), CollectionTime = todatetime(     iff(isnotempty(AdditionalFields.Collection_time), AdditionalFields.Collection_time,         column_ifexists('Collection_time_t',             column_ifexists('Collection_time_s',                 column_ifexists('Collection_time', \"\")             )         )     ) ), TransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xid), AdditionalFields.Backend_xid,         column_ifexists('Backend_xid_d',             column_ifexists('Backend_xid_s',                 column_ifexists('Backend_xid', \"\")             )         )     ) ), OldestTransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xmin), AdditionalFields.Backend_xmin,         column_ifexists('Backend_xmin_d',             column_ifexists('Backend_xmin_s',                 column_ifexists('Backend_xmin', \"\")             )         )     ) ), BackendType = tostring(     iff(isnotempty(AdditionalFields.Backend_type), AdditionalFields.Backend_type,         column_ifexists('Backend_type_s',            column_ifexists('Backend_type', \"\")         )     ) )"
                }
              }
            ],
            "id": "320c5eda-9c90-466d-b5af-8d040750e99b"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.resourcegraph/resources"
      },
      "name": "backend queries to get telemtry"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "a3c88205-1160-40b8-8fba-423c635596c9",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetEnabledGroups",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.categoryGroup!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.categoryGroup\",\"columnid\":\"CategoryGroup\"}]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetAllEnabledCategories",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.category!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.category\",\"columnid\":\"Category\"}]}}]}",
            "queryType": 12,
            "id": "cc0b467c-1e68-4613-b06e-462e63cc2495"
          },
          {
            "id": "3172fbc3-cfb6-46ca-9b1c-0f47b2f497a7",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimaryAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..properties..replicationRole\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "ce539c66-2b54-46bb-a384-7b90d78f46e8",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimary",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsServerPrimaryAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "Primary",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "5fdec83f-0dec-4efd-9928-6342dad36eaa",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricsAutovacuumDiagnosticsAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/metrics.autovacuum_diagnostics?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^on|ON|On|oN$\",\"substringReplace\":\"ON\"}]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "494c9f2f-43e4-4dbc-a4ee-9be017a05bd0",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricsAutovacuumDiagnosticsOn",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsMetricsAutovacuumDiagnosticsAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "ON",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "a203c3f6-1949-4bd2-b110-2f923c2adc6d",
            "version": "KqlParameterItem/1.0",
            "name": "AutovacuumAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^on|ON|On|oN$\",\"substringReplace\":\"ON\"}]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "2883fefd-b500-4385-b789-ace525dc082b",
            "version": "KqlParameterItem/1.0",
            "name": "IsAutovacuumOn",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AutovacuumAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "ON",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "807fddc6-661a-455c-942d-f047da07162c",
            "version": "KqlParameterItem/1.0",
            "name": "IsTableStatsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexTableStats",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "30891a89-0e07-4054-b835-b12b296e5203",
            "version": "KqlParameterItem/1.0",
            "name": "IsDatabaseXactsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexDatabaseXacts",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "eaaf4dca-3c74-4c39-94a0-de37f1a8fb4b",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerLogsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexSessions",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "id": "0d9e221a-7439-415e-8626-d23536326ab1"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "LogAutovacuumMinDurationAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/log_autovacuum_min_duration?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "e178a342-dd7d-41fa-bd0a-51adae879db0",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsLogAutovacuumMinDurationOn",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "LogAutovacuumMinDurationAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "-1",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              }
            ],
            "id": "b53b5471-cf9a-4c7d-8733-87af0eb6c228"
          },
          {
            "id": "e430ce26-f33f-4576-8572-e2027664e400",
            "version": "KqlParameterItem/1.0",
            "name": "isPreparedXactsUsed",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/max_prepared_transactions?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "005de42a-784a-4722-8e24-fdfb62a7c6be",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerHavingReplicaAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/replicas?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value[*].name\",\"columns\":[]}}]}",
            "queryType": 12
          },
          {
            "id": "90de2148-f760-4651-911f-cce08878c59d",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerHavingReplica",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsServerHavingReplicaAPI",
                  "operator": "isNotNull",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          }
        ],
        "style": "above",
        "queryType": 12
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "ValidaitonsParameters"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "9e8382bf-e5e2-4279-9662-65c5b83faa48",
            "version": "KqlParameterItem/1.0",
            "name": "Database",
            "type": 2,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet x= print DatabaseName_s='All';\r\nlet y=\r\nAzureDiagnostics\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n|where Category ==\"PostgreSQLFlexTableStats\"\r\n| where DatabaseName_s !in (\"azure_sys\",\"azure_maintenance\")\r\n| where N_live_tup_d >100 and N_dead_tup_d >1000\r\n|distinct DatabaseName_s;\r\nx | union  y\r\n| project value=DatabaseName_s, label=DatabaseName_s, selected = iff(DatabaseName_s == 'All', true, false)\r\n|order by label asc\r\n\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "IsTableStatsSentToLogAnalytics",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "customWidth": "50",
      "name": "checks on parameters"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "7f1b5948-358a-4845-bc0b-6d45a9ee8f8b",
            "version": "KqlParameterItem/1.0",
            "name": "LessThanOneHourInterval",
            "type": 1,
            "query": "let interval = 1h;\r\nprint iff({TimeRange:end} - {TimeRange:start} < interval, \"Yes\", \"No\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "c355a1f4-39bd-4835-901d-3c5160342265",
            "version": "KqlParameterItem/1.0",
            "name": "EmergencyWraparoundVacuumIssue",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet max_query = \r\n{PostgreSQLFlexDatabaseXacts}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| extend ts=bin(TimeGenerated,5min)\r\n| summarize max(ts);\r\n{PostgreSQLFlexDatabaseXacts}\r\n| where TimeGenerated >= End_Time-{WRAPAROUND_LOOK_BACK_DAYS}\r\n| extend ts=bin(TimeGenerated,5min)\r\n| where ts in(max_query)\r\n| extend PercentTowardsWraparound=round(toreal(TransactionIdFrozenAge)/toreal({MAX_XACTS})*100,2)\r\n| extend PercentTowardsEmergencyAV=round(toreal(TransactionIdFrozenAge)/toreal(AutovacuumFreezeMaxAge)*100,2)\r\n| extend PercentTowardsWraparoundMxid=round(toreal(MinMultixactIdAge)/toreal({MAX_XACTS})*100,2)\r\n| extend PercentTowardsEmergencyAVMxid=round(toreal(MinMultixactIdAge)/toreal(AutovacuumMultixactFreezeMaxAge)*100,2)\r\n| project \r\nDatabaseName,PercentTowardsWraparound,PercentTowardsEmergencyAV,PercentTowardsWraparoundMxid,PercentTowardsEmergencyAVMxid\r\n| where PercentTowardsEmergencyAV > {EMERGENCY_AV_THRES} or \r\n        PercentTowardsWraparound > {WRAPAROUND_THRES} or \r\n        PercentTowardsEmergencyAVMxid > {EMERGENCY_AV_THRES} or \r\n        PercentTowardsWraparoundMxid > {WRAPAROUND_THRES}\r\n| count      \r\n| extend EmergencyWraparoundVacuumIssue = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project EmergencyWraparoundVacuumIssue",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "3b96a823-321c-4963-9a1d-1b21f60f03a4",
            "version": "KqlParameterItem/1.0",
            "name": "_SevenDaysAgoTimestamp",
            "type": 1,
            "query": "let dt = {TimeRange:end}-7d;\r\nprint \r\nv=format_datetime(dt, 'MM/dd/yyyy hh:mm tt')",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "df16fc21-78da-44de-8804-b62e36e9276c",
            "version": "KqlParameterItem/1.0",
            "name": "ChartGrain",
            "type": 1,
            "query": "let trange=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nprint case(\r\n    trange<1h, strcat(format_timespan(trange,'m'),' minute(s)'),\r\n    trange>=1h and trange<1d, strcat(format_timespan(trange,'H'),' hour(s)') ,\r\n    strcat(format_timespan(trange,'dd'),' day(s)')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "14b0a73c-9234-446b-a9cb-e48b1fbeec2b",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedDatabasesRaw",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName !in (\"azure_sys\",\"azure_maintenance\")\r\n| where LiveRowsCount >100 and DeadRowsCount >1000\r\n|distinct db=DatabaseName\r\n|project dbname=split(db, \",\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "74c715dd-8c8b-4609-956e-01922994ebc0",
            "version": "KqlParameterItem/1.0",
            "name": "OverTenDatabasesOnServer",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/databases?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value[?(@.name !='azure_sys' && @.name != 'azure_maintenance')].name\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsOverTenDatabasesOnServer",
            "type": 1,
            "query": "print dbcount= array_length(split('{OverTenDatabasesOnServer}', \",\"))\r\n|extend IsDbCount10 = iff(dbcount>10,'Yes','No')\r\n|project IsDbCount10\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "id": "b70e1d97-f974-458d-8a1f-2c3bd676cdb7"
          },
          {
            "id": "694974ac-bcbf-4e4a-88f3-1efdc1098163",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedSchemasRaw",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName =='{Database}'\r\n| summarize LiveRowsCount=max(LiveRowsCount),DeadRowsCount=max(DeadRowsCount) by bin(TimeGenerated,15m), SchemaName\r\n| where LiveRowsCount>100 and DeadRowsCount>1000\r\n|distinct SchemaName\r\n|project Schema=split(SchemaName, \",\")\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "0c5bb12f-1d00-4b55-99ec-142d62c5796d",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedDatabases",
            "type": 1,
            "isRequired": true,
            "query": "print dbname='{QualifiedDatabasesRaw}'\r\n| extend dbname=replace_string(dbname, '[','')\r\n| extend dbname=replace_string(dbname, ']','')\r\n| project dbname",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "4ed030ce-611f-4b9a-8184-2b24e25c34b1",
            "version": "KqlParameterItem/1.0",
            "name": "IsAVCatchingUp",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalEndTime}')-{AV_LOOK_BACK_DAYS};\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet MAX_BLOAT_PCT=100;\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| summarize LiveTuplesCluster= max(LiveTuplesCluster),DeadTuplesCluster=max(DeadTuplesCluster)  \r\n  by bin(TimeGenerated,1d),DatabaseName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal((DeadTuplesCluster+LiveTuplesCluster))*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n|project TimeGenerated, DatabaseName, BloatRatio\r\n|summarize arg_max(TimeGenerated,latest_bloat_pct=(MAX_BLOAT_PCT-BloatRatio)),arg_min(TimeGenerated,last_bloat_pct=(MAX_BLOAT_PCT-BloatRatio)) by DatabaseName\r\n|extend  pct_bloat_change = toreal(((latest_bloat_pct-last_bloat_pct)/((latest_bloat_pct+last_bloat_pct)/2))*100)\r\n|extend pct_bloat_change = iff(isnan(pct_bloat_change),0.0,pct_bloat_change)\r\n|extend actual_latest_pct=MAX_BLOAT_PCT-latest_bloat_pct\r\n|where pct_bloat_change >{AV_BLOAT_THRESHOLD} or actual_latest_pct >{AV_BLOAT_THRESHOLD}\r\n|project DatabaseName",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedSchemas",
            "type": 1,
            "isRequired": true,
            "query": "print Schema='{QualifiedSchemasRaw}'\r\n| extend Schema=replace_string(Schema, '[','')\r\n| extend Schema=replace_string(Schema, ']','')\r\n| project Schema",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "id": "07ccd9aa-d994-4392-9d40-e335f686b636"
          },
          {
            "id": "43bbd184-2866-4e3a-985d-c961f2be3c4e",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedDatabasesCount",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "QualifiedDatabases",
                  "operator": "is Empty",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedSchemaCount",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "QualifiedSchemas",
                  "operator": "is Empty",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              }
            ],
            "id": "d9edf76f-106e-4cee-84c9-d93c8c70d72d"
          },
          {
            "id": "3c750ce7-90f0-410d-a4b4-bb07f915f8b2",
            "version": "KqlParameterItem/1.0",
            "name": "UnQualifiedSchema",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName =='{Database}'\r\n| summarize LiveRowsCount=max(LiveRowsCount),DeadRowsCount=max(DeadRowsCount) by bin(TimeGenerated,15m), SchemaName\r\n| where LiveRowsCount < 100 and DeadRowsCount < 1000\r\n| distinct SchemaName\r\n| order by SchemaName asc\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "dc442afa-0531-4e7e-a3ad-81065c93e2ef",
            "version": "KqlParameterItem/1.0",
            "name": "WorkbookNecessary",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet ReadReplica=print isneccesary='{IsServerHavingReplica}';\r\nlet prep_statements =\r\nprint prepared=tolong('{isPreparedXactsUsed}')\r\n| project isneccesary=iff(prepared>0, \"Yes\", \"No\")\r\n| project isneccesary;\r\n\r\nlet sessions =\r\n{PostgreSQLFlexSessions}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| where State !='idle'\r\n| extend Transaction_duration_ms=datetime_diff('second',CollectionTime,TransactionStartTime)\r\n| summarize Transaction_duration_ms=max(Transaction_duration_ms)\r\n| where Transaction_duration_ms > toint({LongRunningTransaction}) \r\n|count\r\n| extend isneccesary = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project isneccesary;\r\n\r\nprep_statements | union sessions,ReadReplica\r\n|where isneccesary =='Yes'\r\n|count\r\n| extend WorkbookNecessary = iff(Count > 0, 'Yes', 'No')\r\n| project WorkbookNecessary",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "5ae97d04-b0fd-410b-afed-52377eaaf643",
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_max_workers",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_max_workers?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.value\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_default_autovacuum_max_workers",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_max_workers?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.defaultValue\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "6031e707-1de5-4406-9015-c8a1a1412662",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_vacuum_cost_limit",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_vacuum_cost_limit?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.value\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "ce25022b-39fd-4ad8-8b87-809bf5180817",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_default_autovacuum_vacuum_cost_limit",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_vacuum_cost_limit?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.defaultValue\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "46a02197-7d24-4b2a-bdd5-8bdd2d6e01bd",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_vacuum_cost_limit",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/vacuum_cost_limit?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.value\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "30a7dae4-008f-4e06-a1bb-fc6119fe427a",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_default_vacuum_cost_limit",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/vacuum_cost_limit?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.defaultValue\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "9c32bc3c-8dd8-4d16-987f-63e241d78a2f",
            "value": null
          },
          {
            "id": "2dd53d46-4b66-4c0a-808d-c20028dc22bd",
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_vacuum_cost_delay",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_vacuum_cost_delay?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.properties.value\",\"columns\":[]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "id": "51ad4c80-5c54-406e-911a-c6131da568bb",
            "version": "KqlParameterItem/1.0",
            "name": "generate_autovacuum_max_workers_warning",
            "type": 1,
            "query": "let autovacuum_max_workers = {fetch_autovacuum_max_workers};\r\nlet autovacuum_vacuum_cost_limit = {fetch_autovacuum_vacuum_cost_limit};\r\nlet vacuum_cost_limit = {fetch_vacuum_cost_limit};\r\nlet default_autovacuum_vacuum_cost_limit = {fetch_default_autovacuum_vacuum_cost_limit};\r\nlet default_vacuum_cost_limit = {fetch_default_vacuum_cost_limit};\r\nlet default_autovacuum_max_workers = {fetch_default_autovacuum_max_workers};\r\nlet autovacuum_vacuum_cost_delay = {fetch_autovacuum_vacuum_cost_delay};\r\nlet autovacuum_max_workers_threshold_medium = 5;\r\nlet autovacuum_max_workers_threshold_high = 10;\r\nlet warning1 = \"Warning: Increasing autovacuum_max_workers to {fetch_autovacuum_max_workers} without adjusting autovacuum_vacuum_cost_limit/vacuum_cost_limit may slow down workers. Note that the cost limit is distributed proportionally among the running autovacuum workers. Consider adjusting vacuum/Autovacuum cost limits accordingly to ensure optimal performance.\";\r\nlet warning2 = \"Warning: Reducing the number of autovacuum_max_workers to {fetch_autovacuum_max_workers} may impact server vacuum performance negatively. With fewer Autovacuum workers, the system might struggle to keep up with the demand for vacuuming.\";\r\nlet warning3 = \"Warning: Setting autovacuum_max_workers to a value higher than 10 can lead to excessive vacuum activity, potentially causing performance degradation and increased resource consumption.\";\r\n\r\n// Check if autovacuum_max_workers is between threshold_medium and threshold_high\r\nlet isBetweenThresholds = autovacuum_max_workers >= autovacuum_max_workers_threshold_medium and autovacuum_max_workers <= autovacuum_max_workers_threshold_high;\r\n\r\n// Check if vacuum cost limits are equal to defaults\r\nlet isVacuumCostDefault = autovacuum_vacuum_cost_delay > 0 and (vacuum_cost_limit == default_vacuum_cost_limit and autovacuum_vacuum_cost_limit == default_autovacuum_vacuum_cost_limit);\r\n\r\n// Check if autovacuum_max_workers is less than default_autovacuum_max_workers\r\nlet isReducedWorkers = autovacuum_max_workers < default_autovacuum_max_workers;\r\n\r\n// Check if autovacuum_max_workers is greater than threshold_high\r\nlet isExcessiveWorkers = autovacuum_max_workers > autovacuum_max_workers_threshold_high;\r\n\r\n// Generate warnings based on conditions\r\nlet warning = iff(isBetweenThresholds and isVacuumCostDefault, warning1,iff(isReducedWorkers, warning2, iff(isExcessiveWorkers, warning3,'None')));\r\nprint warning\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "check to see if workbook is needed for the server"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "#### This troubleshooting guide displays only databases and schemas with Live_tuples >100 and Dead_tuples > 1000.\r\nPlease keep in mind that the count of databases and schemas displayed in this troubleshooting guide may not match the total number of databases and schemas present on the PostgreSQL server. This is because the troubleshooting guide filters out any databases and schemas that do not meet the specified criteria.\r\n\r\nIt's important to understand this limitation when working with the troubleshooting guide, as it may affect the accuracy of any analyses or insights drawn from the data. However, by focusing on the databases and schemas that meet the criteria, it's possible to gain a better understanding of the health and performance of the PostgreSQL server and take appropriate actions to optimize it.\r\n\r\n**Occasionally, we may deviate from these standards and opt to include all the databases on the server, which would trigger a warning for exceeding the limit of 10 databases.**\r\n\r\n**Points to keep in mind while utilizing this troubleshooting guide:**\r\n\r\nThe troubleshooting guide has a cap of 30 databases. However, if you're using the Burstable SKU, the limit is reduced to 10 databases. It's worth noting that this limit applies to the OID column, which indicates the order in which the databases were created.",
              "style": "info"
            },
            "name": "Workbook Info on live and dead tuples"
          }
        ],
        "exportParameters": true
      },
      "name": "workbook description"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "### There is no database with high dead_tuples/bloat detected in the selected PostgreSQL Flexible Server in the specified time range.\r\nThe PostgreSQL Flexible Server you have selected does not contain a database with a higher dead_tuples/bloat ratio, so information related to the troubleshooting guide will not be displayed.\r\n\r\nHowever, the system will still perform necessary checks and display any relevant warnings to ensure that the server is running optimally.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "QualifiedDatabasesCount",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsTableStatsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "QualifiedDatabasesCount",
                "comparison": "isNotEqualTo"
              }
            ],
            "name": "are there any databases of concern"
          },
          {
            "type": 1,
            "content": {
              "json": "### Autovacuum is currently disabled\r\nAutovacuum is currently disabled. This can lead to the accumulation of dead tuples, index fragmentation, transaction ID wraparound, increased disk space consumption, poor query performance. To prevent these issues, it is strongly recommended to enable autovacuum with appropriate settings and regularly monitor and maintain the database.\r\n\r\nYou can use the Azure Portal to configure server parameters and enable autovacuum. For more information, please follow this link: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-server-parameters-using-portal.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsAutovacuumOn",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "autovacuum is off"
          },
          {
            "type": 1,
            "content": {
              "json": "### The log_autovacuum_min_duration setting is currently disabled\r\nIt seems that the `log_autovacuum_min_duration` setting is turned off on the server. As a result, the Autovacuum workers execution section in this troubleshooting guide will not show any information since autovacuum logging is not being carried out. It is recommended to enable this setting in order to track longer autovacuum operations.\r\n\r\nYou can use the Azure Portal to configure server parameters and enable `log_autovacuum_min_duration`. For more information, please follow this link: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-server-parameters-using-portal.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsLogAutovacuumMinDurationOn",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "QualifiedDatabasesCount",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "log autovacuum min duration setting is currently disabled"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Server Logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL server logs data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Server Logs` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsServerLogsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "IsServerLogsSentToLogAnalytics"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Sessions data logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL Sessions logs data is not being sent to the log analytics workspace, which is necessary to use this workbook. To configure the logging settings for category `PostgreSQL Sessions data` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "session logs are not being transmitted"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Autovacuum and schema statistics logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL Table Stats data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Autovacuum and schema statistics` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsTableStatsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "IsTableStatsSentToLogAnalytics"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL remaining transactions logs are not being transmitted to the log analytics workspace\r\nThe PostgreSQL Table Stats data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL remaining transactions` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsDatabaseXactsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "remaining transactions are not being transmitted"
          },
          {
            "type": 1,
            "content": {
              "json": "### The specified server is not a primary server\r\nThe autovacuum statistics shown on the replica server are not relevant and may be misleading. The replica server is designed to replicate data from the primary server and is not responsible for running autovacuum. The autovacuum statistics shown on the replica server are simply a reflection of the primary server's activity and do not represent the actual state of the replica server. \r\n\r\nPlease be aware that checking the autovacuum statistics on a replica server may cause confusion and lead to incorrect conclusions about the state of the database. We recommend that you only check the autovacuum statistics on the primary server to ensure accurate and reliable results.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsServerPrimary",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "specified server is not a primary"
          }
        ]
      },
      "name": "errors",
      "styleSettings": {
        "margin": "1"
      }
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "### Warning: Elevated percentage of wraparound and emergency autovacuuming protection detected\r\nThis warning indicates that the autovacuum process, which helps maintain the health and performance of a PostgreSQL database, is currently blocked or running slow. This can lead to higher percentages towards wraparound or emergency autovacuum protection.",
                    "style": "warning"
                  },
                  "name": "elevated percentage of wraparound"
                },
                {
                  "type": 11,
                  "content": {
                    "version": "LinkItem/1.0",
                    "style": "paragraph",
                    "links": [
                      {
                        "id": "01cef439-ceca-4e6f-b2c7-e5a844636211",
                        "cellValue": "",
                        "linkTarget": "WorkbookTemplate",
                        "linkLabel": "Autovacuum blockers troubleshooting guide",
                        "preText": "Please visit ",
                        "postText": " to debug.",
                        "style": "link",
                        "linkIsContextBlade": true,
                        "workbookContext": {
                          "componentIdSource": "workbook",
                          "resourceIdsSource": "workbook",
                          "templateIdSource": "static",
                          "templateId": "Community-Workbooks/PostgreSQL Flexible Server/Performance/Autovacuum Blockers",
                          "typeSource": "workbook",
                          "gallerySource": "workbook",
                          "locationSource": "default",
                          "passSpecificParams": true,
                          "templateParameters": [
                            {
                              "name": "TimRange",
                              "source": "parameter",
                              "value": "TimeRange"
                            },
                            {
                              "name": "Resource",
                              "source": "parameter",
                              "value": "Resource"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  "name": "link to av blockers workbook"
                }
              ]
            },
            "conditionalVisibilities": [
              {
                "parameterName": "EmergencyWraparoundVacuumIssue",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "EmergencyWraparoundVacuumIssueWarning"
          },
          {
            "type": 1,
            "content": {
              "json": "#### More than 10 databases are detected.\r\n**The given server contains more than 10 databases, and the presence of several databases with a limited number of autovacuum workers may result in autovacuum to fall behind.**\r\n\r\nIf autovacuum is unable to catch-up due the large number of databases on the server, it is advisable to adjust the autovacuum parameters.\r\n\r\nFor more information on how to tune autovacuum in this situation, please refer to: https://learn.microsoft.com/azure/postgresql/flexible-server/how-to-autovacuum-tuning#large-number-ofdatabases",
              "style": "warning"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "OverTenDatabasesOnServer",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "more than ten databases found"
          },
          {
            "type": 1,
            "content": {
              "json": "#### The autovacuum process is not able to keep up with the workload for certain databases on the server.\r\n\r\nBetween the time period **{_SevenDaysAgoTimestamp}** and **{TimeRange:end}** the bloat ratio for **{IsAVCatchingUp}**  databases seems to have increased more than {AV_BLOAT_THRESHOLD}% or the bloat ratio for these databases at current time period - **{TimeRange:end}** is more than {AV_BLOAT_THRESHOLD}%.Please follow recommendations below\r\n\r\n1. Review the metrics provided to identify the databases with a high bloat ratio and follow the provided recommendations.\r\n2. Check the troubleshooting guide for any warnings about autovacuum blockers. Autovacuum blockers can increase bloat, which can prevent autovacuum workers from catching up.\r\n3. If no autovacuum or vacuum blockers are found, please refer to the following link for more information on how to tune autovacuum in this situation: https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning#not-keeping-up-with-busy-server\r\n\r\n",
              "style": "warning"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsAVCatchingUp",
                "comparison": "isNotEqualTo",
                "value": ""
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "av cannot keep up at the moment"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "loadType": "always",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Autovacuum is blocked.\r\nThis warning indicates that the autovacuum process, which helps maintain the health and performance of a PostgreSQL database, is currently blocked. This can lead to an accumulation of dead tuples, increased bloat, and degraded performance.",
                    "style": "warning"
                  },
                  "name": "av is blocked and here could be why"
                },
                {
                  "type": 11,
                  "content": {
                    "version": "LinkItem/1.0",
                    "style": "list",
                    "links": [
                      {
                        "id": "57ba7895-7e6a-40fa-ae2f-597495d440f7",
                        "cellValue": "",
                        "linkTarget": "WorkbookTemplate",
                        "linkLabel": "Autovacuum blockers troubleshooting guide",
                        "preText": "It's crucial to identify and address the source of the autovacuum blockage promptly. This may involve investigating potential causes. Please visit",
                        "postText": " to debug.",
                        "style": "link",
                        "linkIsContextBlade": true,
                        "workbookContext": {
                          "componentIdSource": "workbook",
                          "resourceIdsSource": "workbook",
                          "templateIdSource": "static",
                          "templateId": "Community-Workbooks/PostgreSQL Flexible Server/Performance/Autovacuum Blockers",
                          "typeSource": "workbook",
                          "gallerySource": "workbook",
                          "locationSource": "default",
                          "passSpecificParams": true,
                          "templateParameters": [
                            {
                              "name": "Resource",
                              "source": "parameter",
                              "value": "Resource"
                            },
                            {
                              "name": "TimeRange",
                              "source": "parameter",
                              "value": "TimeRange"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  "name": "a link to an autovacuum troubleshooting guide"
                }
              ]
            },
            "conditionalVisibilities": [
              {
                "parameterName": "WorkbookNecessary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "group - 31"
          }
        ]
      },
      "name": "warnings about the section"
    },
    {
      "type": 1,
      "content": {
        "json": "#### This troubleshooting guide will only display data for schemas that meet the eligibility criteria, which includes a minimum of 100 live tuples and 1000 dead tuples. Therefore, data for schemas **'{UnQualifiedSchema}'** are not shown as they don't meet these criteria. .",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "Database",
          "comparison": "isNotEqualTo",
          "value": "All"
        },
        {
          "parameterName": "IsServerPrimary",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsTableStatsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "UnQualifiedSchema",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "schema must meet eligability criteria"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Please note that this troubleshooting guide does not permit the selection of a timerange shorter than one hour. If a timerange of less than one hour is selected, the troubleshooting guide will default to a timerange of one hour.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "LessThanOneHourInterval",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "name": "Workbook Info on live and dead tuples for troubleshooting guide"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$.value[?(@.name==\\\"autovacuum\\\")].properties.value\",\"columnid\":\"autovacuum\"},{\"path\":\"$.value[?(@.name==\\\"autovacuum_max_workers\\\")].properties.value\",\"columnid\":\"autovacuum_max_workers\"},{\"path\":\"$.value[?(@.name==\\\"autovacuum_vacuum_cost_limit\\\")].properties.value\",\"columnid\":\"autovacuum_vacuum_cost_limit\"},{\"path\":\"$.value[?(@.name==\\\"autovacuum_vacuum_cost_delay\\\")].properties.value\",\"columnid\":\"autovacuum_vacuum_cost_delay\"},{\"path\":\"$.value[?(@.name==\\\"autovacuum_vacuum_threshold\\\")].properties.value\",\"columnid\":\"autovacuum_vacuum_threshold\"},{\"path\":\"$.value[?(@.name==\\\"autovacuum_vacuum_scale_factor\\\")].properties.value\",\"columnid\":\"autovacuum_vacuum_scale_factor\"}]}}]}",
        "size": 4,
        "title": "Autovacuum current configuration",
        "queryType": 12,
        "gridSettings": {
          "sortBy": [
            {
              "itemKey": "autovacuum_vacuum_scale_factor",
              "sortOrder": 2
            }
          ]
        },
        "sortBy": [
          {
            "itemKey": "autovacuum_vacuum_scale_factor",
            "sortOrder": 2
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimary",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "avconfiguration",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 1,
      "content": {
        "json": ">**Note:** The configuration mentioned above pertains to server-level settings and does not consider any table-level settings. If you have set specific autovacuum settings at the table level, please note that these will take precedence over the server-level settings.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimary",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "autovacuum configuration note"
    },
    {
      "type": 1,
      "content": {
        "json": "{generate_autovacuum_max_workers_warning}",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "generate_autovacuum_max_workers_warning",
          "comparison": "isNotEqualTo",
          "value": "None"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "autovacuum_max_workers_warning_message"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "tabStyle": "bigger",
        "links": [
          {
            "id": "658f22a6-f71a-4f7e-add6-445c7c80b66b",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Bloat",
            "subTarget": "bloat",
            "style": "link"
          },
          {
            "id": "daa324f1-0d29-4dac-b76b-1447edfe6b0d",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Tuples",
            "subTarget": "tupcount",
            "style": "link"
          },
          {
            "id": "e48395ed-d0a2-424d-8951-744764988284",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Vacuum and analyze",
            "subTarget": "vacuumanalyze",
            "style": "link"
          },
          {
            "id": "5187a9fe-7e5c-4223-bcdf-e4e229bcffdf",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Autovacuum workers",
            "subTarget": "vacuumworkers",
            "style": "link"
          },
          {
            "id": "cb5d1854-1f79-4960-8b3c-295dade842e3",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Autovacuum per table",
            "subTarget": "vacuumpertablehistory",
            "style": "link"
          },
          {
            "id": "1268adb1-c7a8-44b1-ad0e-43c0b137e8ce",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Enhanced metrics",
            "subTarget": "txidmetric",
            "style": "link"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "QualifiedDatabasesCount",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "name": "AV Monitoring Tabs"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "title": "Bloat ratio for {Database} database(s)",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "#### Guidelines for the bloat ratio formula:\r\n\r\n The bloat ratio can be determined by applying the following formula: dead_tuples/live_tuples*100. However, caution should be exercised when interpreting the results of this formula as it may produce skewed outcomes that exceed 100%.\r\n\r\n- A ratio of 50% is cause for concern as it suggests that dead_tuples account for half of the live_tuples.\r\n- When the ratio reaches 100%, it implies that the number of dead_tuples is equal to the number of live_tuples, which is a sign of significant bloat.\r\n- Moreover, if the ratio surpasses 100%, it indicates that there are more dead_tuples than live_tuples, which is a clear indication of severe bloat.",
              "style": "info"
            },
            "name": "Bloatration Guidelines"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,DatabaseName\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal(LiveTuplesCluster)*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n| project TimeGenerated,DatabaseName, BloatRatio\r\n//|summarize BloatRatio=max(BloatRatio) by bin (TimeGenerated,5m),DatabaseName\r\n//|summarize BloatRatio=max(BloatRatio) by bin (TimeGenerated,graphgrain),DatabaseName\r\n|make-series BloatRatio=max(BloatRatio) on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName",
              "size": 0,
              "aggregation": 2,
              "showAnnotations": true,
              "title": "Bloat ratio by database. Data is plotted at a granularity of {ChartGrain}",
              "timeBrushParameterName": "TimeRange",
              "timeBrushExportOnlyWhenBrushed": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "linechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Start_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "Start_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    },
                    "numberFormat": {
                      "unit": 0,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "End_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "End_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  },
                  {
                    "columnMatch": "BloatRatio",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  }
                ]
              },
              "sortBy": [],
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "DatabaseName_s"
                },
                "leftContent": {
                  "columnMatch": "BloatRatio",
                  "formatter": 3,
                  "formatOptions": {
                    "palette": "blue"
                  },
                  "numberFormat": {
                    "unit": 1,
                    "options": {
                      "style": "decimal"
                    }
                  }
                },
                "rightContent": {
                  "columnMatch": "BloatRatio"
                },
                "secondaryContent": {
                  "columnMatch": "BloatRatio"
                },
                "showBorder": false,
                "sortCriteriaField": "BloatRatio",
                "sortOrderField": 2
              },
              "chartSettings": {
                "group": "DatabaseName",
                "createOtherGroup": 30,
                "showLegend": true,
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 1,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                }
              }
            },
            "conditionalVisibility": {
              "parameterName": "Database",
              "comparison": "isEqualTo",
              "value": "All"
            },
            "name": "checks at top level section for visibility"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "\r\nlet graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,SchemaName\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m), SchemaName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal(LiveTuplesCluster)*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n| project TimeGenerated, SchemaName, BloatRatio\r\n|make-series BloatRatio=max(BloatRatio) default=0 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName",
              "size": 0,
              "aggregation": 2,
              "showAnnotations": true,
              "title": "Bloat Ratio by Schema. Data is plotted at a granularity of {ChartGrain}",
              "timeBrushParameterName": "TimeRange",
              "timeBrushExportOnlyWhenBrushed": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "linechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Start_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "Start_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    },
                    "numberFormat": {
                      "unit": 0,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "End_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "End_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  },
                  {
                    "columnMatch": "BloatRatio",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  }
                ]
              },
              "sortBy": [],
              "chartSettings": {
                "group": "SchemaName",
                "createOtherGroup": 100,
                "showLegend": true,
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 1,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                }
              }
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "QualifiedSchemaCount",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "Bloat Ratio - Database"
          },
          {
            "type": 1,
            "content": {
              "json": "#### Monitor the database bloat ratio for all databases on server. A High bloat ratio for any individual database is not recommended. If you identify a database with a high bloat ratio then select that database from the drop down in the troubleshooting guide to further drill down and analyze.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "Database",
              "comparison": "isEqualTo",
              "value": "All"
            },
            "name": "guidelines for monitoring the database bloat"
          },
          {
            "type": 1,
            "content": {
              "json": "#### Please monitor the bloat ratio at the individual schema level for the selected {Database} database. If a schema with a high bloat ratio is detected, it may be due to one of the following reasons, which require further investigation:\r\n\r\n- The presence of autovacuum blockers. Look for any warnings in this troubleshooting guide regarding autovacuum blockers, and remove any that are found.\r\n- If no blockers are present, and the bloat ratio is still high, it may be because the autovacuum workers are not able to keep up with the workload. In this case, it is recommended to tune the autovacuum settings.\r\n\r\nFor more information on how to tune autovacuum, please refer to the following article: https://learn.microsoft.com/azure/postgresql/flexible-server/how-to-autovacuum-tuning",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "isFlexServer",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "how to monitor bloat at schema levels"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "bloat"
        }
      ],
      "name": "bloat ratio guideline param checks"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "tabs",
              "links": [
                {
                  "id": "ea04fb8f-dbf1-4eb6-bdb8-f835b59f6579",
                  "cellValue": "tuptab",
                  "linkTarget": "parameter",
                  "linkLabel": "Live and dead tuples",
                  "subTarget": "live",
                  "style": "link"
                },
                {
                  "id": "3eb571c9-8116-426f-9655-1cd7cde73f80",
                  "cellValue": "tuptab",
                  "linkTarget": "parameter",
                  "linkLabel": "Inserted, updated and deleted tuples",
                  "subTarget": "insert",
                  "style": "link"
                }
              ]
            },
            "name": "links for checking separate tuple counts"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "details for how to expand each group"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,DatabaseName,SchemaName\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m)\r\n| make-series ['live'] = max(LiveTuples), ['dead'] = max(DeadTuples) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tuple state for {Database} database(s). Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "DatabaseName",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed",
                            "compositeBarSettings": {
                              "labelText": "",
                              "columnSettings": []
                            }
                          }
                        }
                      ],
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Live & Dead Tuple State"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,DatabaseName,SchemaName\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| make-series LiveTuples=max(LiveTuples) default=-1  , DeadTuples=max(DeadTuples) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,LiveTuples, DeadTuples\r\n| where LiveTuples!=-1 or DeadTuples!=-1\r\n| extend LiveTuples = tolong(LiveTuples), DeadTuples=tolong(DeadTuples), TimeGenerated=todatetime(TimeGenerated)\r\n| extend LiveToDeadTupRatio=round(100*DeadTuples/LiveTuples)\r\n| project ['time generated'] = TimeGenerated, ['database'] = DatabaseName, ['live tuples'] = LiveTuples, ['dead tuples'] = DeadTuples, ['live to dead ratio'] = LiveToDeadTupRatio\r\n| order by ['time generated'], ['dead tuples'] desc ",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "LiveTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "LiveToDeadTupRatio",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DatabaseName_s",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "conditionals for tuple section and what warnings should show"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,LiveRowsCount,DeadRowsCount\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series LiveTuples=max(LiveTuples), DeadTuples=max(DeadTuples) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "title": "Tuple State for {Database} database. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database "
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,SchemaName\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m),SchemaName\r\n| make-series LiveTuples=max(LiveTuples) default=-1 , DeadTuples=max(DeadTuples) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName\r\n| mv-expand TimeGenerated,LiveTuples, DeadTuples\r\n| where LiveTuples!=-1 or DeadTuples!=-1\r\n| extend TimeGenerated=todatetime(TimeGenerated),LiveTuples = tolong(LiveTuples), DeadTuples=tolong(DeadTuples)\r\n| extend LiveToDeadTupRatio=round(100*DeadTuples/LiveTuples)\r\n| project TimeGenerated, SchemaName, LiveTuples, DeadTuples, LiveToDeadTupRatio\r\n| order by TimeGenerated,DeadTuples desc\r\n",
                    "size": 1,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "LiveTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "LiveToDeadTupRatio",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ]
                      }
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database grid"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "To ensure optimal performance of the server, it's recommended to monitor the live and dead tuple counts for all databases. If a database is identified with a high number of dead tuples, it's suggested to select the identified database from the drop-down menu in the troubleshooting guide to further analyze and drill down into the issue.\r\n\r\nBy focusing on the identified database, it's possible to investigate the cause of the high dead tuple count and take corrective measures to optimize performance. Therefore, it's essential to keep track of the tuple counts and identify any databases that may require further analysis.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "how to get optimal performance on the server"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "To ensure optimal performance of the selected **{Database}** database, it's recommended to monitor the live, dead, inserted, deleted, and updated tuple counts at the schema level. If a schema is identified with a high number of dead tuples, and there is a trend where the dead tuples seem to be increasing over time, it's suggested to check the bloat ratio for both the database and schema.\r\n\r\nA high count of dead tuples may lead to a high bloat ratio, which can impact performance. Therefore, it's essential to keep track of the tuple counts and investigate any increases in dead tuples to ensure that the bloat ratio stays within an acceptable range.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isNotEqualTo",
                    "value": "All"
                  },
                  "name": "how to get optimal performance on the selected database"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "tuptab",
              "comparison": "isEqualTo",
              "value": "live"
            },
            "name": "Live"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "details on how to expand second tab"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series ['inserted'] = max(TuplesInserted), ['updated'] = max(TuplesUpdated), ['deletedinserted'] = max(TuplesDeleted) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tuple state for {Database} database(s). Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "DatabaseName",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed",
                            "compositeBarSettings": {
                              "labelText": "",
                              "columnSettings": []
                            }
                          }
                        }
                      ],
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Live & Dead Tuple State for second tab"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m),DatabaseName\r\n|make-series TuplesInserted=max(TuplesInserted) default=-1, TuplesUpdated=max(TuplesUpdated) default=-1, TuplesDeleted=max(TuplesDeleted) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,TuplesInserted, TuplesUpdated,TuplesDeleted\r\n| where TuplesInserted !=-1 or TuplesUpdated !=-1 or TuplesDeleted !=-1\r\n| extend TimeGenerated=todatetime(TimeGenerated), TuplesInserted = tolong(TuplesInserted), TuplesUpdated=tolong(TuplesUpdated),TuplesDeleted=tolong(TuplesDeleted)\r\n| project ['time generated'] = TimeGenerated, ['database'] = DatabaseName, ['inserted'] = TuplesInserted, ['updated'] = TuplesUpdated , ['deleted'] = TuplesDeleted\r\n| order by ['time generated'] desc ",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "database",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "inserted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "updated",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "deleted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "database"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "checks for second tab and what warnings to show"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series ['inserted'] = max(TuplesInserted), ['updated'] = max(TuplesUpdated), ['deleted'] = max(TuplesDeleted) on ['time generated'] = TimeGenerated from Start_Time to End_Time step graphgrain ",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tuple state for {Database} database(s). Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "database",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed",
                            "compositeBarSettings": {
                              "labelText": "",
                              "columnSettings": []
                            }
                          }
                        }
                      ],
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "database"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database on second tab"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m), SchemaName\r\n|make-series TuplesInserted=max(TuplesInserted) default=-1, TuplesUpdated=max(TuplesUpdated) default=-1, TuplesDeleted=max(TuplesDeleted) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName\r\n| mv-expand TimeGenerated,TuplesInserted, TuplesUpdated,TuplesDeleted\r\n| where TuplesInserted !=-1 or TuplesUpdated !=-1 or TuplesDeleted !=-1\r\n| extend TuplesInserted = tolong(TuplesInserted), TuplesUpdated=tolong(TuplesUpdated),TuplesDeleted=tolong(TuplesDeleted), TimeGenerated=todatetime(TimeGenerated)\r\n| project ['time generated'] = TimeGenerated, ['schema'] = SchemaName, ['inserted'] = TuplesInserted, ['updated'] = TuplesUpdated , ['deleted'] = TuplesDeleted\r\n| order by ['time generated'] desc ",
                    "size": 1,
                    "aggregation": 2,
                    "timeBrushParameterName": "TimeRange",
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "TuplesInserted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "TuplesUpdated",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "TuplesDeleted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database grid in tab two"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Inserts, updates, and deletes can cause bloat in PostgreSQL, which is when the size of a table or index grows larger than necessary due to data fragmentation and inefficient space utilization. This can negatively impact the performance and efficiency of the database.\r\n\r\nInserts can cause bloat if the table has a high degree of fragmentation, meaning that the table has gaps between existing rows due to deleted rows. These gaps can cause a table to use more disk space than necessary, which can slow down queries that scan the entire table.\r\n\r\nUpdates can also cause bloat because when a row is updated, PostgreSQL does not immediately overwrite the existing row. Instead, it creates a new version of the row, and marks the old version as \"dead.\" This can create fragmentation in the table and contribute to bloat, especially if there are many updates and the table has many indexes.\r\n\r\nDeletes can cause bloat if they leave behind empty space in a table or index. This is because PostgreSQL does not immediately remove the dead rows from the table or index, but rather marks them as \"free space.\" Over time, this can cause a table or index to become fragmented and use more disk space than necessary.\r\n\r\nTo prevent bloat, it is important to regularly vacuum and analyze tables and indexes. ",
                    "style": "info"
                  },
                  "name": "what are some of the main causes of bloat"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "tuptab",
              "comparison": "isEqualTo",
              "value": "insert"
            },
            "name": "Insert"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "tupcount"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "tuple count for the second tab"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "tabs",
              "links": [
                {
                  "id": "4a11b036-17c2-4fb9-ae07-b5258bd36fee",
                  "cellValue": "vacuum-tab",
                  "linkTarget": "parameter",
                  "linkLabel": "Vacuum",
                  "subTarget": "vacuum",
                  "style": "link"
                },
                {
                  "id": "5bba1dca-dd6f-4224-a56e-0b0eaa5d399e",
                  "cellValue": "vacuum-tab",
                  "linkTarget": "parameter",
                  "linkLabel": "Analyze",
                  "subTarget": "analyze",
                  "style": "link"
                }
              ]
            },
            "name": "Vacuum&Analyze"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "expand each group instructions for queries"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,1m)\r\n|make-series ['tables in database'] = max(_Tables_counter), ['tables vacuumed'] = max(_Tables_vacuumed), ['tables autovacuumed'] = max(_Tables_autovacuumed) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Execution of VACUUM on tables in all databases. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_vacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "yellowOrangeRed"
                          }
                        }
                      ]
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Table Vacuumed Execution Count - Cluster"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated, SchemaName,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,1s)\r\n| make-series ['tables in database'] = max(_Tables_counter), ['tables vacuumed'] = max(_Tables_vacuumed), ['tables autovacuumed'] = max(_Tables_autovacuumed) on TimeGenerated from Start_Time to End_Time step graphgrain\r\n\r\n",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Execution of VACUUM on tables in database {Database}. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_vacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "yellowOrangeRed"
                          }
                        }
                      ]
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Table Vacuumed Execution Count - Database"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "##### Column details\r\n\r\n**Total tables** : Total tables that are present in all databases, when Database parameter is set to All, or total tables that are present in the individual database, when a particular database name is selected.\r\n\r\n**Tables vacuumed**: Total tables that are manually vacuumed in all databases, when Database parameter is set to All, or total tables that are manually vacuumed in the individual database, when a particular database name is selected.\r\n\r\n**Tables autovacuumed**: Total tables that are autovacuumed in all databases, when Database parameter is set to All, or total tables that are autovacuumed in the individual database, when a particular database name is selected.\r\n\r\n**Tables autovacuumed [%]**: Tables autovacuumed / total tables * 100\r\n\r\n**Tables never autovacuumed [%]**: Tables never autovacuumed / total tables * 100\r\n",
                    "style": "info"
                  },
                  "name": "Table Vacuumed Execution Coun - Cluster text"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,1s),DatabaseName\r\n|make-series Tables_counter=max(_Tables_counter) default=-1,Tables_vacuumed=max(_Tables_vacuumed) default=-1,Tables_autovacuumed=max(_Tables_autovacuumed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,Tables_counter, Tables_vacuumed,Tables_autovacuumed\r\n| where Tables_counter !=-1 or Tables_vacuumed !=-1 or Tables_autovacuumed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_vacuumed=tolong(Tables_vacuumed),Tables_autovacuumed=tolong(Tables_autovacuumed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autovacuumed= iff(Tables_counter==Tables_autovacuumed,0.0,toreal(Tables_counter-Tables_autovacuumed))\r\n| extend Tables_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,100.00,iff(Tables_autovacuumed < Tables_counter, (toreal(Tables_autovacuumed)/toreal(Tables_counter))*100,100.0))\r\n| extend Tables_never_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,0.0,iff(Tables_never_autovacuumed < Tables_counter, (toreal(Tables_never_autovacuumed)/toreal (Tables_counter))*100,100.0))\r\n| project ['time generated'] = TimeGenerated, ['database'] = DatabaseName, ['tables in database'] = Tables_counter, ['tables vacuumed'] = Tables_vacuumed, ['tables autovacuumed'] = Tables_autovacuumed, ['tables autovacuumed ratio'] = Tables_autovacuumed_pct, ['tables never autovacuumed'] = Tables_never_autovacuumed, ['tables never autovacuumed ratio'] = Tables_never_autovacuumed_pct\r\n| order by ['time generated'], ['tables never autovacuumed']  desc",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "tables autovacuumed ratio",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "tables never autovacuumed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "tables never autovacuumed ratio",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Table Vacuumed Execution Count  - Cluster grid"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount,SchemaName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,5m),SchemaName \r\n|make-series Tables_counter=max(_Tables_counter) default=-1,Tables_vacuumed=max(_Tables_vacuumed) default=-1,Tables_autovacuumed=max(_Tables_autovacuumed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName \r\n| mv-expand TimeGenerated,Tables_counter, Tables_vacuumed,Tables_autovacuumed\r\n| where Tables_counter !=-1 or Tables_vacuumed !=-1 or Tables_autovacuumed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_vacuumed=tolong(Tables_vacuumed),Tables_autovacuumed=tolong(Tables_autovacuumed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autovacuumed= iff(Tables_counter==Tables_autovacuumed,0.0,toreal(Tables_counter-Tables_autovacuumed))\r\n| extend Tables_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,100.00,iff(Tables_autovacuumed < Tables_counter, (toreal(Tables_autovacuumed)/toreal(Tables_counter))*100,100.0))\r\n| extend Tables_never_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,0.0,iff(Tables_never_autovacuumed < Tables_counter, (toreal(Tables_never_autovacuumed)/toreal (Tables_counter))*100,100.0))\r\n| project TimeGenerated, SchemaName, Tables_counter, Tables_vacuumed, Tables_autovacuumed, Tables_autovacuumed_pct,Tables_never_autovacuumed, Tables_never_autovacuumed_pct\r\n| order by TimeGenerated, Tables_never_autovacuumed desc",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autovacuumed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ]
                      },
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated"
                        },
                        {
                          "columnId": "SchemaName",
                          "label": "Schema Name"
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_vacuumed",
                          "label": "Tables Vacuumed"
                        },
                        {
                          "columnId": "Tables_autovacuumed",
                          "label": "Tables Autovacuumed"
                        },
                        {
                          "columnId": "Tables_autovacuumed_pct",
                          "label": "Tables Autovacuumed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autovacuumed",
                          "label": "Tables Never Autovacuumed"
                        },
                        {
                          "columnId": "Tables_never_autovacuumed_pct",
                          "label": "Tables Never Autovacuumed [Pct]"
                        }
                      ]
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Table Vacuumed Execution Count  - Database gird"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the Total Tables Never Autovacuumed[pct] column for all databases on server. If we identify a database with high Total Tables Never Autovacuumed[pct] value then suggest to select the identified database from the drop down in the troubleshooting guide to further drill down and analyze.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "what to monitor to avoid an av issue"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the total Tables Never Autovacuumed[pct] column at schema level for selected {Database} database.<br>\r\n\r\nIf you have a high Tables Never Autovacuumed[pct] value, follow the suggestions below for further analysis:\r\n\r\n\tIt's important to consider the workload when tuning autovacuum parameters as some tables may have high DML activity while others may not have any activity at all. Therefore, it's crucial to understand the workload dynamics before making any adjustments.\r\n\r\n<h5>Scenario 1:</h5>\r\n\r\nThe server might have a large number of databases and autovacuum is not able to catch up and  vacuum all tables across all databases. Please refer https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning on suggestions to tune the server.\r\n\r\n<h5>Scenario 2:</h5>\r\n\r\nThe autovacuum is cleaning the dead tuples slowly. Please refer https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning on suggestions to speed up and tune.\r\n\r\n<h5>Scenario 3:</h5>\r\n\r\nAutovacuum workers could potentially be occupied with larger tables, leaving insufficient time to clean other tables within the database. Please refer https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning#table-specific-requirements on suggestions for table specific requirements.\r\n\r\n<h5>Scenario 4:</h5>\r\n\r\nTotal Tables Never Autovacuumed[pct] value found to be zero. Follow the suggestions below for further analysis:\r\n\r\nThe server's autovacuum parameter could be disabled. To determine if this is the case, check the error messages at the top of the troubleshooting guide for any indication that autovacuum has been turned off on the server.\r\n\r\n<h5>Scenario 5:</h5>\r\n\r\nAfter upgrading your PostgreSQL database server to a higher version or migrating to a new server, it is crucial to perform a database-wide manual vacuum before commencing your workload on the server. This is done to ensure that the statistics for tables are up to date and the query plans are optimized.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "more information regarding monitoring av"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "vacuum-tab",
              "comparison": "isEqualTo",
              "value": "vacuum"
            },
            "name": "vacuum"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "another item explaining that the grid can be expanded"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nlet DB_NAME =iff('{Database}'== 'All', '', '{Database}');\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated, TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m)\r\n| make-series ['tables in database'] = max(_Tables_counter), ['tables analyzed'] = max(_Tables_analyzed), ['tables autoanalyzed'] = max(_Tables_autoanalyzed) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Execution of ANALYZE on tables in all databases. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_analyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed"
                          }
                        }
                      ],
                      "sortBy": [
                        {
                          "itemKey": "$._Tables_counter",
                          "sortOrder": 2
                        }
                      ],
                      "labelSettings": [
                        {
                          "columnId": "_Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "_Tables_analyzed",
                          "label": "Tables Analyzed"
                        },
                        {
                          "columnId": "_Tables_autoanalyzed",
                          "label": "Tables Auto Analyzed"
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "$._Tables_counter",
                        "sortOrder": 2
                      }
                    ],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Tables Analyzed Execution Count  - Clusters"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount,DatabaseName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m),DatabaseName\r\n|make-series ['tables in database'] = max(_Tables_counter), ['tables analyzed'] = max(_Tables_analyzed), ['tables autoanalyzed'] = max(_Tables_autoanalyzed) on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Execution of ANALYZE on tables in database {Database}. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_analyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed"
                          }
                        }
                      ],
                      "sortBy": [
                        {
                          "itemKey": "$._Tables_counter",
                          "sortOrder": 2
                        }
                      ],
                      "labelSettings": [
                        {
                          "columnId": "_Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "_Tables_analyzed",
                          "label": "Tables Analyzed"
                        },
                        {
                          "columnId": "_Tables_autoanalyzed",
                          "label": "Tables Auto Analyzed"
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "$._Tables_counter",
                        "sortOrder": 2
                      }
                    ]
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tables Analyzed Execution Count - Databases"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "##### Column details\r\n\r\n**Total tables** : Total tables that are present in all databases, when Database parameter is set to All, or total tables that are present in the individual database, when a particular database name is selected.\r\n\r\n**Tables analyzed**: Total tables that are manually analyzed in all databases, when Database parameter is set to All, or total tables that are manually analyzed in the individual database, when a particular database name is selected.\r\n\r\n**Tables autoanalyzed**: Total tables that are autoanalyzed in all databases, when Database parameter is set to All, or total tables that are autoanalyzed in the individual database, when a particular database name is selected.\r\n\r\n**Tables autoanalyzed [%]**: Tables autoanalyzed / total tables * 100\r\n\r\n**Tables never autoanalyzed [%]**: Tables never autoanalyzed / total tables * 100\r\n",
                    "style": "info"
                  },
                  "name": "Tables Analyzed Execution Count cluster texts"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated, TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount,DatabaseName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m),DatabaseName\r\n|make-series Tables_counter=max(_Tables_counter) default=-1 ,Tables_analyzed=max(_Tables_analyzed) default=-1,Tables_autoanalyzed=max(_Tables_autoanalyzed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,Tables_counter, Tables_analyzed,Tables_autoanalyzed\r\n| where Tables_counter !=-1 or Tables_analyzed !=-1 or Tables_autoanalyzed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_analyzed=tolong(Tables_analyzed),Tables_autoanalyzed=tolong(Tables_autoanalyzed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autoanalyzed=Tables_counter-Tables_autoanalyzed\r\n| extend Tables_autoanalyzed_pct= iff(Tables_autoanalyzed < Tables_counter, (toreal(Tables_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| extend Tables_never_autoanalyzed_pct= iff(Tables_never_autoanalyzed < Tables_counter, (toreal(Tables_never_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| project TimeGenerated, DatabaseName, Tables_counter, Tables_analyzed, Tables_autoanalyzed, Tables_autoanalyzed_pct,Tables_never_autoanalyzed, Tables_never_autoanalyzed_pct\r\n| order by TimeGenerated, Tables_never_autoanalyzed_pct desc",
                    "size": 1,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DatabaseName_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ]
                      },
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated "
                        },
                        {
                          "columnId": "DatabaseName",
                          "label": "Database Name"
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_analyzed",
                          "label": "Tables Analyzed "
                        },
                        {
                          "columnId": "Tables_autoanalyzed",
                          "label": "Tables Autoanalyzed"
                        },
                        {
                          "columnId": "Tables_autoanalyzed_pct",
                          "label": "Tables Autoanalyzed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed",
                          "label": "Tables Never Autoanalyzed "
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed_pct",
                          "label": "Tables Never Autoanalyzed [Pct]"
                        }
                      ]
                    },
                    "sortBy": []
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Tables Analyzed Execution Count for cluster grids"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated, TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount,SchemaName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m),SchemaName\r\n|make-series Tables_counter=max(_Tables_counter) default=-1 ,Tables_analyzed=max(_Tables_analyzed) default=-1,Tables_autoanalyzed=max(_Tables_autoanalyzed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName\r\n| mv-expand TimeGenerated,Tables_counter, Tables_analyzed,Tables_autoanalyzed\r\n| where Tables_counter !=-1 or Tables_analyzed !=-1 or Tables_autoanalyzed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_analyzed=tolong(Tables_analyzed),Tables_autoanalyzed=tolong(Tables_autoanalyzed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autoanalyzed=Tables_counter-Tables_autoanalyzed\r\n| extend Tables_autoanalyzed_pct= iff(Tables_autoanalyzed < Tables_counter, (toreal(Tables_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| extend Tables_never_autoanalyzed_pct= iff(Tables_never_autoanalyzed < Tables_counter, (toreal(Tables_never_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| project TimeGenerated, SchemaName, Tables_counter, Tables_analyzed, Tables_autoanalyzed, Tables_autoanalyzed_pct,Tables_never_autoanalyzed, Tables_never_autoanalyzed_pct\r\n| order by TimeGenerated, Tables_never_autoanalyzed_pct desc",
                    "size": 1,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ]
                      },
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated"
                        },
                        {
                          "columnId": "SchemaName",
                          "label": "Schema Name"
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_analyzed",
                          "label": "Tables Analyzed"
                        },
                        {
                          "columnId": "Tables_autoanalyzed",
                          "label": "Tables Autoanalyzed"
                        },
                        {
                          "columnId": "Tables_autoanalyzed_pct",
                          "label": "Tables Autoanalyzed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed",
                          "label": "Tables Never Autoanalyzed "
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed_pct",
                          "label": "Tables Never Autoanalyzed [Pct]"
                        }
                      ]
                    },
                    "sortBy": []
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": " Tables Analyzed Execution Count for the database grids"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the Total Tables Never Autoanalyzed[pct] column for all databases on server. If we identify a database with a high Total Tables Never Autoanalyzed[pct] value then suggest to select the identified database from the drop down in the troubleshooting guide to further drill down and analyze.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "identify databases from the dropdown"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the Total Tables Never Autoanalyzed[pct] column at schema level for selected {Database} database.\r\n\r\nHigh Total Tables Never Autoanalyzed[pct] value found. Follow the suggestions below for further analysis:\r\n\r\n1. Please consider making autovacuum_analyze_scale_factor and autovacuum_analyze_threshold more aggressive after carefully understanding the workload. Please refer to https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning for suggestions.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "monitor the total tables that have not been autoanalyzed"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "vacuum-tab",
              "comparison": "isEqualTo",
              "value": "analyze"
            },
            "name": "analyze"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumanalyze"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "vacuum & analyze group section"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 9,
            "content": {
              "version": "KqlParameterItem/1.0",
              "crossComponentResources": [
                "{Resource}"
              ],
              "parameters": [
                {
                  "id": "ce0608cf-c3d2-4028-a10d-99de6533df91",
                  "version": "KqlParameterItem/1.0",
                  "name": "IsAVDataExists",
                  "type": 1,
                  "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| where database =='{Database}'\r\n|limit 5\r\n|count\r\n| extend avdata = iff(Count>0,'Yes','No')\r\n|project avdata",
                  "crossComponentResources": [
                    "{Resource}"
                  ],
                  "isHiddenWhenLocked": true,
                  "queryType": 0,
                  "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                }
              ],
              "style": "pills",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers"
            },
            "conditionalVisibility": {
              "parameterName": "x",
              "comparison": "isEqualTo",
              "value": "y"
            },
            "name": "conditional check to see if autovacuum execution should show"
          },
          {
            "type": 1,
            "content": {
              "json": "#### To view information about autovacuum execution, select a database parameter at the top of the troubleshooting guide.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "Database",
              "comparison": "isEqualTo",
              "value": "All"
            },
            "name": "check what the setting of databases is to determine rendering"
          },
          {
            "type": 1,
            "content": {
              "json": "#### It appears that there are no autovacuum entries in the PostgreSQL Server logs within the specified time range, or that the logs are not being sent to the Log Analytics workspace. Please refer to the error message at the top of the troubleshooting guide for further details.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "inform that there are no autovacuum entries"
          },
          {
            "type": 1,
            "content": {
              "json": "#### The grouping order for the grid view is as follows:\r\n\r\n**Database -> Schema -> Table**",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "the grouping order for the grid is as follows information"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| where database =='{Database}'\r\n| summarize ['execution count'] = count() by bin (TimeGenerated, 1m), schema\r\n| project-rename ['time generated'] = TimeGenerated\r\n| order by ['time generated'], ['execution count']",
              "size": 1,
              "title": "Execution of autovacuum on tables in database {Database}",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "piechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Group",
                    "formatter": 1
                  },
                  {
                    "columnMatch": "count_",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ],
                "rowLimit": 10000,
                "hierarchySettings": {
                  "treeType": 1,
                  "groupBy": [
                    "database",
                    "schema",
                    "table"
                  ]
                }
              },
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "database",
                  "formatter": 1
                },
                "subtitleContent": {
                  "columnMatch": "schema",
                  "formatter": 1
                },
                "leftContent": {
                  "columnMatch": "count_",
                  "formatter": 12,
                  "formatOptions": {
                    "palette": "auto"
                  },
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                },
                "rightContent": {
                  "columnMatch": "table",
                  "formatter": 1
                },
                "secondaryContent": {
                  "columnMatch": "TimeGenerated"
                },
                "showBorder": true,
                "sortCriteriaField": "count_",
                "sortOrderField": 2
              },
              "chartSettings": {
                "showLegend": true,
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 17,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                }
              },
              "mapSettings": {
                "locInfo": "LatLong",
                "sizeSettings": "count_",
                "sizeAggregation": "Sum",
                "legendMetric": "count_",
                "legendAggregation": "Sum",
                "itemColorSettings": {
                  "type": "heatmap",
                  "colorAggregation": "Sum",
                  "nodeColorField": "count_",
                  "heatmapPalette": "greenRed"
                }
              }
            },
            "customWidth": "50",
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "conditional checks for the final section showing"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| project TimeGenerated, database, schema,table\r\n| where database !in('azure_sys','azure_maintenance')\r\n| summarize ['execution count'] = count() by bin (TimeGenerated,graphgrain), schema, table\r\n| project-rename ['time generated'] = TimeGenerated \r\n| order by ['time generated'], ['execution count']",
              "size": 1,
              "title": "Execution of autovacuum on tables in database {Database} by schema",
              "showExportToExcel": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "table",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Group",
                    "formatter": 1
                  },
                  {
                    "columnMatch": "count_",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ],
                "rowLimit": 10000,
                "filter": true,
                "hierarchySettings": {
                  "treeType": 1,
                  "groupBy": [
                    "schema",
                    "table"
                  ],
                  "expandTopLevel": false
                }
              },
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "database",
                  "formatter": 1
                },
                "subtitleContent": {
                  "columnMatch": "schema",
                  "formatter": 1
                },
                "leftContent": {
                  "columnMatch": "count_",
                  "formatter": 12,
                  "formatOptions": {
                    "palette": "auto"
                  },
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                },
                "rightContent": {
                  "columnMatch": "table",
                  "formatter": 1
                },
                "secondaryContent": {
                  "columnMatch": "TimeGenerated"
                },
                "showBorder": true,
                "sortCriteriaField": "count_",
                "sortOrderField": 2
              },
              "chartSettings": {
                "createOtherGroup": 100,
                "showLegend": true
              },
              "mapSettings": {
                "locInfo": "LatLong",
                "sizeSettings": "count_",
                "sizeAggregation": "Sum",
                "legendMetric": "count_",
                "legendAggregation": "Sum",
                "itemColorSettings": {
                  "type": "heatmap",
                  "colorAggregation": "Sum",
                  "nodeColorField": "count_",
                  "heatmapPalette": "greenRed"
                }
              }
            },
            "customWidth": "50",
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "warnings for the final section and parameters which check for them"
          },
          {
            "type": 1,
            "content": {
              "json": "The graph and grid view displayed above present valuable insights into the frequency of autovacuum worker executions within a database.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "the graph and grid displayed above information"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumworkers"
        }
      ],
      "name": "autovacuum workers in progress"
    },
    {
      "type": 1,
      "content": {
        "json": "**Note:** The information displayed in this tab is based on the PostgreSQL logs available in your Log Analytics workspace, which are generated when the `log_autovacuum_min_duration` parameter is set. If `log_autovacuum_min_duration` is not set, the information in this tab will not be visible.\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "log_autovacuum_min_duration_message"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| extend tuples_removed = extract(\"tuples: (\\\\d+) removed\", 1, Message)\r\n| extend tuples_remain = extract(\"tuples: \\\\d+ removed, (\\\\d+) remain\", 1, Message)\r\n| extend tuples_dead_but_not_removed = extract(\"remain, (\\\\d+) are dead but not yet removable\", 1, Message)\r\n| extend oldest_xmin = extract(\"oldest xmin: (\\\\d+)\", 1, Message)\r\n| extend elapsed_time = extract(\"elapsed: (\\\\d+\\\\.\\\\d+) s\", 1, Message)\r\n| project TimeGenerated, database, schema,table, tuples_removed, tuples_remain, tuples_dead_but_not_removed, oldest_xmin, elapsed_time, Message\r\n| where database !in('azure_sys','azure_maintenance')\r\n| summarize VacuumCount=count() by database, schema,table\r\n| extend database_table = strcat(database,'.',schema,'.',table)\r\n| top 10 by VacuumCount",
        "size": 0,
        "title": "Top tables by vacuum activity",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "piechart",
        "chartSettings": {
          "group": "database_table",
          "createOtherGroup": 10
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "customWidth": "33",
      "name": "avhistorypiechart"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| extend tuples_dead_but_not_removed = extract(\"remain, (\\\\d+) are dead but not yet removable\", 1, Message)\r\n| where database !in('azure_sys','azure_maintenance')\r\n| summarize round(avg(tolong(tuples_dead_but_not_removed))) by database, schema,table\r\n| extend database_table = strcat(database,'.',schema,'.',table)\r\n| where avg_tuples_dead_but_not_removed>0\r\n| top 10 by avg_tuples_dead_but_not_removed\r\n",
        "size": 0,
        "title": "Top tables by non-removable dead tuples",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "piechart",
        "chartSettings": {
          "yAxis": [
            "avg_tuples_dead_but_not_removed"
          ],
          "group": "database_table",
          "createOtherGroup": 10
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "customWidth": "33",
      "name": "avtuplesremovehistorypiechart"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| extend elapsed_time = extract(\"elapsed: (\\\\d+\\\\.\\\\d+) s\", 1, Message)\r\n| where database !in('azure_sys','azure_maintenance')\r\n| summarize avg(round(todecimal(elapsed_time),2)) by database, schema,table\r\n| extend database_table = strcat(database,'.',schema,'.',table)\r\n| top 10 by avg_elapsed_time\r\n",
        "size": 0,
        "title": "Top tables by vacuum duration",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "visualization": "piechart",
        "chartSettings": {
          "group": "database_table",
          "createOtherGroup": 10,
          "ySettings": {
            "numberFormatSettings": {
              "unit": 24,
              "options": {
                "style": "decimal",
                "useGrouping": true
              }
            }
          }
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "customWidth": "33",
      "name": "avpiechartbyelapsedtime"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Daily aggregated autovacuum history\r\n\r\nEach row in this grid represents a single day, and the columns provide various aggregated details about the autovacuum activities that occurred on that day. This can include information such as the total number of autovacuum processes initiated, the average duration of these processes, the tables that were involved, and so on.\r\n\r\nIn addition to providing a daily overview, this grid view also offers a detailed view for each day. When you select a row in the grid, a **“Detailed autovacuum activity”** will appear. This detailed grid displays each individual autovacuum activity that occurred on the selected day.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "Autovacuum History Grid view text"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let graphgrain=1d;\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| extend tuples_removed = extract(\"tuples: (\\\\d+) removed\", 1, Message)\r\n| extend tuples_remain = extract(\"tuples: \\\\d+ removed, (\\\\d+) remain\", 1, Message)\r\n| extend tuples_dead_but_not_removed = extract(\"remain, (\\\\d+) are dead but not yet removable\", 1, Message)\r\n| extend oldest_xmin = extract(\"oldest xmin: (\\\\d+)\", 1, Message)\r\n| extend elapsed_time = extract(\"elapsed: (\\\\d+\\\\.\\\\d+) s\", 1, Message)\r\n| project TimeGenerated, database, schema,table, tuples_removed, tuples_remain, tuples_dead_but_not_removed, oldest_xmin, elapsed_time, Message\r\n| where database !in('azure_sys','azure_maintenance')\r\n| summarize ['vacuum count'] = count(), ['tuples removed'] = round(avg(tolong(tuples_removed))), ['tuples remain'] = round(avg(tolong(tuples_remain))), ['tuples dead but not removed'] = round(avg(tolong(tuples_dead_but_not_removed))), ['elapsed time'] = round(avg(todecimal(elapsed_time)),2) by bin(TimeGenerated, graphgrain), database, schema, table\r\n| project-rename ['time generated'] = TimeGenerated\r\n| order by ['time generated']",
        "size": 0,
        "exportedParameters": [
          {
            "fieldName": "time generated",
            "parameterName": "AVHistoryTime",
            "parameterType": 1
          },
          {
            "fieldName": "database",
            "parameterName": "AVHistoryDatabase",
            "parameterType": 1
          },
          {
            "fieldName": "schema",
            "parameterName": "AVHistorySchema",
            "parameterType": 1
          },
          {
            "fieldName": "table",
            "parameterName": "AVHistoryTable",
            "parameterType": 1
          },
          {
            "parameterName": "All",
            "parameterType": 1
          }
        ],
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "time generated",
              "formatter": 6
            },
            {
              "columnMatch": "vacuum count",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "tuples removed",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "tuples remain",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "tuples dead but not removed",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal",
                  "useGrouping": false
                }
              }
            },
            {
              "columnMatch": "elapsed time",
              "formatter": 0,
              "numberFormat": {
                "unit": 24,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "tuples dead but nor removed",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ],
          "rowLimit": 10000,
          "filter": true,
          "sortBy": [
            {
              "itemKey": "time generated",
              "sortOrder": 2
            }
          ]
        },
        "sortBy": [
          {
            "itemKey": "time generated",
            "sortOrder": 2
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "avpertablehistory"
    },
    {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let AVDate = todatetime('{AVHistoryTime}');\r\nlet formatAVData = format_datetime(AVDate, \"yyyy-MM-dd\");\r\nlet AVDatabase='{AVHistoryDatabase}';\r\nlet AVSchema='{AVHistorySchema}';\r\nlet AVTable='{AVHistoryTable}';\r\n//print AVDate, formatAVData, AVDatabase, AVSchema, AVTable\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| extend tuples_removed = extract(\"tuples: (\\\\d+) removed\", 1, Message)\r\n| extend tuples_remain = extract(\"tuples: \\\\d+ removed, (\\\\d+) remain\", 1, Message)\r\n| extend tuples_dead_but_not_removed = extract(\"remain, (\\\\d+) are dead but not yet removable\", 1, Message)\r\n| extend elapsed_time = extract(\"elapsed: (\\\\d+\\\\.\\\\d+) s\", 1, Message)\r\n| project tostring(TimeGenerated), database, schema,table, ['tuples removed']= tuples_removed, ['tuples remain']= tuples_remain, ['tuples dead but not removed'] = tuples_dead_but_not_removed, ['elapsed time'] = elapsed_time, ['autovacuum log'] = Message\r\n| where TimeGenerated contains tostring(formatAVData) and database ==AVDatabase and schema==AVSchema and table==AVTable\r\n| project-rename ['time generated'] = TimeGenerated\r\n| order by ['time generated']",
        "size": 0,
        "title": "Detailed autovacuum activity",
        "showExportToExcel": true,
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "crossComponentResources": [
          "{Resource}"
        ],
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "time generated",
              "formatter": 6
            },
            {
              "columnMatch": "tuples removed",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "tuples remain",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "tuples dead but not removed",
              "formatter": 0,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "elapsed time",
              "formatter": 0,
              "numberFormat": {
                "unit": 24,
                "options": {
                  "style": "decimal"
                }
              }
            }
          ],
          "rowLimit": 10000
        },
        "sortBy": []
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "AVHistoryTime",
          "comparison": "isNotEqualTo"
        }
      ],
      "name": "avpertablehistorysubgrid"
    },
    {
      "type": 1,
      "content": {
        "json": "| Column name                   | Description                                                                                             |\r\n|-------------------------------|---------------------------------------------------------------------------------------------------------|\r\n| database                      | The name of the database on which the autovacuum operation was performed.                              |\r\n| schema                        | The schema of the table that underwent the autovacuum process.                                          |\r\n| table                         | The name of the table that underwent the autovacuum process.\r\n| vacuum count                         | The count of autovacuum operations summarized.                                             |\r\n| tuples removed                | The number of tuples (rows) that were removed during the autovacuum operation.                          |\r\n| tuples remain                 | The number of tuples (rows) that remain after the autovacuum operation.                                 |\r\n| tuples dead but not removed   | The number of tuples (rows) that are marked as dead but have not been physically removed from the table. |\r\n| elapsed time                  | The duration of time taken for the autovacuum operation to complete.                                     |\r\n"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumpertablehistory"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "AVHistoryGridColumnInfo"
    },
    {
      "type": 1,
      "content": {
        "json": "These metrics need to be enabled by the server parameter `metrics.collector_database_activity`. This is a dynamic server parameter that does not require a server restart.\r\n\r\n\r\n- **Maximum Used Transaction IDs** : The \"Maximum Used Transaction IDs\" metric reveals the highest count of transaction identifiers (XIDs) in use by active transactions within the PostgreSQL Flexible Server over a defined period. \r\n\r\n\tWhen the count of active transactions approaches the limit of 2 billion transaction IDs, it's crucial to consider the potential impact on database write operations. PostgreSQL employs a 32-bit transaction identifier, allowing for a maximum of approximately 2 billion unique transaction IDs. If this limit is nearing exhaustion, the database may cease accepting new write transactions. For more information, please visit [PostgreSQL official docs](https://www.postgresql.org/docs/current/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND)\r\n\tTo mitigate the risk of transaction ID exhaustion, consider setting up a metric alert to notify when the \"Maximum Used Transaction IDs\" metric crosses the 1 billion mark. This threshold allows for proactive intervention to address potential issues before they escalate. Additionally, investigate the root cause behind the increased transaction ID utilization by visiting **Autovacuum blockers Troubleshooting Guide**.\r\n- **Oldest Backend Xmin**: \tThe actual value of the oldest xmin. If xmin isn't increasing, it indicates that there are some long-running transactions that can potentially hold dead tuples from being removed.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "txidmetric"
        }
      ],
      "name": "txid metric information"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook0190696b-5f8a-4fc0-8c21-5bf6c6a9ece2",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Traffic-maximum_used_transactionIDs",
            "aggregation": 3
          }
        ],
        "title": "Maximum number of transaction IDs in use.",
        "showCreateAlertRule": true,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "txidmetric"
        }
      ],
      "customWidth": "50",
      "name": "txid metric chart",
      "styleSettings": {
        "showBorder": true
      }
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook0190696b-5f8a-4fc0-8c21-5bf6c6a9ece2",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Activity-oldest_backend_xmin",
            "aggregation": 3
          }
        ],
        "title": "Oldest Backend Xmin",
        "showCreateAlertRule": true,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "txidmetric"
        }
      ],
      "customWidth": "50",
      "name": "oldestxmin metric chart",
      "styleSettings": {
        "showBorder": true
      }
    }
  ],
  "fallbackResourceIds": [],
  "$schema": "https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json"
}