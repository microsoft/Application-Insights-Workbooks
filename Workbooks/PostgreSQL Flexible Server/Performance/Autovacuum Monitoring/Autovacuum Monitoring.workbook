{
  "version": "Notebook/1.0",
  "items": [
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "## Autovacuum Monitoring\r\n\r\nThis troubleshooting guide is designed to assess the health of autovacuum or vacuum on Azure Database for PostgreSQL Flexible Server. During the execution of autovacuum, it removes dead tuples, which can free up disk space and improve query performance. Additionally, it updates the visibility map to keep track of pages that do not contain any outdated or deleted data, helping to reduce unnecessary I/O operations. \r\n\r\nAnother critical function of autovacuum is to prevent transaction ID wraparound situations, which could result in data loss. \r\n\r\nBy analyzing the results of this troubleshooting guide, you can take proactive steps to optimize autovacuum and maintain the long-term health of your database.",
              "style": "info"
            },
            "name": "introduction to the workbook"
          },
          {
            "type": 1,
            "content": {
              "json": "Step | Observations\r\n--- | ---\r\n**Select Parameters** | Step 0: Select Time interval of interest and database. You can select All option to view the metrics for all databases available on server or by selecting a particular database you could drill down metrics for that selected database.\r\n** Identify Bloat** | Step 1: Determine database bloat ratio. \r\n**Live, Dead and DML Tuple count ** | Step 2: Identify count of dead tuples, live tuples, inserted/updated/deleted tuples.\r\n**Table Vacuumed Execution Count** | Step 3: Identify count of tables vacuumed in the database. \r\n**Table Analyzed Execution Count** | Step 4: Identify count of tables analyzed in the database. \r\n**Autovacuum Workers Execution Count** | Step 5: Monitor autovacuum workers execution count.\r\n\r\n"
            },
            "name": "table of contents"
          },
          {
            "type": 1,
            "content": {
              "json": "#### This troubleshooting guide displays only databases and schemas with Live_tuples >100 and Dead_tuples > 1000.\r\nPlease keep in mind that the count of databases and schemas displayed in this troubleshooting guide may not match the total number of databases and schemas present on the PostgreSQL server. This is because the troubleshooting guide filters out any databases and schemas that do not meet the specified criteria.\r\n\r\nIt's important to understand this limitation when working with the troubleshooting guide, as it may affect the accuracy of any analyses or insights drawn from the data. However, by focusing on the databases and schemas that meet the criteria, it's possible to gain a better understanding of the health and performance of the PostgreSQL server and take appropriate actions to optimize it.\r\n\r\n**Occasionally, we may deviate from these standards and opt to include all the databases on the server, which would trigger a warning for exceeding the limit of 10 databases.**\r\n\r\n**Points to keep in mind while utilizing this troubleshooting guide:**\r\n\r\nThe troubleshooting guide has a cap of 30 databases. However, if you're using the Burstable SKU, the limit is reduced to 10 databases. It's worth noting that this limit applies to the OID column, which indicates the order in which the databases were created.",
              "style": "info"
            },
            "name": "Workbook Info on live and dead tuples"
          }
        ],
        "exportParameters": true
      },
      "name": "workbook top"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Start by setting the following parameters:"
      },
      "name": "parameters for the workbook"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "09ae6e10-24ff-4eb0-964c-78c3bebf6b0b",
            "version": "KqlParameterItem/1.0",
            "name": "MIN_TIME_WINDOW_SEC",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "3600"
                }
              }
            ]
          },
          {
            "id": "9ebd8e9a-5e9c-496a-bdb1-e41b9faaf9ad",
            "version": "KqlParameterItem/1.0",
            "name": "TimeRange",
            "type": 4,
            "isRequired": true,
            "isGlobal": true,
            "value": {
              "durationMs": 86400000
            },
            "typeSettings": {
              "selectableValues": [
                {
                  "durationMs": 3600000
                },
                {
                  "durationMs": 14400000
                },
                {
                  "durationMs": 43200000
                },
                {
                  "durationMs": 86400000
                },
                {
                  "durationMs": 172800000
                },
                {
                  "durationMs": 259200000
                },
                {
                  "durationMs": 604800000
                },
                {
                  "durationMs": 1209600000
                },
                {
                  "durationMs": 2419200000
                }
              ],
              "allowCustom": true
            },
            "timeContext": {
              "durationMs": 86400000
            },
            "label": "TimeRange (Local Time)"
          },
          {
            "id": "af775476-7170-4279-a661-d41ee3581495",
            "version": "KqlParameterItem/1.0",
            "name": "Resource",
            "type": 5,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false,
              "componentIdOnly": true
            }
          },
          {
            "id": "b57a9e87-cce3-4416-8456-965aece843ca",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalEndTime",
            "type": 1,
            "isGlobal": true,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\n\r\nlet dt = {TimeRange:end};\r\nprint iff(dt<now(), dt, now())\r\n\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "331f2446-d717-413a-b8f6-27d2996ec4fc",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalStartTime",
            "type": 1,
            "isGlobal": true,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\nprint iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime('{GlobalEndTime}')-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start})",
            "crossComponentResources": [
              "{Resource}"
            ],
            "isHiddenWhenLocked": true,
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "baf42514-5816-4480-863c-e3bbc27d4cc3",
            "version": "KqlParameterItem/1.0",
            "name": "WRAPAROUND_LOOK_BACK_DAYS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "4d"
                }
              }
            ]
          },
          {
            "id": "93dbd56c-6477-461b-95cc-96b40686d791",
            "version": "KqlParameterItem/1.0",
            "name": "EMERGENCY_AV_THRES",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "200"
                }
              }
            ]
          },
          {
            "id": "f3814683-6847-4337-aedb-6c0c165bf0fd",
            "version": "KqlParameterItem/1.0",
            "name": "WRAPAROUND_THRES",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "45"
                }
              }
            ]
          },
          {
            "id": "39a79938-e8f9-486f-b3ec-f26258dcf87e",
            "version": "KqlParameterItem/1.0",
            "name": "AV_LOOK_BACK_DAYS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7d"
                }
              }
            ]
          },
          {
            "id": "4de34e71-1a41-4aac-8c41-5365578f3ea5",
            "version": "KqlParameterItem/1.0",
            "name": "LongRunningTransaction",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "7200"
                }
              }
            ]
          },
          {
            "id": "7e695ecf-8ee9-4a2a-9d2e-9f8487a9e7e6",
            "version": "KqlParameterItem/1.0",
            "name": "Replication_Threshold",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "10737418240"
                }
              }
            ]
          },
          {
            "id": "eea7ca7c-4a7c-43cf-b11b-2aa1f3a90386",
            "version": "KqlParameterItem/1.0",
            "name": "MAX_XACTS",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "2147483647"
                }
              }
            ]
          },
          {
            "id": "679af9cd-5d73-4f5b-b0e2-643e50383876",
            "version": "KqlParameterItem/1.0",
            "name": "AV_BLOAT_THRESHOLD",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "50"
                }
              }
            ]
          },
          {
            "id": "8997b9e7-7516-4acb-b707-cc4269fea130",
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLFlexTableStats",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where Category =='PostgreSQLFlexTableStats' | project TimeGenerated, Resource, DatabaseName = tostring(     iff(isnotempty(AdditionalFields.DatabaseName), AdditionalFields.DatabaseName,         column_ifexists('DatabaseName_s',            column_ifexists('DatabaseName', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.Schemaname), AdditionalFields.Schemaname,         column_ifexists('Schemaname_s',            column_ifexists('Schemaname', \"\")         )     ) ), LiveRowsCount = tolong(     iff(isnotempty(AdditionalFields.N_live_tup), AdditionalFields.N_live_tup,         column_ifexists('N_live_tup_d',             column_ifexists('N_live_tup',                 column_ifexists('N_live_tup_s', \"\")             )         )     ) ), DeadRowsCount = tolong(     iff(isnotempty(AdditionalFields.N_dead_tup), AdditionalFields.N_dead_tup,         column_ifexists('N_dead_tup_d',             column_ifexists('N_dead_tup',                 column_ifexists('N_dead_tup_s', \"\")             )         )     ) ), SeqentialScansCount = tolong(     iff(isnotempty(AdditionalFields.Seq_scan), AdditionalFields.Seq_scan,         column_ifexists('Seq_scan_d',             column_ifexists('Seq_scan',                 column_ifexists('Seq_scan_s', \"\")             )         )     ) ), RowsFromSeqentialScansCount = tolong(     iff(isnotempty(AdditionalFields.Seq_tup_read), AdditionalFields.Seq_tup_read,         column_ifexists('Seq_tup_read_d',             column_ifexists('Seq_tup_read',                 column_ifexists('Seq_tup_read_s', \"\")             )         )     ) ), IndexScansCount = tolong(     iff(isnotempty(AdditionalFields.Idx_scan), AdditionalFields.Idx_scan,         column_ifexists('Idx_scan_d',             column_ifexists('Idx_scan',                 column_ifexists('Idx_scan_s', \"\")             )         )     ) ), RowsFromIndexScansCount = tolong(     iff(isnotempty(AdditionalFields.Idx_tup_fetch), AdditionalFields.Idx_tup_fetch,         column_ifexists('Idx_tup_fetch_d',             column_ifexists('Idx_tup_fetch',                 column_ifexists('Idx_tup_fetch_s', \"\")             )         )     ) ), RowsInsertedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_ins), AdditionalFields.N_tup_ins,         column_ifexists('N_tup_ins_d',             column_ifexists('N_tup_ins',                 column_ifexists('N_tup_ins_s', \"\")             )         )     ) ), RowsUpdatedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_upd), AdditionalFields.N_tup_upd,         column_ifexists('N_tup_upd_d',             column_ifexists('N_tup_upd',                 column_ifexists('N_tup_upd_s', \"\")             )         )     ) ), RowsDeletedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_del), AdditionalFields.N_tup_del,         column_ifexists('N_tup_del_d',             column_ifexists('N_tup_del',                 column_ifexists('N_tup_del_s', \"\")             )         )     ) ), RowsHotUpdatedCount = tolong(     iff(isnotempty(AdditionalFields.N_tup_hot_upd), AdditionalFields.N_tup_hot_upd,         column_ifexists('N_tup_hot_upd_d',             column_ifexists('N_tup_hot_upd',                 column_ifexists('N_tup_hot_upd_s', \"\")             )         )     ) ), ModificationsSinceAnalyzeCount = tolong(     iff(isnotempty(AdditionalFields.N_mod_since_analyze), AdditionalFields.N_mod_since_analyze,         column_ifexists('N_mod_since_analyze_d',             column_ifexists('N_mod_since_analyze',                 column_ifexists('N_mod_since_analyze_s', \"\")             )         )     ) ), VacuumCount = tolong(     iff(isnotempty(AdditionalFields.Vacuum_count), AdditionalFields.Vacuum_count,         column_ifexists('Vacuum_count_d',             column_ifexists('Vacuum_count',                 column_ifexists('Vacuum_count_s', \"\")             )         )     ) ), AutovacuumCount = tolong(     iff(isnotempty(AdditionalFields.Autovacuum_count), AdditionalFields.Autovacuum_count,         column_ifexists('Autovacuum_count_d',             column_ifexists('Autovacuum_count',                 column_ifexists('Autovacuum_count_s', \"\")             )         )     ) ), AnalyzeCount = tolong(     iff(isnotempty(AdditionalFields.Analyze_count), AdditionalFields.Analyze_count,         column_ifexists('Analyze_count_d',             column_ifexists('Analyze_count',                 column_ifexists('Analyze_count_s', \"\")             )         )     ) ), AutoanalyzeCount = tolong(     iff(isnotempty(AdditionalFields.Autoanalyze_count), AdditionalFields.Autoanalyze_count,         column_ifexists('Autoanalyze_count_d',             column_ifexists('Autoanalyze_count',                 column_ifexists('Autoanalyze_count_s', \"\")             )         )     ) ), TablesCount = tolong(     iff(isnotempty(AdditionalFields.Tables_counter), AdditionalFields.Tables_counter,         column_ifexists('Tables_counter_d',             column_ifexists('Tables_counter',                 column_ifexists('Tables_counter_s', \"\")             )         )     ) ), TablesVacuumedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_vacuumed), AdditionalFields.Tables_vacuumed,         column_ifexists('Tables_vacuumed_d',             column_ifexists('Tables_vacuumed',                 column_ifexists('Tables_vacuumed_s', \"\")             )         )     ) ), TablesAutovacuumedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_autovacuumed), AdditionalFields.Tables_autovacuumed,         column_ifexists('Tables_autovacuumed_d',             column_ifexists('Tables_autovacuumed',                 column_ifexists('Tables_autovacuumed_s', \"\")             )         )     ) ), TablesAnalyzedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_analyzed), AdditionalFields.Tables_analyzed,         column_ifexists('Tables_analyzed_d',             column_ifexists('Tables_analyzed',                 column_ifexists('Tables_analyzed_s', \"\")             )         )     ) ), TablesAutoanalyzedCount = tolong(     iff(isnotempty(AdditionalFields.Tables_autoanalyzed), AdditionalFields.Tables_autoanalyzed,         column_ifexists('Tables_autoanalyzed_d',             column_ifexists('Tables_autoanalyzed',                 column_ifexists('Tables_autoanalyzed_s', \"\")             )         )     ) )"
                }
              }
            ]
          },
          {
            "id": "b545dd79-d31d-43f8-bcbe-7a681acb80d2",
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLLogs",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where Category =='PostgreSQLLogs' | project TimeGenerated, Resource, Timestamp = tostring(     iff(isnotempty(AdditionalFields.timestamp), AdditionalFields.timestamp,         column_ifexists('timestamp_s',            column_ifexists('timestamp', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.processId), AdditionalFields.processId,         column_ifexists('processId_d',             column_ifexists('processId_s',                 column_ifexists('processId', \"\")             )         )     ) ), ErrorLevel = tostring(     iff(isnotempty(AdditionalFields.errorLevel), AdditionalFields.errorLevel,         column_ifexists('errorLevel_s',            column_ifexists('errorLevel', \"\")         )     ) ), SqlErrorCode = tostring(     iff(isnotempty(AdditionalFields.sqlerrcode), AdditionalFields.sqlerrcode,         column_ifexists('sqlerrcode_s',            column_ifexists('sqlerrcode', \"\")         )     ) ), Message = tostring(     iff(isnotempty(AdditionalFields.message), AdditionalFields.message,         column_ifexists('Message',            column_ifexists('message_s', \"\")         )     ) ), Detail = tostring(     iff(isnotempty(AdditionalFields.detail), AdditionalFields.detail,         column_ifexists('detail_s',            column_ifexists('detail', \"\")         )     ) ), Hint = tostring(     iff(isnotempty(AdditionalFields.hint), AdditionalFields.hint,         column_ifexists('hint_s',            column_ifexists('hint', \"\")         )     ) ), Query = tostring(     iff(isnotempty(AdditionalFields.query), AdditionalFields.query,         column_ifexists('query_s',            column_ifexists('query', \"\")         )     ) ), Context = tostring(     iff(isnotempty(AdditionalFields.context), AdditionalFields.context,         column_ifexists('context_s',            column_ifexists('context', \"\")         )     ) ), Statement = tostring(     iff(isnotempty(AdditionalFields.statement), AdditionalFields.statement,         column_ifexists('statement_s',            column_ifexists('statement', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.schema_name), AdditionalFields.schema_name,         column_ifexists('schema_name_s',            column_ifexists('schema_name', \"\")         )     ) ), TableName = tostring(     iff(isnotempty(AdditionalFields.table_name), AdditionalFields.table_name,         column_ifexists('table_name_s',            column_ifexists('table_name', \"\")         )     ) ), ColumnName = tostring(     iff(isnotempty(AdditionalFields.column_name), AdditionalFields.column_name,         column_ifexists('column_name_s',            column_ifexists('column_name', \"\")         )     ) ), DatatypeName = tostring(     iff(isnotempty(AdditionalFields.datatype_name), AdditionalFields.datatype_name,         column_ifexists('datatype_name_s',            column_ifexists('datatype_name', \"\")         )     ) ), ConstraintName = tostring(     iff(isnotempty(AdditionalFields.constraint_name), AdditionalFields.constraint_name,         column_ifexists('constraint_name_s',            column_ifexists('constraint_name', \"\")         )     ) )"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLFlexDatabaseXacts",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where Category =='PostgreSQLFlexDatabaseXacts' | project TimeGenerated, Resource, DatabaseName = tostring(     iff(isnotempty(AdditionalFields.DatabaseName), AdditionalFields.DatabaseName,         column_ifexists('DatabaseName_s',            column_ifexists('DatabaseName', \"\")         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Datdba), AdditionalFields.Datdba,         column_ifexists('Datdba_d',             column_ifexists('Datdba',                 column_ifexists('Datdba_s', \"\")             )         )     )     ), ConnectionsLimit = toint(     iff(isnotempty(AdditionalFields.DatConnLimit), AdditionalFields.DatConnLimit,         column_ifexists('DatConnLimit_d',             column_ifexists('DatConnLimit',                 column_ifexists('DatConnLimit_s', \"\")             )         )     ) ), MinMultixactId = tolong(     iff(isnotempty(AdditionalFields.DatMinmxid), AdditionalFields.DatMinmxid,         column_ifexists('DatMinmxid_d',             column_ifexists('DatMinmxid',                 column_ifexists('DatMinmxid_s', \"\")             )         )     ) ), MinMultixactIdAge = tolong(     iff(isnotempty(AdditionalFields.Age_DatMinmxid), AdditionalFields.Age_DatMinmxid,         column_ifexists('Age_DatMinmxid_d',             column_ifexists('Age_DatMinmxid',                 column_ifexists('Age_DatMinmxid_s', \"\")             )         )     ) ), TransactionIdFrozen = tolong(     iff(isnotempty(AdditionalFields.DatFrozenxid), AdditionalFields.DatFrozenxid,         column_ifexists('DatFrozenxid_d',             column_ifexists('DatFrozenxid',                 column_ifexists('DatFrozenxid_s', \"\")             )         )     ) ), TransactionIdFrozenAge = tolong(     iff(isnotempty(AdditionalFields.Age_DatFrozenxid), AdditionalFields.Age_DatFrozenxid,         column_ifexists('Age_DatFrozenxid_d',             column_ifexists('Age_DatFrozenxid',                 column_ifexists('Age_DatFrozenxid_s', \"\")             )         )     ) ), VacuumFreezeMinAge = toint(     iff(isnotempty(AdditionalFields.Vacuum_freeze_min_age), AdditionalFields.Vacuum_freeze_min_age,         column_ifexists('Vacuum_freeze_min_age_d',             column_ifexists('Vacuum_freeze_min_age',                 column_ifexists('Vacuum_freeze_min_age_s', \"\")             )         )     ) ), AutovacuumFreezeMaxAge = toint(     iff(isnotempty(AdditionalFields.Autovacuum_freeze_max_age), AdditionalFields.Autovacuum_freeze_max_age,         column_ifexists('Autovacuum_freeze_max_age_d',             column_ifexists('Autovacuum_freeze_max_age',                 column_ifexists('Autovacuum_freeze_max_age_s', \"\")             )         )     ) ), RemainingTransactionIds = tolong(     iff(isnotempty(AdditionalFields.Total_remaining_xids), AdditionalFields.Total_remaining_xids,         column_ifexists('Total_remaining_xids_d',             column_ifexists('Total_remaining_xids',                 column_ifexists('Total_remaining_xids_s', \"\")             )         )     ) ), RemainingTransactionIdsTillEmergencyAV = tolong(     iff(isnotempty(AdditionalFields.Remaining_xids_till_emergency_autovacuum), AdditionalFields.Remaining_xids_till_emergency_autovacuum,         column_ifexists('Remaining_xids_till_emergency_autovacuum_d',             column_ifexists('Remaining_xids_till_emergency_autovacuum',                 column_ifexists('Remaining_xids_till_emergency_autovacuum_s', \"\")             )         )     ) ), RemainingTransactionIdsTillWraparound = tolong(     iff(isnotempty(AdditionalFields.Remaining_xids_till_wraparound), AdditionalFields.Remaining_xids_till_wraparound,         column_ifexists('Remaining_xids_till_wraparound_d',             column_ifexists('Remaining_xids_till_wraparound',                 column_ifexists('Remaining_xids_till_wraparound_s', \"\")             )         )     ) ), VacuumMultixactFreezeMinAge = toint(     iff(isnotempty(AdditionalFields.Vacuum_multixact_freeze_min_age), AdditionalFields.Vacuum_multixact_freeze_min_age,         column_ifexists('Vacuum_multixact_freeze_min_age_d',             column_ifexists('Vacuum_multixact_freeze_min_age',                 column_ifexists('Vacuum_multixact_freeze_min_age_s', \"\")             )         )     ) ), AutovacuumMultixactFreezeMaxAge = toint(     iff(isnotempty(AdditionalFields.Autovacuum_multixact_freeze_max_age), AdditionalFields.Autovacuum_multixact_freeze_max_age,         column_ifexists('Autovacuum_multixact_freeze_max_age_d',             column_ifexists('Autovacuum_multixact_freeze_max_age',                 column_ifexists('Autovacuum_multixact_freeze_max_age_s', \"\")             )         )     ) ), RemainingMultixactIds = tolong(     iff(isnotempty(AdditionalFields.Total_remaining_mxids), AdditionalFields.Total_remaining_mxids,         column_ifexists('Total_remaining_mxids_d',             column_ifexists('Total_remaining_mxids',                 column_ifexists('Total_remaining_mxids_s', \"\")             )         )     ) ), RemainingMultixactIdsTillEmergencyAV = tolong(     iff(isnotempty(AdditionalFields.Remaining_mxids_till_emergency_autovacuum), AdditionalFields.Remaining_mxids_till_emergency_autovacuum,         column_ifexists('Remaining_mxids_till_emergency_autovacuum_d',             column_ifexists('Remaining_mxids_till_emergency_autovacuum',                 column_ifexists('Remaining_mxids_till_emergency_autovacuum_s', \"\")             )         )     ) ), RemainingMultixactIdsTillWraparound = tolong(     iff(isnotempty(AdditionalFields.Remaining_mxids_till_wraparound), AdditionalFields.Remaining_mxids_till_wraparound,         column_ifexists('Remaining_mxids_till_wraparound_d',             column_ifexists('Remaining_mxids_till_wraparound',                 column_ifexists('Remaining_mxids_till_wraparound_s', \"\")             )         )     ) )"
                }
              }
            ],
            "id": "2528752f-7b83-45ee-93f2-73b59982a215"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "PostgreSQLFlexSessions",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where Category =='PostgreSQLFlexSessions' | project TimeGenerated, Resource, DatabaseId = toint(     iff(isnotempty(AdditionalFields.Datid), AdditionalFields.Datid,         column_ifexists('Datid_d',             column_ifexists('Datid_s',                 column_ifexists('Datid', \"\")             )         )     )     ), DatabaseName = tostring(     iff(isnotempty(AdditionalFields.Database_name), AdditionalFields.Database_name,         column_ifexists('Database_name_s',            column_ifexists('Database_name', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.Pid), AdditionalFields.Pid,         column_ifexists('Pid_d',            column_ifexists('Pid', \"\")         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Usesysid), AdditionalFields.Usesysid,         column_ifexists('Usesysid_d',             column_ifexists('Usesysid_s',                 column_ifexists('Usesysid', \"\")             )         )     )     ), ApplicationName = tostring(     iff(isnotempty(AdditionalFields.Application_name), AdditionalFields.Application_name,         column_ifexists('Application_name_s',            column_ifexists('Application_name', \"\")         )     ) ), ClientIpAddress = tostring(     iff(isnotempty(AdditionalFields.Client_addr), AdditionalFields.Client_addr,         column_ifexists('Client_addr_s',            column_ifexists('Client_addr', \"\")         )     ) ), State = tostring(     iff(isnotempty(AdditionalFields.State), AdditionalFields.State,         column_ifexists('State_s',            column_ifexists('State', \"\")         )     ) ), WaitEventType = tostring(     iff(isnotempty(AdditionalFields.Wait_event_type), AdditionalFields.Wait_event_type,         column_ifexists('Wait_event_type_s',            column_ifexists('Wait_event_type', \"\")         )     ) ), WaitEvent = tostring(     iff(isnotempty(AdditionalFields.Wait_event), AdditionalFields.Wait_event,         column_ifexists('Wait_event_s',            column_ifexists('Wait_event', \"\")         )     ) ), BackendStartTime = todatetime(     iff(isnotempty(AdditionalFields.Backend_start), AdditionalFields.Backend_start,         column_ifexists('Backend_start_t',             column_ifexists('Backend_start',                 column_ifexists('Backend_start_s', \"\")             )         )     ) ), TransactionStartTime = todatetime(     iff(isnotempty(AdditionalFields.Xact_start), AdditionalFields.Xact_start,         column_ifexists('Xact_start_t',             column_ifexists('Xact_start_s',                 column_ifexists('Xact_start', \"\")             )         )     ) ), QueryStartTime = todatetime(     iff(isnotempty(AdditionalFields.Query_start), AdditionalFields.Query_start,         column_ifexists('Query_start_t',             column_ifexists('Query_start_s',                 column_ifexists('Query_start', \"\")             )         )     ) ), StateChangeTime = todatetime(     iff(isnotempty(AdditionalFields.State_change), AdditionalFields.State_change,         column_ifexists('State_change_t',             column_ifexists('State_change_s',                 column_ifexists('State_change', \"\")             )         )     ) ), CollectionTime = todatetime(     iff(isnotempty(AdditionalFields.Collection_time), AdditionalFields.Collection_time,         column_ifexists('Collection_time_t',             column_ifexists('Collection_time_s',                 column_ifexists('Collection_time', \"\")             )         )     ) ), TransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xid), AdditionalFields.Backend_xid,         column_ifexists('Backend_xid_d',             column_ifexists('Backend_xid_s',                 column_ifexists('Backend_xid', \"\")             )         )     ) ), OldestTransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xmin), AdditionalFields.Backend_xmin,         column_ifexists('Backend_xmin_d',             column_ifexists('Backend_xmin_s',                 column_ifexists('Backend_xmin', \"\")             )         )     ) ), BackendType = tostring(     iff(isnotempty(AdditionalFields.Backend_type), AdditionalFields.Backend_type,         column_ifexists('Backend_type_s',            column_ifexists('Backend_type', \"\")         )     ) )"
                }
              }
            ],
            "id": "320c5eda-9c90-466d-b5af-8d040750e99b"
          }
        ],
        "style": "above",
        "queryType": 1,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "name": "backend queries to get telemtry"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "parameters": [
          {
            "id": "a3c88205-1160-40b8-8fba-423c635596c9",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetEnabledGroups",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.categoryGroup!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.categoryGroup\",\"columnid\":\"CategoryGroup\"}]}}]}",
            "queryType": 12
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetAllEnabledCategories",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.category!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.category\",\"columnid\":\"Category\"}]}}]}",
            "queryType": 12,
            "id": "cc0b467c-1e68-4613-b06e-462e63cc2495"
          },
          {
            "id": "3172fbc3-cfb6-46ca-9b1c-0f47b2f497a7",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimaryAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..properties..replicationRole\",\"columns\":[]}}]}",
            "queryType": 12
          },
          {
            "id": "ce539c66-2b54-46bb-a384-7b90d78f46e8",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimary",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsServerPrimaryAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "Primary",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "5fdec83f-0dec-4efd-9928-6342dad36eaa",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricsAutovacuumDiagnosticsAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/metrics.autovacuum_diagnostics?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^on|ON|On|oN$\",\"substringReplace\":\"ON\"}]}}]}",
            "queryType": 12
          },
          {
            "id": "494c9f2f-43e4-4dbc-a4ee-9be017a05bd0",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricsAutovacuumDiagnosticsOn",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsMetricsAutovacuumDiagnosticsAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "ON",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "a203c3f6-1949-4bd2-b110-2f923c2adc6d",
            "version": "KqlParameterItem/1.0",
            "name": "AutovacuumAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^on|ON|On|oN$\",\"substringReplace\":\"ON\"}]}}]}",
            "queryType": 12
          },
          {
            "id": "2883fefd-b500-4385-b789-ace525dc082b",
            "version": "KqlParameterItem/1.0",
            "name": "IsAutovacuumOn",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AutovacuumAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "ON",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "807fddc6-661a-455c-942d-f047da07162c",
            "version": "KqlParameterItem/1.0",
            "name": "IsTableStatsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexTableStats",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "30891a89-0e07-4054-b835-b12b296e5203",
            "version": "KqlParameterItem/1.0",
            "name": "IsDatabaseXactsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexDatabaseXacts",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "eaaf4dca-3c74-4c39-94a0-de37f1a8fb4b",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerLogsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexSessions",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "id": "0d9e221a-7439-415e-8626-d23536326ab1"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "LogAutovacuumMinDurationAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/log_autovacuum_min_duration?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value\",\"columns\":[]}}]}",
            "queryType": 12,
            "id": "e178a342-dd7d-41fa-bd0a-51adae879db0"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsLogAutovacuumMinDurationOn",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "LogAutovacuumMinDurationAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "-1",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              }
            ],
            "id": "b53b5471-cf9a-4c7d-8733-87af0eb6c228"
          },
          {
            "id": "e430ce26-f33f-4576-8572-e2027664e400",
            "version": "KqlParameterItem/1.0",
            "name": "isPreparedXactsUsed",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/max_prepared_transactions?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value\",\"columns\":[]}}]}",
            "queryType": 12
          },
          {
            "id": "005de42a-784a-4722-8e24-fdfb62a7c6be",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerHavingReplicaAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/replicas?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value[*].name\",\"columns\":[]}}]}",
            "queryType": 12
          },
          {
            "id": "90de2148-f760-4651-911f-cce08878c59d",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerHavingReplica",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsServerHavingReplicaAPI",
                  "operator": "isNotNull",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces"
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "ValidaitonsParameters"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "9e8382bf-e5e2-4279-9662-65c5b83faa48",
            "version": "KqlParameterItem/1.0",
            "name": "Database",
            "type": 2,
            "isRequired": true,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet x= print DatabaseName_s='All';\r\nlet y=\r\nAzureDiagnostics\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n|where Category ==\"PostgreSQLFlexTableStats\"\r\n| where DatabaseName_s !in (\"azure_sys\",\"azure_maintenance\")\r\n| where N_live_tup_d >100 and N_dead_tup_d >1000\r\n|distinct DatabaseName_s;\r\nx | union  y\r\n| project value=DatabaseName_s, label=DatabaseName_s, selected = iff(DatabaseName_s == 'All', true, false)\r\n|order by label asc\r\n\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false
            },
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "IsTableStatsSentToLogAnalytics",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "customWidth": "50",
      "name": "checks on parameters"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "7f1b5948-358a-4845-bc0b-6d45a9ee8f8b",
            "version": "KqlParameterItem/1.0",
            "name": "LessThanOneHourInterval",
            "type": 1,
            "query": "let interval = 1h;\r\nprint iff({TimeRange:end} - {TimeRange:start} < interval, \"Yes\", \"No\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "c355a1f4-39bd-4835-901d-3c5160342265",
            "version": "KqlParameterItem/1.0",
            "name": "EmergencyWraparoundVacuumIssue",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet max_query = \r\n{PostgreSQLFlexDatabaseXacts}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| extend ts=bin(TimeGenerated,5min)\r\n| summarize max(ts);\r\n{PostgreSQLFlexDatabaseXacts}\r\n| where TimeGenerated >= End_Time-{WRAPAROUND_LOOK_BACK_DAYS}\r\n| extend ts=bin(TimeGenerated,5min)\r\n| where ts in(max_query)\r\n| extend PercentTowardsWraparound=round(toreal(TransactionIdFrozenAge)/toreal({MAX_XACTS})*100,2)\r\n| extend PercentTowardsEmergencyAV=round(toreal(TransactionIdFrozenAge)/toreal(AutovacuumFreezeMaxAge)*100,2)\r\n| extend PercentTowardsWraparoundMxid=round(toreal(MinMultixactIdAge)/toreal({MAX_XACTS})*100,2)\r\n| extend PercentTowardsEmergencyAVMxid=round(toreal(MinMultixactIdAge)/toreal(AutovacuumMultixactFreezeMaxAge)*100,2)\r\n| project \r\nDatabaseName,PercentTowardsWraparound,PercentTowardsEmergencyAV,PercentTowardsWraparoundMxid,PercentTowardsEmergencyAVMxid\r\n| where PercentTowardsEmergencyAV > {EMERGENCY_AV_THRES} or \r\n        PercentTowardsWraparound > {WRAPAROUND_THRES} or \r\n        PercentTowardsEmergencyAVMxid > {EMERGENCY_AV_THRES} or \r\n        PercentTowardsWraparoundMxid > {WRAPAROUND_THRES}\r\n| count      \r\n| extend EmergencyWraparoundVacuumIssue = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project EmergencyWraparoundVacuumIssue",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "3b96a823-321c-4963-9a1d-1b21f60f03a4",
            "version": "KqlParameterItem/1.0",
            "name": "_SevenDaysAgoTimestamp",
            "type": 1,
            "query": "let dt = {TimeRange:end}-7d;\r\nprint \r\nv=format_datetime(dt, 'MM/dd/yyyy hh:mm tt')",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "df16fc21-78da-44de-8804-b62e36e9276c",
            "version": "KqlParameterItem/1.0",
            "name": "ChartGrain",
            "type": 1,
            "query": "let trange=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nprint case(\r\n    trange<1h, strcat(format_timespan(trange,'m'),' minute(s)'),\r\n    trange>=1h and trange<1d, strcat(format_timespan(trange,'H'),' hour(s)') ,\r\n    strcat(format_timespan(trange,'dd'),' day(s)')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "14b0a73c-9234-446b-a9cb-e48b1fbeec2b",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedDatabasesRaw",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName !in (\"azure_sys\",\"azure_maintenance\")\r\n| where LiveRowsCount >100 and DeadRowsCount >1000\r\n|distinct db=DatabaseName\r\n|project dbname=split(db, \",\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "74c715dd-8c8b-4609-956e-01922994ebc0",
            "version": "KqlParameterItem/1.0",
            "name": "OverTenDatabasesOnServer",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/databases?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..value[?(@.name !='azure_sys' && @.name != 'azure_maintenance')].name\",\"columns\":[]}}]}",
            "queryType": 12
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "IsOverTenDatabasesOnServer",
            "type": 1,
            "query": "print dbcount= array_length(split('{OverTenDatabasesOnServer}', \",\"))\r\n|extend IsDbCount10 = iff(dbcount>10,'Yes','No')\r\n|project IsDbCount10\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "id": "b70e1d97-f974-458d-8a1f-2c3bd676cdb7"
          },
          {
            "id": "694974ac-bcbf-4e4a-88f3-1efdc1098163",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedSchemasRaw",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName =='{Database}'\r\n| summarize LiveRowsCount=max(LiveRowsCount),DeadRowsCount=max(DeadRowsCount) by bin(TimeGenerated,15m), SchemaName\r\n| where LiveRowsCount>100 and DeadRowsCount>1000\r\n|distinct SchemaName\r\n|project Schema=split(SchemaName, \",\")\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "0c5bb12f-1d00-4b55-99ec-142d62c5796d",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedDatabases",
            "type": 1,
            "query": "print dbname='{QualifiedDatabasesRaw}'\r\n| extend dbname=replace_string(dbname, '[','')\r\n| extend dbname=replace_string(dbname, ']','')\r\n| project dbname",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "4ed030ce-611f-4b9a-8184-2b24e25c34b1",
            "version": "KqlParameterItem/1.0",
            "name": "IsAVCatchingUp",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalEndTime}')-{AV_LOOK_BACK_DAYS};\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet MAX_BLOAT_PCT=100;\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| summarize LiveTuplesCluster= max(LiveTuplesCluster),DeadTuplesCluster=max(DeadTuplesCluster)  \r\n  by bin(TimeGenerated,1d),DatabaseName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal((DeadTuplesCluster+LiveTuplesCluster))*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n|project TimeGenerated, DatabaseName, BloatRatio\r\n|summarize arg_max(TimeGenerated,latest_bloat_pct=(MAX_BLOAT_PCT-BloatRatio)),arg_min(TimeGenerated,last_bloat_pct=(MAX_BLOAT_PCT-BloatRatio)) by DatabaseName\r\n|extend  pct_bloat_change = toreal(((latest_bloat_pct-last_bloat_pct)/((latest_bloat_pct+last_bloat_pct)/2))*100)\r\n|extend pct_bloat_change = iff(isnan(pct_bloat_change),0.0,pct_bloat_change)\r\n|extend actual_latest_pct=MAX_BLOAT_PCT-latest_bloat_pct\r\n|where pct_bloat_change >{AV_BLOAT_THRESHOLD} or actual_latest_pct >{AV_BLOAT_THRESHOLD}\r\n|project DatabaseName",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedSchemas",
            "type": 1,
            "query": "print Schema='{QualifiedSchemasRaw}'\r\n| extend Schema=replace_string(Schema, '[','')\r\n| extend Schema=replace_string(Schema, ']','')\r\n| project Schema",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers",
            "id": "07ccd9aa-d994-4392-9d40-e335f686b636"
          },
          {
            "id": "43bbd184-2866-4e3a-985d-c961f2be3c4e",
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedDatabasesCount",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "QualifiedDatabases",
                  "operator": "is Empty",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              }
            ]
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "QualifiedSchemaCount",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "QualifiedSchemas",
                  "operator": "is Empty",
                  "rightValType": "param",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              }
            ],
            "id": "d9edf76f-106e-4cee-84c9-d93c8c70d72d"
          },
          {
            "id": "3c750ce7-90f0-410d-a4b4-bb07f915f8b2",
            "version": "KqlParameterItem/1.0",
            "name": "UnQualifiedSchema",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName =='{Database}'\r\n| summarize LiveRowsCount=max(LiveRowsCount),DeadRowsCount=max(DeadRowsCount) by bin(TimeGenerated,15m), SchemaName\r\n| where LiveRowsCount < 100 and DeadRowsCount < 1000\r\n| distinct SchemaName\r\n| order by SchemaName asc\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "dc442afa-0531-4e7e-a3ad-81065c93e2ef",
            "version": "KqlParameterItem/1.0",
            "name": "WorkbookNecessary",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\nlet ReadReplica=print isneccesary='{IsServerHavingReplica}';\r\nlet prep_statements =\r\nprint prepared=tolong('{isPreparedXactsUsed}')\r\n| project isneccesary=iff(prepared>0, \"Yes\", \"No\")\r\n| project isneccesary;\r\n\r\nlet sessions =\r\n{PostgreSQLFlexSessions}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| where State !='idle'\r\n| extend Transaction_duration_ms=datetime_diff('second',CollectionTime,TransactionStartTime)\r\n| summarize Transaction_duration_ms=max(Transaction_duration_ms)\r\n| where Transaction_duration_ms > toint({LongRunningTransaction}) \r\n|count\r\n| extend isneccesary = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project isneccesary;\r\n\r\nprep_statements | union sessions,ReadReplica\r\n|where isneccesary =='Yes'\r\n|count\r\n| extend WorkbookNecessary = iff(Count > 0, 'Yes', 'No')\r\n| project WorkbookNecessary",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "above",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "check to see if workbook is needed for the server"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "### There is no database with high dead_tuples/bloat detected in the selected PostgreSQL Flexible Server in the specified time range.\r\nThe PostgreSQL Flexible Server you have selected does not contain a database with a higher dead_tuples/bloat ratio, so information related to the troubleshooting guide will not be displayed.\r\n\r\nHowever, the system will still perform necessary checks and display any relevant warnings to ensure that the server is running optimally.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "QualifiedDatabasesCount",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsTableStatsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "QualifiedDatabasesCount",
                "comparison": "isNotEqualTo"
              }
            ],
            "name": "are there any databases of concern"
          },
          {
            "type": 1,
            "content": {
              "json": "### Autovacuum is currently disabled\r\nAutovacuum is currently disabled. This can lead to the accumulation of dead tuples, index fragmentation, transaction ID wraparound, increased disk space consumption, poor query performance. To prevent these issues, it is strongly recommended to enable autovacuum with appropriate settings and regularly monitor and maintain the database.\r\n\r\nYou can use the Azure Portal to configure server parameters and enable autovacuum. For more information, please follow this link: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-server-parameters-using-portal.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsAutovacuumOn",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "autovacuum is off"
          },
          {
            "type": 1,
            "content": {
              "json": "### The log_autovacuum_min_duration setting is currently disabled\r\nIt seems that the `log_autovacuum_min_duration` setting is turned off on the server. As a result, the Autovacuum workers execution section in this troubleshooting guide will not show any information since autovacuum logging is not being carried out. It is recommended to enable this setting in order to track longer autovacuum operations.\r\n\r\nYou can use the Azure Portal to configure server parameters and enable `log_autovacuum_min_duration`. For more information, please follow this link: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-server-parameters-using-portal.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsLogAutovacuumMinDurationOn",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "QualifiedDatabasesCount",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "log autovacuum min duration setting is currently disabled"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL server logs data is not being transmitted to the log analytics workspace\r\nThe PostgreSQL server logs data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Server Logs` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsServerLogsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "IsServerLogsSentToLogAnalytics"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Sessions logs data is not being transmitted to the log analytics workspace\r\nThe PostgreSQL Sessions logs data is not being sent to the log analytics workspace, which is necessary to use this workbook. To configure the logging settings for category `PostgreSQL Sessions` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "session logs are not being transmitted"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Table Stats data is not being transmitted to the log analytics workspace\r\nThe PostgreSQL Table Stats data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Tables Statistics` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsTableStatsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "IsTableStatsSentToLogAnalytics"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Database Remaining Transactions data is not being transmitted to the log analytics workspace\r\nThe PostgreSQL Table Stats data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Database Remaining Transactions` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsDatabaseXactsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "remaining transactions are not being transmitted"
          },
          {
            "type": 1,
            "content": {
              "json": "### The specified server is not a primary server\r\nThe autovacuum statistics shown on the replica server are not relevant and may be misleading. The replica server is designed to replicate data from the primary server and is not responsible for running autovacuum. The autovacuum statistics shown on the replica server are simply a reflection of the primary server's activity and do not represent the actual state of the replica server. \r\n\r\nPlease be aware that checking the autovacuum statistics on a replica server may cause confusion and lead to incorrect conclusions about the state of the database. We recommend that you only check the autovacuum statistics on the primary server to ensure accurate and reliable results.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsServerPrimary",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "specified server is not a primary"
          }
        ]
      },
      "name": "errors",
      "styleSettings": {
        "margin": "1"
      }
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "### WARNING: Elevated Percentage of Wraparound and Emergency Autovacuuming Protection Detected\r\nThis warning indicates that the autovacuum process, which helps maintain the health and performance of a PostgreSQL database, is currently blocked or running slow. This can lead to higher percentages towards Wraparound or Emergency autovacuum protection.",
                    "style": "warning"
                  },
                  "name": "elevated percentage of wraparound"
                },
                {
                  "type": 11,
                  "content": {
                    "version": "LinkItem/1.0",
                    "style": "paragraph",
                    "links": [
                      {
                        "id": "01cef439-ceca-4e6f-b2c7-e5a844636211",
                        "cellValue": "",
                        "linkTarget": "WorkbookTemplate",
                        "linkLabel": "Autovacuum blockers troubleshooting guide ",
                        "preText": "Please visit ",
                        "postText": " to debug.",
                        "style": "link",
                        "linkIsContextBlade": true,
                        "workbookContext": {
                          "componentIdSource": "workbook",
                          "resourceIdsSource": "workbook",
                          "templateIdSource": "static",
                          "templateId": "Community-Workbooks/PostgreSQL Flexible Server/Performance/Autovacuum Blockers",
                          "typeSource": "workbook",
                          "gallerySource": "workbook",
                          "locationSource": "default",
                          "passSpecificParams": true,
                          "templateParameters": [
                            {
                              "name": "TimRange",
                              "source": "parameter",
                              "value": "TimeRange"
                            },
                            {
                              "name": "Resource",
                              "source": "parameter",
                              "value": "Resource"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  "name": "link to av blockers workbook"
                }
              ]
            },
            "conditionalVisibilities": [
              {
                "parameterName": "EmergencyWraparoundVacuumIssue",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "EmergencyWraparoundVacuumIssueWarning"
          },
          {
            "type": 1,
            "content": {
              "json": "#### More than 10 databases are detected.\r\n**The given server contains more than 10 databases, and the presence of several databases with a limited number of autovacuum workers may result in autovacuum to fall behind.**\r\n\r\nIf autovacuum is unable to catch-up due the large number of databases on the server, it is advisable to adjust the autovacuum parameters.\r\n\r\nFor more information on how to tune autovacuum in this situation, please refer to: https://learn.microsoft.com/azure/postgresql/flexible-server/how-to-autovacuum-tuning#large-number-ofdatabases",
              "style": "warning"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "OverTenDatabasesOnServer",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "more than ten databases found"
          },
          {
            "type": 1,
            "content": {
              "json": "#### The autovacuum process is not able to keep up with the workload for certain databases on the server.\r\n\r\nBetween the time period **{_SevenDaysAgoTimestamp}** and **{TimeRange:end}** the bloat ratio for **{IsAVCatchingUp}**  databases seems to have increased more than {AV_BLOAT_THRESHOLD}% or the bloat ratio for these databases at current time period - **{TimeRange:end}** is more than {AV_BLOAT_THRESHOLD}%.Please follow recommendations below\r\n\r\n1. Review the metrics provided to identify the databases with a high bloat ratio and follow the provided recommendations.\r\n2. Check the troubleshooting guide for any warnings about autovacuum blockers. Autovacuum blockers can increase bloat, which can prevent autovacuum workers from catching up.\r\n3. If no autovacuum or vacuum blockers are found, please refer to the following link for more information on how to tune autovacuum in this situation: https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning#not-keeping-up-with-busy-server\r\n\r\n",
              "style": "warning"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsAVCatchingUp",
                "comparison": "isNotEqualTo",
                "value": ""
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "av cannot keep up at the moment"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "loadType": "always",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Autovacuum is blocked.\r\nThis warning indicates that the autovacuum process, which helps maintain the health and performance of a PostgreSQL database, is currently blocked. This can lead to an accumulation of dead tuples, increased bloat, and degraded performance.",
                    "style": "warning"
                  },
                  "name": "av is blocked and here could be why"
                },
                {
                  "type": 11,
                  "content": {
                    "version": "LinkItem/1.0",
                    "style": "list",
                    "links": [
                      {
                        "id": "57ba7895-7e6a-40fa-ae2f-597495d440f7",
                        "cellValue": "",
                        "linkTarget": "WorkbookTemplate",
                        "linkLabel": "Autovacuum blockers troubleshooting guide",
                        "preText": "It's crucial to identify and address the source of the autovacuum blockage promptly. This may involve investigating potential causes. Please visit",
                        "postText": " to debug.",
                        "style": "link",
                        "linkIsContextBlade": true,
                        "workbookContext": {
                          "componentIdSource": "workbook",
                          "resourceIdsSource": "workbook",
                          "templateIdSource": "static",
                          "templateId": "Community-Workbooks/PostgreSQL Flexible Server/Performance/Autovacuum Blockers",
                          "typeSource": "workbook",
                          "gallerySource": "workbook",
                          "locationSource": "default",
                          "passSpecificParams": true,
                          "templateParameters": [
                            {
                              "name": "Resource",
                              "source": "parameter",
                              "value": "Resource"
                            },
                            {
                              "name": "TimeRange",
                              "source": "parameter",
                              "value": "TimeRange"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  "name": "a link to an autovacuum troubleshooting guide"
                }
              ]
            },
            "conditionalVisibilities": [
              {
                "parameterName": "WorkbookNecessary",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimary",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "group - 31"
          }
        ]
      },
      "name": "warnings about the section"
    },
    {
      "type": 1,
      "content": {
        "json": "#### This troubleshooting guide will only display data for schemas that meet the eligibility criteria, which includes a minimum of 100 live tuples and 1000 dead tuples. Therefore, data for schemas **'{UnQualifiedSchema}'** are not shown as they don't meet these criteria. .",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "Database",
          "comparison": "isNotEqualTo",
          "value": "All"
        },
        {
          "parameterName": "IsServerPrimary",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsTableStatsSentToLogAnalytics",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "schema must meet eligability criteria"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Please note that this troubleshooting guide does not permit the selection of a timerange shorter than one hour. If a timerange of less than one hour is selected, the troubleshooting guide will default to a timerange of one hour.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "LessThanOneHourInterval",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "name": "Workbook Info on live and dead tuples for troubleshooting guide"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "tabStyle": "bigger",
        "links": [
          {
            "id": "658f22a6-f71a-4f7e-add6-445c7c80b66b",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Bloat Ratio",
            "subTarget": "bloat",
            "style": "link"
          },
          {
            "id": "daa324f1-0d29-4dac-b76b-1447edfe6b0d",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Tuple Counts",
            "subTarget": "tupcount",
            "style": "link"
          },
          {
            "id": "e48395ed-d0a2-424d-8951-744764988284",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Tables Vacuumed & Analyzed Execution Counts",
            "subTarget": "vacuumanalyze",
            "style": "link"
          },
          {
            "id": "5187a9fe-7e5c-4223-bcdf-e4e229bcffdf",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Autovacuum Workers Execution Count",
            "subTarget": "vacuumworkers",
            "style": "link"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "QualifiedDatabasesCount",
        "comparison": "isEqualTo",
        "value": "Yes"
      },
      "name": "checks for this specific section and if it can display"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "title": "Blot Ratio for {Database} database(s)",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "#### Guidelines for the bloat ratio formula:\r\n\r\n The bloat ratio can be determined by applying the following formula: dead_tuples/live_tuples*100. However, caution should be exercised when interpreting the results of this formula as it may produce skewed outcomes that exceed 100%.\r\n\r\n- A ratio of 50% is cause for concern as it suggests that dead_tuples account for half of the live_tuples.\r\n- When the ratio reaches 100%, it implies that the number of dead_tuples is equal to the number of live_tuples, which is a sign of significant bloat.\r\n- Moreover, if the ratio surpasses 100%, it indicates that there are more dead_tuples than live_tuples, which is a clear indication of severe bloat.",
              "style": "info"
            },
            "name": "Bloatration Guidelines"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,DatabaseName\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal(LiveTuplesCluster)*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n| project TimeGenerated,DatabaseName, BloatRatio\r\n//|summarize BloatRatio=max(BloatRatio) by bin (TimeGenerated,5m),DatabaseName\r\n//|summarize BloatRatio=max(BloatRatio) by bin (TimeGenerated,graphgrain),DatabaseName\r\n|make-series BloatRatio=max(BloatRatio) on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName",
              "size": 0,
              "aggregation": 2,
              "showAnnotations": true,
              "title": "Bloat Ratio by Database. Data is plotted at a granularity of {ChartGrain}",
              "timeBrushParameterName": "TimeRange",
              "timeBrushExportOnlyWhenBrushed": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "linechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Start_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "Start_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    },
                    "numberFormat": {
                      "unit": 0,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "End_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "End_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  },
                  {
                    "columnMatch": "BloatRatio",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  }
                ]
              },
              "sortBy": [],
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "DatabaseName_s"
                },
                "leftContent": {
                  "columnMatch": "BloatRatio",
                  "formatter": 3,
                  "formatOptions": {
                    "palette": "blue"
                  },
                  "numberFormat": {
                    "unit": 1,
                    "options": {
                      "style": "decimal"
                    }
                  }
                },
                "rightContent": {
                  "columnMatch": "BloatRatio"
                },
                "secondaryContent": {
                  "columnMatch": "BloatRatio"
                },
                "showBorder": false,
                "sortCriteriaField": "BloatRatio",
                "sortOrderField": 2
              },
              "chartSettings": {
                "group": "DatabaseName",
                "createOtherGroup": 30,
                "showLegend": true,
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 1,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                }
              }
            },
            "conditionalVisibility": {
              "parameterName": "Database",
              "comparison": "isEqualTo",
              "value": "All"
            },
            "name": "checks at top level section for visibility"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "\r\nlet graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,SchemaName\r\n| summarize LiveTuplesCluster= sum(LiveRowsCount),DeadTuplesCluster=sum(DeadRowsCount)  \r\n  by bin(TimeGenerated,5m), SchemaName\r\n| extend BloatRatio=toreal(DeadTuplesCluster)/toreal(LiveTuplesCluster)*100\r\n| extend BloatRatio = iff( isnan(BloatRatio), 0.0, BloatRatio)\r\n| project TimeGenerated, SchemaName, BloatRatio\r\n|make-series BloatRatio=max(BloatRatio) default=0 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName",
              "size": 0,
              "aggregation": 2,
              "showAnnotations": true,
              "title": "Bloat Ratio by Schema. Data is plotted at a granularity of {ChartGrain}",
              "timeBrushParameterName": "TimeRange",
              "timeBrushExportOnlyWhenBrushed": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "linechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Start_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "Start_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    },
                    "numberFormat": {
                      "unit": 0,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "End_time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "End_bloat",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  },
                  {
                    "columnMatch": "BloatRatio",
                    "formatter": 8,
                    "formatOptions": {
                      "palette": "greenRed"
                    }
                  }
                ]
              },
              "sortBy": [],
              "chartSettings": {
                "group": "SchemaName",
                "createOtherGroup": 100,
                "showLegend": true,
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 1,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                }
              }
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "QualifiedSchemaCount",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "Bloat Ratio - Database"
          },
          {
            "type": 1,
            "content": {
              "json": "#### Monitor the database bloat ratio for all databases on server. A High bloat ratio for any individual database is not recommended. If you identify a database with a high bloat ratio then select that database from the drop down in the troubleshooting guide to further drill down and analyze.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "Database",
              "comparison": "isEqualTo",
              "value": "All"
            },
            "name": "guidelines for monitoring the database bloat"
          },
          {
            "type": 1,
            "content": {
              "json": "#### Please monitor the bloat ratio at the individual schema level for the selected {Database} database. If a schema with a high bloat ratio is detected, it may be due to one of the following reasons, which require further investigation:\r\n\r\n- The presence of autovacuum blockers. Look for any warnings in this troubleshooting guide regarding autovacuum blockers, and remove any that are found.\r\n- If no blockers are present, and the bloat ratio is still high, it may be because the autovacuum workers are not able to keep up with the workload. In this case, it is recommended to tune the autovacuum settings.\r\n\r\nFor more information on how to tune autovacuum, please refer to the following article: https://learn.microsoft.com/azure/postgresql/flexible-server/how-to-autovacuum-tuning",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "isFlexServer",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "how to monitor bloat at schema levels"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "bloat"
        }
      ],
      "name": "bloat ratio guideline param checks"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "tabs",
              "links": [
                {
                  "id": "ea04fb8f-dbf1-4eb6-bdb8-f835b59f6579",
                  "cellValue": "tuptab",
                  "linkTarget": "parameter",
                  "linkLabel": "Live & Dead Tuple Counts",
                  "subTarget": "live",
                  "style": "link"
                },
                {
                  "id": "3eb571c9-8116-426f-9655-1cd7cde73f80",
                  "cellValue": "tuptab",
                  "linkTarget": "parameter",
                  "linkLabel": "Insert, Update & Delete Tuple Counts",
                  "subTarget": "insert",
                  "style": "link"
                }
              ]
            },
            "name": "links for checking separate tuple counts"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "details for how to expand each group"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,DatabaseName,SchemaName\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series LiveTuples=max(LiveTuples), DeadTuples=max(DeadTuples) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tuple State for {Database} Databases. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "DatabaseName",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed",
                            "compositeBarSettings": {
                              "labelText": "",
                              "columnSettings": []
                            }
                          }
                        }
                      ],
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Live & Dead Tuple State"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,DatabaseName,SchemaName\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m),DatabaseName\r\n| make-series LiveTuples=max(LiveTuples) default=-1  , DeadTuples=max(DeadTuples) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,LiveTuples, DeadTuples\r\n| where LiveTuples!=-1 or DeadTuples!=-1\r\n| extend LiveTuples = tolong(LiveTuples), DeadTuples=tolong(DeadTuples), TimeGenerated=todatetime(TimeGenerated)\r\n| extend LiveToDeadTupRatio=round(100*DeadTuples/LiveTuples)\r\n| project TimeGenerated, DatabaseName, LiveTuples, DeadTuples, LiveToDeadTupRatio\r\n| order by TimeGenerated, DeadTuples desc ",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "LiveTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "LiveToDeadTupRatio",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DatabaseName_s",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      },
                      "sortBy": [
                        {
                          "itemKey": "$gen_heatmap_LiveToDeadTupRatio_5",
                          "sortOrder": 2
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "$gen_heatmap_LiveToDeadTupRatio_5",
                        "sortOrder": 2
                      }
                    ],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "conditionals for tuple section and what warnings should show"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,LiveRowsCount,DeadRowsCount\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series LiveTuples=max(LiveTuples), DeadTuples=max(DeadTuples) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "title": "Tuple State for {Database} database. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database "
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,LiveRowsCount,DeadRowsCount,SchemaName\r\n| summarize LiveTuples= sum(LiveRowsCount),\r\n            DeadTuples=sum(DeadRowsCount)\r\n  by bin(TimeGenerated,5m),SchemaName\r\n| make-series LiveTuples=max(LiveTuples) default=-1 , DeadTuples=max(DeadTuples) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName\r\n| mv-expand TimeGenerated,LiveTuples, DeadTuples\r\n| where LiveTuples!=-1 or DeadTuples!=-1\r\n| extend TimeGenerated=todatetime(TimeGenerated),LiveTuples = tolong(LiveTuples), DeadTuples=tolong(DeadTuples)\r\n| extend LiveToDeadTupRatio=round(100*DeadTuples/LiveTuples)\r\n| project TimeGenerated, SchemaName, LiveTuples, DeadTuples, LiveToDeadTupRatio\r\n| order by TimeGenerated,DeadTuples desc\r\n",
                    "size": 1,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "LiveTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "LiveToDeadTupRatio",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ]
                      }
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database grid"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "To ensure optimal performance of the server, it's recommended to monitor the live and dead tuple counts for all databases. If a database is identified with a high number of dead tuples, it's suggested to select the identified database from the drop-down menu in the troubleshooting guide to further analyze and drill down into the issue.\r\n\r\nBy focusing on the identified database, it's possible to investigate the cause of the high dead tuple count and take corrective measures to optimize performance. Therefore, it's essential to keep track of the tuple counts and identify any databases that may require further analysis.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "how to get optimal performance on the server"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "To ensure optimal performance of the selected **{Database}** database, it's recommended to monitor the live, dead, inserted, deleted, and updated tuple counts at the schema level. If a schema is identified with a high number of dead tuples, and there is a trend where the dead tuples seem to be increasing over time, it's suggested to check the bloat ratio for both the database and schema.\r\n\r\nA high count of dead tuples may lead to a high bloat ratio, which can impact performance. Therefore, it's essential to keep track of the tuple counts and investigate any increases in dead tuples to ensure that the bloat ratio stays within an acceptable range.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isNotEqualTo",
                    "value": "All"
                  },
                  "name": "how to get optimal performance on the selected database"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "tuptab",
              "comparison": "isEqualTo",
              "value": "live"
            },
            "name": "Live"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "details on how to expand second tab"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series TuplesInserted=max(TuplesInserted), TuplesUpdated=max(TuplesUpdated), TuplesDeleted=max(TuplesDeleted) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tuple State for {Database} Databases. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "DatabaseName",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed",
                            "compositeBarSettings": {
                              "labelText": "",
                              "columnSettings": []
                            }
                          }
                        }
                      ],
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Live & Dead Tuple State for second tab"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m),DatabaseName\r\n|make-series TuplesInserted=max(TuplesInserted) default=-1, TuplesUpdated=max(TuplesUpdated) default=-1, TuplesDeleted=max(TuplesDeleted) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,TuplesInserted, TuplesUpdated,TuplesDeleted\r\n| where TuplesInserted !=-1 or TuplesUpdated !=-1 or TuplesDeleted !=-1\r\n| extend TimeGenerated=todatetime(TimeGenerated), TuplesInserted = tolong(TuplesInserted), TuplesUpdated=tolong(TuplesUpdated),TuplesDeleted=tolong(TuplesDeleted)\r\n| project TimeGenerated,DatabaseName, TuplesInserted, TuplesUpdated , TuplesDeleted\r\n| order by TimeGenerated desc ",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "DatabaseName",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "TuplesInserted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "TuplesUpdated",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "TuplesDeleted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DatabaseName_s",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "checks for second tab and what warnings to show"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m)\r\n|make-series TuplesInserted=max(TuplesInserted), TuplesUpdated=max(TuplesUpdated), TuplesDeleted=max(TuplesDeleted) on TimeGenerated from Start_Time to End_Time step graphgrain ",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tuple State for {Database} database. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "$gen_group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "Group",
                          "formatter": 16,
                          "formatOptions": {
                            "showIcon": true
                          }
                        },
                        {
                          "columnMatch": "DatabaseName",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "DeadTuples",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed",
                            "compositeBarSettings": {
                              "labelText": "",
                              "columnSettings": []
                            }
                          }
                        }
                      ],
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database on second tab"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,RowsInsertedCount,RowsUpdatedCount,RowsDeletedCount\r\n| summarize TuplesInserted= sum(RowsInsertedCount),\r\n            TuplesUpdated = sum(RowsUpdatedCount),\r\n            TuplesDeleted = sum(RowsDeletedCount)\r\n  by bin(TimeGenerated,5m), SchemaName\r\n|make-series TuplesInserted=max(TuplesInserted) default=-1, TuplesUpdated=max(TuplesUpdated) default=-1, TuplesDeleted=max(TuplesDeleted) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName\r\n| mv-expand TimeGenerated,TuplesInserted, TuplesUpdated,TuplesDeleted\r\n| where TuplesInserted !=-1 or TuplesUpdated !=-1 or TuplesDeleted !=-1\r\n| extend TuplesInserted = tolong(TuplesInserted), TuplesUpdated=tolong(TuplesUpdated),TuplesDeleted=tolong(TuplesDeleted), TimeGenerated=todatetime(TimeGenerated)\r\n| project TimeGenerated,SchemaName, TuplesInserted, TuplesUpdated , TuplesDeleted\r\n| order by TimeGenerated desc ",
                    "size": 1,
                    "aggregation": 2,
                    "timeBrushParameterName": "TimeRange",
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "TuplesInserted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "TuplesUpdated",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "TuplesDeleted",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 17,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ],
                        "expandTopLevel": false
                      }
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tuple State and Disk Usage for database grid in tab two"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Inserts, updates, and deletes can cause bloat in PostgreSQL, which is when the size of a table or index grows larger than necessary due to data fragmentation and inefficient space utilization. This can negatively impact the performance and efficiency of the database.\r\n\r\nInserts can cause bloat if the table has a high degree of fragmentation, meaning that the table has gaps between existing rows due to deleted rows. These gaps can cause a table to use more disk space than necessary, which can slow down queries that scan the entire table.\r\n\r\nUpdates can also cause bloat because when a row is updated, PostgreSQL does not immediately overwrite the existing row. Instead, it creates a new version of the row, and marks the old version as \"dead.\" This can create fragmentation in the table and contribute to bloat, especially if there are many updates and the table has many indexes.\r\n\r\nDeletes can cause bloat if they leave behind empty space in a table or index. This is because PostgreSQL does not immediately remove the dead rows from the table or index, but rather marks them as \"free space.\" Over time, this can cause a table or index to become fragmented and use more disk space than necessary.\r\n\r\nTo prevent bloat, it is important to regularly vacuum and analyze tables and indexes. ",
                    "style": "info"
                  },
                  "name": "what are some of the main causes of bloat"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "tuptab",
              "comparison": "isEqualTo",
              "value": "insert"
            },
            "name": "Insert"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "tupcount"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "tuple count for the second tab"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "tabs",
              "links": [
                {
                  "id": "4a11b036-17c2-4fb9-ae07-b5258bd36fee",
                  "cellValue": "vacuum-tab",
                  "linkTarget": "parameter",
                  "linkLabel": "Vacuumed Execution Count",
                  "subTarget": "vacuum",
                  "style": "link"
                },
                {
                  "id": "5bba1dca-dd6f-4224-a56e-0b0eaa5d399e",
                  "cellValue": "vacuum-tab",
                  "linkTarget": "parameter",
                  "linkLabel": "Analyzed Execution Count",
                  "subTarget": "analyze",
                  "style": "link"
                }
              ]
            },
            "name": "Vacuum&Analyze"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "expand each group instructions for queries"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,1m)\r\n|make-series Tables_counter=max(_Tables_counter),Tables_vacuumed=max(_Tables_vacuumed),Tables_autovacuumed=max(_Tables_autovacuumed) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tables Vacuumed Execution Count for all Databases. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_vacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "yellowOrangeRed"
                          }
                        }
                      ]
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Table Vacuumed Execution Count - Cluster"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated, SchemaName,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,1s)\r\n|make-series Tables_counter=max(_Tables_counter),Tables_vacuumed=max(_Tables_vacuumed),Tables_autovacuumed=max(_Tables_autovacuumed) on TimeGenerated from Start_Time to End_Time step graphgrain\r\n\r\n",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tables Vacuumed Execution Count for {Database} database.  Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_vacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "yellowOrangeRed"
                          }
                        }
                      ]
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Table Vacuumed Execution Count - Database"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "##### Column Details\r\n\r\n**Total Tables** : Total tables that are present in the database when Database=All is selected or Total tables that are present in the individual schema when a particular database is selected from troubleshooting guide dropdown.\r\n\r\n**Tables Vacuumed** : Total tables that are manually vacuumed in the database when Database=All is selected or Total tables that are manually vacuumed in the individual schema when a particular database is selected from troubleshooting guide dropdown.\r\n\r\n**Tables Autovacuumed** : Total tables that are  autovacuumed in the database when Database=All is selected from troubleshooting guide dropdown or Total tables that are autovacuumed in the individual schema when a particular database is selected from troubleshooting guide dropdown.\r\n\r\n**Tables Autovacuumed [Pct]** : Tables Autovacuumed/Total Tables *100\r\n\r\n**Tables Never Autovacuumed[Pct]** : Tables Never Autovacuumed/Total Tables *100\r\n",
                    "style": "info"
                  },
                  "name": "Table Vacuumed Execution Coun - Cluster text"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated,DatabaseName,SchemaName,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,1s),DatabaseName\r\n|make-series Tables_counter=max(_Tables_counter) default=-1,Tables_vacuumed=max(_Tables_vacuumed) default=-1,Tables_autovacuumed=max(_Tables_autovacuumed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,Tables_counter, Tables_vacuumed,Tables_autovacuumed\r\n| where Tables_counter !=-1 or Tables_vacuumed !=-1 or Tables_autovacuumed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_vacuumed=tolong(Tables_vacuumed),Tables_autovacuumed=tolong(Tables_autovacuumed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autovacuumed= iff(Tables_counter==Tables_autovacuumed,0.0,toreal(Tables_counter-Tables_autovacuumed))\r\n| extend Tables_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,100.00,iff(Tables_autovacuumed < Tables_counter, (toreal(Tables_autovacuumed)/toreal(Tables_counter))*100,100.0))\r\n| extend Tables_never_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,0.0,iff(Tables_never_autovacuumed < Tables_counter, (toreal(Tables_never_autovacuumed)/toreal (Tables_counter))*100,100.0))\r\n| project TimeGenerated, DatabaseName, Tables_counter, Tables_vacuumed, Tables_autovacuumed, Tables_autovacuumed_pct,Tables_never_autovacuumed, Tables_never_autovacuumed_pct\r\n| order by TimeGenerated, Tables_never_autovacuumed desc",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autovacuumed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ],
                        "expandTopLevel": false
                      },
                      "sortBy": [
                        {
                          "itemKey": "$gen_heatmap_Tables_never_autovacuumed_pct_8",
                          "sortOrder": 1
                        }
                      ],
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated "
                        },
                        {
                          "columnId": "DatabaseName",
                          "label": "Database Name "
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_vacuumed",
                          "label": "Tables Vacuumed"
                        },
                        {
                          "columnId": "Tables_autovacuumed",
                          "label": "Tabled Autovacuumed "
                        },
                        {
                          "columnId": "Tables_autovacuumed_pct",
                          "label": "Tables Autovacuumed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autovacuumed",
                          "label": "Tables Never Autovacuumed "
                        },
                        {
                          "columnId": "Tables_never_autovacuumed_pct",
                          "label": "Tables Never Autovacuumed [Pct]"
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "$gen_heatmap_Tables_never_autovacuumed_pct_8",
                        "sortOrder": 1
                      }
                    ],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Table Vacuumed Execution Count  - Cluster grid"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,TablesCount,TablesVacuumedCount,TablesAutovacuumedCount,SchemaName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_vacuumed=sum(TablesVacuumedCount),_Tables_autovacuumed=sum(TablesAutovacuumedCount) by bin(TimeGenerated,5m),SchemaName \r\n|make-series Tables_counter=max(_Tables_counter) default=-1,Tables_vacuumed=max(_Tables_vacuumed) default=-1,Tables_autovacuumed=max(_Tables_autovacuumed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName \r\n| mv-expand TimeGenerated,Tables_counter, Tables_vacuumed,Tables_autovacuumed\r\n| where Tables_counter !=-1 or Tables_vacuumed !=-1 or Tables_autovacuumed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_vacuumed=tolong(Tables_vacuumed),Tables_autovacuumed=tolong(Tables_autovacuumed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autovacuumed= iff(Tables_counter==Tables_autovacuumed,0.0,toreal(Tables_counter-Tables_autovacuumed))\r\n| extend Tables_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,100.00,iff(Tables_autovacuumed < Tables_counter, (toreal(Tables_autovacuumed)/toreal(Tables_counter))*100,100.0))\r\n| extend Tables_never_autovacuumed_pct= iff(Tables_counter==Tables_autovacuumed,0.0,iff(Tables_never_autovacuumed < Tables_counter, (toreal(Tables_never_autovacuumed)/toreal (Tables_counter))*100,100.0))\r\n| project TimeGenerated, SchemaName, Tables_counter, Tables_vacuumed, Tables_autovacuumed, Tables_autovacuumed_pct,Tables_never_autovacuumed, Tables_never_autovacuumed_pct\r\n| order by TimeGenerated, Tables_never_autovacuumed desc",
                    "size": 1,
                    "aggregation": 2,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autovacuumed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autovacuumed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ]
                      },
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated"
                        },
                        {
                          "columnId": "SchemaName",
                          "label": "Schema Name"
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_vacuumed",
                          "label": "Tables Vacuumed"
                        },
                        {
                          "columnId": "Tables_autovacuumed",
                          "label": "Tables Autovacuumed"
                        },
                        {
                          "columnId": "Tables_autovacuumed_pct",
                          "label": "Tables Autovacuumed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autovacuumed",
                          "label": "Tables Never Autovacuumed"
                        },
                        {
                          "columnId": "Tables_never_autovacuumed_pct",
                          "label": "Tables Never Autovacuumed [Pct]"
                        }
                      ]
                    },
                    "sortBy": [],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Table Vacuumed Execution Count  - Database gird"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the Total Tables Never Autovacuumed[pct] column for all databases on server. If we identify a database with high Total Tables Never Autovacuumed[pct] value then suggest to select the identified database from the drop down in the troubleshooting guide to further drill down and analyze.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "what to monitor to avoid an av issue"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the total Tables Never Autovacuumed[pct] column at schema level for selected {Database} database.<br>\r\n\r\nIf you have a high Tables Never Autovacuumed[pct] value, follow the suggestions below for further analysis:\r\n\r\n\tIt's important to consider the workload when tuning autovacuum parameters as some tables may have high DML activity while others may not have any activity at all. Therefore, it's crucial to understand the workload dynamics before making any adjustments.\r\n\r\n<h5>Scenario 1:</h5>\r\n\r\nThe server might have a large number of databases and autovacuum is not able to catch up and  vacuum all tables across all databases. Please refer https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning on suggestions to tune the server.\r\n\r\n<h5>Scenario 2:</h5>\r\n\r\nThe autovacuum is cleaning the dead tuples slowly. Please refer https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning on suggestions to speed up and tune.\r\n\r\n<h5>Scenario 3:</h5>\r\n\r\nAutovacuum workers could potentially be occupied with larger tables, leaving insufficient time to clean other tables within the database. Please refer https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning#table-specific-requirements on suggestions for table specific requirements.\r\n\r\n<h5>Scenario 4:</h5>\r\n\r\nTotal Tables Never Autovacuumed[pct] value found to be zero. Follow the suggestions below for further analysis:\r\n\r\nThe server's autovacuum parameter could be disabled. To determine if this is the case, check the error messages at the top of the troubleshooting guide for any indication that autovacuum has been turned off on the server.\r\n\r\n<h5>Scenario 5:</h5>\r\n\r\nAfter upgrading your PostgreSQL database server to a higher version or migrating to a new server, it is crucial to perform a database-wide manual vacuum before commencing your workload on the server. This is done to ensure that the statistics for tables are up to date and the query plans are optimized.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "more information regarding monitoring av"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "vacuum-tab",
              "comparison": "isEqualTo",
              "value": "vacuum"
            },
            "name": "vacuum"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "#### Expand each group in grid view to see the details",
                    "style": "info"
                  },
                  "name": "another item explaining that the grid can be expanded"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nlet DB_NAME =iff('{Database}'== 'All', '', '{Database}');\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated, TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m)\r\n|make-series Tables_counter=max(_Tables_counter),Tables_analyzed=max(_Tables_analyzed),Tables_autoanalyzed=max(_Tables_autoanalyzed) on TimeGenerated from Start_Time to End_Time step graphgrain",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tables Analyzed Execution Count for all Databases. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_analyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed"
                          }
                        }
                      ],
                      "sortBy": [
                        {
                          "itemKey": "$._Tables_counter",
                          "sortOrder": 2
                        }
                      ],
                      "labelSettings": [
                        {
                          "columnId": "_Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "_Tables_analyzed",
                          "label": "Tables Analyzed"
                        },
                        {
                          "columnId": "_Tables_autoanalyzed",
                          "label": "Tables Auto Analyzed"
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "$._Tables_counter",
                        "sortOrder": 2
                      }
                    ],
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Tables Analyzed Execution Count  - Clusters"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated,SchemaName,TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount,DatabaseName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m),DatabaseName\r\n|make-series Tables_counter=max(_Tables_counter),Tables_analyzed=max(_Tables_analyzed),Tables_autoanalyzed=max(_Tables_autoanalyzed) on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Tables Analyzed Execution Count for {Database} Database. Data is plotted at a granularity of {ChartGrain}",
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Tables_never_analyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blueGreen"
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "greenRed"
                          }
                        }
                      ],
                      "sortBy": [
                        {
                          "itemKey": "$._Tables_counter",
                          "sortOrder": 2
                        }
                      ],
                      "labelSettings": [
                        {
                          "columnId": "_Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "_Tables_analyzed",
                          "label": "Tables Analyzed"
                        },
                        {
                          "columnId": "_Tables_autoanalyzed",
                          "label": "Tables Auto Analyzed"
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "$._Tables_counter",
                        "sortOrder": 2
                      }
                    ]
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "Tables Analyzed Execution Count - Databases"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "##### Column Details\r\n\r\n**Total Tables** : Total tables that are present in the database when Database=All is selected or Total tables that are present in the individual schema when a particular database is selected from troubleshooting guide dropdown.\r\n\r\n**Tables Analyzed** : Total tables that are manually analyzed in the database when Database=All is selected or Total tables that are manually analyzed in the individual schema when a particular database is selected from troubleshooting guide dropdown.\r\n\r\n**Tables Autoanalyzed** : Total tables that are  autoanalyzed in the database when Database=All is selected from troubleshooting guide dropdown or Total tables that are autoanalyzed in the individual schema when a particular database is selected from troubleshooting guide dropdown.\r\n\r\n**Tables Autoanalyzed[Pct]** : Tables Autoanalyzed/Total Tables *100\r\n\r\n**Tables Never Autoanalyzed[Pct]** : Tables Never Analyzed/Total Tables *100",
                    "style": "info"
                  },
                  "name": "Tables Analyzed Execution Count cluster texts"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m, {TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName in ({QualifiedDatabases})\r\n| distinct TimeGenerated, TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount,DatabaseName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m),DatabaseName\r\n|make-series Tables_counter=max(_Tables_counter) default=-1 ,Tables_analyzed=max(_Tables_analyzed) default=-1,Tables_autoanalyzed=max(_Tables_autoanalyzed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by DatabaseName\r\n| mv-expand TimeGenerated,Tables_counter, Tables_analyzed,Tables_autoanalyzed\r\n| where Tables_counter !=-1 or Tables_analyzed !=-1 or Tables_autoanalyzed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_analyzed=tolong(Tables_analyzed),Tables_autoanalyzed=tolong(Tables_autoanalyzed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autoanalyzed=Tables_counter-Tables_autoanalyzed\r\n| extend Tables_autoanalyzed_pct= iff(Tables_autoanalyzed < Tables_counter, (toreal(Tables_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| extend Tables_never_autoanalyzed_pct= iff(Tables_never_autoanalyzed < Tables_counter, (toreal(Tables_never_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| project TimeGenerated, DatabaseName, Tables_counter, Tables_analyzed, Tables_autoanalyzed, Tables_autoanalyzed_pct,Tables_never_autoanalyzed, Tables_never_autoanalyzed_pct\r\n| order by TimeGenerated, Tables_never_autoanalyzed_pct desc",
                    "size": 1,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "DatabaseName_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "DatabaseName"
                        ]
                      },
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated "
                        },
                        {
                          "columnId": "DatabaseName",
                          "label": "Database Name"
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_analyzed",
                          "label": "Tables Analyzed "
                        },
                        {
                          "columnId": "Tables_autoanalyzed",
                          "label": "Tables Autoanalyzed"
                        },
                        {
                          "columnId": "Tables_autoanalyzed_pct",
                          "label": "Tables Autoanalyzed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed",
                          "label": "Tables Never Autoanalyzed "
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed_pct",
                          "label": "Tables Never Autoanalyzed [Pct]"
                        }
                      ]
                    },
                    "sortBy": []
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "Tables Analyzed Execution Count for cluster grids"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PostgreSQLFlexTableStats}\r\n|where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where DatabaseName == '{Database}' and SchemaName in ({QualifiedSchemas})\r\n| distinct TimeGenerated, TablesCount,TablesAnalyzedCount,TablesAutoanalyzedCount,SchemaName\r\n|summarize _Tables_counter=sum(TablesCount),_Tables_analyzed=sum(TablesAnalyzedCount),_Tables_autoanalyzed=sum(TablesAutoanalyzedCount) by bin(TimeGenerated,5m),SchemaName\r\n|make-series Tables_counter=max(_Tables_counter) default=-1 ,Tables_analyzed=max(_Tables_analyzed) default=-1,Tables_autoanalyzed=max(_Tables_autoanalyzed) default=-1 on TimeGenerated from Start_Time to End_Time step graphgrain by SchemaName\r\n| mv-expand TimeGenerated,Tables_counter, Tables_analyzed,Tables_autoanalyzed\r\n| where Tables_counter !=-1 or Tables_analyzed !=-1 or Tables_autoanalyzed != -1\r\n| extend Tables_counter = tolong(Tables_counter), Tables_analyzed=tolong(Tables_analyzed),Tables_autoanalyzed=tolong(Tables_autoanalyzed), TimeGenerated=todatetime(TimeGenerated)\r\n| extend Tables_never_autoanalyzed=Tables_counter-Tables_autoanalyzed\r\n| extend Tables_autoanalyzed_pct= iff(Tables_autoanalyzed < Tables_counter, (toreal(Tables_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| extend Tables_never_autoanalyzed_pct= iff(Tables_never_autoanalyzed < Tables_counter, (toreal(Tables_never_autoanalyzed)/toreal (Tables_counter))*100,100.0)\r\n| project TimeGenerated, SchemaName, Tables_counter, Tables_analyzed, Tables_autoanalyzed, Tables_autoanalyzed_pct,Tables_never_autoanalyzed, Tables_never_autoanalyzed_pct\r\n| order by TimeGenerated, Tables_never_autoanalyzed_pct desc",
                    "size": 1,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Group",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Tables_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed",
                          "formatter": 5
                        },
                        {
                          "columnMatch": "Tables_never_autoanalyzed_pct",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "Schemaname_s",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "hierarchySettings": {
                        "treeType": 1,
                        "groupBy": [
                          "SchemaName"
                        ]
                      },
                      "labelSettings": [
                        {
                          "columnId": "TimeGenerated",
                          "label": "Time Generated"
                        },
                        {
                          "columnId": "SchemaName",
                          "label": "Schema Name"
                        },
                        {
                          "columnId": "Tables_counter",
                          "label": "Total Tables"
                        },
                        {
                          "columnId": "Tables_analyzed",
                          "label": "Tables Analyzed"
                        },
                        {
                          "columnId": "Tables_autoanalyzed",
                          "label": "Tables Autoanalyzed"
                        },
                        {
                          "columnId": "Tables_autoanalyzed_pct",
                          "label": "Tables Autoanalyzed [Pct]"
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed",
                          "label": "Tables Never Autoanalyzed "
                        },
                        {
                          "columnId": "Tables_never_autoanalyzed_pct",
                          "label": "Tables Never Autoanalyzed [Pct]"
                        }
                      ]
                    },
                    "sortBy": []
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": " Tables Analyzed Execution Count for the database grids"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the Total Tables Never Autoanalyzed[pct] column for all databases on server. If we identify a database with a high Total Tables Never Autoanalyzed[pct] value then suggest to select the identified database from the drop down in the troubleshooting guide to further drill down and analyze.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "Database",
                    "comparison": "isEqualTo",
                    "value": "All"
                  },
                  "name": "identify databases from the dropdown"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "Monitor the Total Tables Never Autoanalyzed[pct] column at schema level for selected {Database} database.\r\n\r\nHigh Total Tables Never Autoanalyzed[pct] value found. Follow the suggestions below for further analysis:\r\n\r\n1. Please consider making autovacuum_analyze_scale_factor and autovacuum_analyze_threshold more aggressive after carefully understanding the workload. Please refer to https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-autovacuum-tuning for suggestions.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "Database",
                      "comparison": "isNotEqualTo",
                      "value": "All"
                    },
                    {
                      "parameterName": "QualifiedSchemaCount",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "monitor the total tables that have not been autoanalyzed"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "vacuum-tab",
              "comparison": "isEqualTo",
              "value": "analyze"
            },
            "name": "analyze"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumanalyze"
        },
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "vacuum & analyze group section"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 9,
            "content": {
              "version": "KqlParameterItem/1.0",
              "crossComponentResources": [
                "{Resource}"
              ],
              "parameters": [
                {
                  "id": "ce0608cf-c3d2-4028-a10d-99de6533df91",
                  "version": "KqlParameterItem/1.0",
                  "name": "IsAVDataExists",
                  "type": 1,
                  "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| where database =='{Database}'\r\n|limit 5\r\n|count\r\n| extend avdata = iff(Count>0,'Yes','No')\r\n|project avdata",
                  "crossComponentResources": [
                    "{Resource}"
                  ],
                  "isHiddenWhenLocked": true,
                  "queryType": 0,
                  "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                }
              ],
              "style": "pills",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers"
            },
            "conditionalVisibility": {
              "parameterName": "x",
              "comparison": "isEqualTo",
              "value": "y"
            },
            "name": "conditional check to see if autovacuum execution should show"
          },
          {
            "type": 1,
            "content": {
              "json": "#### To view information about autovacuum execution, select a database parameter at the top of the troubleshooting guide.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "Database",
              "comparison": "isEqualTo",
              "value": "All"
            },
            "name": "check what the setting of databases is to determine rendering"
          },
          {
            "type": 1,
            "content": {
              "json": "#### It appears that there are no autovacuum entries in the PostgreSQL Server logs within the specified time range, or that the logs are not being sent to the Log Analytics workspace. Please refer to the error message at the top of the troubleshooting guide for further details.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "inform that there are no autovacuum entries"
          },
          {
            "type": 1,
            "content": {
              "json": "#### The grouping order for the grid view is as follows:\r\n\r\n**Database -> Schema -> Table**",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "the grouping order for the grid is as follows information"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| where database =='{Database}'\r\n| summarize ExecutionCount=count() by bin (TimeGenerated,1m),schema\r\n| order by TimeGenerated,ExecutionCount",
              "size": 1,
              "title": "Autovacuum Execution Count for Database {Database}",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "piechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Group",
                    "formatter": 1
                  },
                  {
                    "columnMatch": "count_",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ],
                "rowLimit": 10000,
                "hierarchySettings": {
                  "treeType": 1,
                  "groupBy": [
                    "database",
                    "schema",
                    "table"
                  ]
                }
              },
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "database",
                  "formatter": 1
                },
                "subtitleContent": {
                  "columnMatch": "schema",
                  "formatter": 1
                },
                "leftContent": {
                  "columnMatch": "count_",
                  "formatter": 12,
                  "formatOptions": {
                    "palette": "auto"
                  },
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                },
                "rightContent": {
                  "columnMatch": "table",
                  "formatter": 1
                },
                "secondaryContent": {
                  "columnMatch": "TimeGenerated"
                },
                "showBorder": true,
                "sortCriteriaField": "count_",
                "sortOrderField": 2
              },
              "chartSettings": {
                "showLegend": true,
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 17,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                }
              },
              "mapSettings": {
                "locInfo": "LatLong",
                "sizeSettings": "count_",
                "sizeAggregation": "Sum",
                "legendMetric": "count_",
                "legendAggregation": "Sum",
                "itemColorSettings": {
                  "type": "heatmap",
                  "colorAggregation": "Sum",
                  "nodeColorField": "count_",
                  "heatmapPalette": "greenRed"
                }
              }
            },
            "customWidth": "50",
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "conditional checks for the final section showing"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let graphgrain=iff({TimeRange:grain}<30m,30m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{PostgreSQLLogs}\r\n| where TimeGenerated >= TimeStart and TimeGenerated <= TimeEnd\r\n| where Message contains \"automatic vacuum of table\"\r\n| distinct TimeGenerated,Message\r\n| extend database_schema_table = extract_all(@\"automatic vacuum of table \"\"(?P<database>[^.\"\"]+)+\\.(?P<schema>[^.]+)\\.(?P<table>[^\"\"]+)\"\"\", Message)\r\n| extend database_schema_table=substring(tostring(database_schema_table), 1, strlen(tostring(database_schema_table))-2)\r\n| extend database_schema_table = todynamic(database_schema_table)\r\n| extend database = tostring(database_schema_table[0]), schema = tostring(database_schema_table[1]), table = tostring(database_schema_table[2])\r\n| project TimeGenerated, database, schema,table\r\n| where database !in('azure_sys','azure_maintenance')\r\n| summarize ExecutionCount=count() by bin (TimeGenerated,graphgrain),schema,table\r\n| order by TimeGenerated,ExecutionCount",
              "size": 1,
              "title": "Autovacuum Execution Count by Schema for Database {Database}",
              "showExportToExcel": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "table",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Group",
                    "formatter": 1
                  },
                  {
                    "columnMatch": "count_",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 17,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ],
                "rowLimit": 10000,
                "filter": true,
                "hierarchySettings": {
                  "treeType": 1,
                  "groupBy": [
                    "schema",
                    "table"
                  ],
                  "expandTopLevel": false
                }
              },
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "database",
                  "formatter": 1
                },
                "subtitleContent": {
                  "columnMatch": "schema",
                  "formatter": 1
                },
                "leftContent": {
                  "columnMatch": "count_",
                  "formatter": 12,
                  "formatOptions": {
                    "palette": "auto"
                  },
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                },
                "rightContent": {
                  "columnMatch": "table",
                  "formatter": 1
                },
                "secondaryContent": {
                  "columnMatch": "TimeGenerated"
                },
                "showBorder": true,
                "sortCriteriaField": "count_",
                "sortOrderField": 2
              },
              "chartSettings": {
                "createOtherGroup": 100,
                "showLegend": true
              },
              "mapSettings": {
                "locInfo": "LatLong",
                "sizeSettings": "count_",
                "sizeAggregation": "Sum",
                "legendMetric": "count_",
                "legendAggregation": "Sum",
                "itemColorSettings": {
                  "type": "heatmap",
                  "colorAggregation": "Sum",
                  "nodeColorField": "count_",
                  "heatmapPalette": "greenRed"
                }
              }
            },
            "customWidth": "50",
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "warnings for the final section and parameters which check for them"
          },
          {
            "type": 1,
            "content": {
              "json": "The graph and grid view displayed above present valuable insights into the frequency of autovacuum worker executions within a database.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "Database",
                "comparison": "isNotEqualTo",
                "value": "All"
              },
              {
                "parameterName": "IsAVDataExists",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "the graph and grid displayed above information"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "QualifiedDatabasesCount",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "vacuumworkers"
        }
      ],
      "name": "autovacuum workers in progress"
    }
  ],
  "fallbackResourceIds": [],
  "$schema": "https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json"
}