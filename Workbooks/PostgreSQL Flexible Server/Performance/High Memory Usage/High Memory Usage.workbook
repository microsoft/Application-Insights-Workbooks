{
  "version": "Notebook/1.0",
  "items": [
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "## Optimizing high memory utilization\r\n\r\nThe aim of this troubleshooting guide is to pinpoint potential reasons for high memory usage and suggest solutions to alleviate the issue.\r\n\r\nHigh memory utilization may arise from various factors, such as a surge in workload, memory-intensive queries, or a rise in the number of server connections.\r\n\r\nThe following table outlines the step-by-step approach to using the troubleshooting guide to investigate server behavior and improve memory usage.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
              "style": "info"
            },
            "name": "high memory intial heading"
          },
          {
            "type": 1,
            "content": {
              "json": " Step | Description\r\n--- | ---\r\n**Analysis period** | Choose the time interval that you wish to analyze.\r\n**Memory** | Monitor the memory usage on the server. Any sudden increase in values, in comparison to previous time intervals, should be viewed as abnormal and needs further investigation.\r\n**Workload** | Analyze and understand what proportion of `read` and `write` your workload is composed of. Read workload includes all reads made by any type of statement, not only SELECTs. While write workload includes all modifications (inserts, deletes or updates) made by any type of statement, including SELECTs. Compare the CPU spike seen in **CPU** step with read and write workloads. Any spike in workload during the window of interest points to increased workload on server.\r\n**Sessions** | Find process identifiers (PIDs) of the sessions that have been running for too long. Follow the suggested mitigation measures outlined in the section and monitor memory usage accordingly.\r\n**Queries** | Identify the top queries by data usage during the period of interes. Follow mitigation steps suggested in the tab and monitor data usage.\r\n**User connections** | Understand the connectivity patterns of your client applications. Follow mitigation steps suggested in the tab and continue to monitor memory usage.\r\n**Memory parameters** | Use the `Memory parameters`tab to validate that `work_mem`, `maintenance_work_mem`, `shared_buffers`, `max_connections`, and `max_locks_per_transaction` server parameters are appropriately configured on the server."
            },
            "name": "high memory guidance",
            "styleSettings": {
              "margin": "100",
              "padding": "100"
            }
          }
        ],
        "exportParameters": true
      },
      "name": "WorkbookHeader"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Start by setting the following parameters:"
      },
      "name": "high memory parameter set all"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Subscription}"
        ],
        "parameters": [
          {
            "id": "6573f642-b4c6-4a56-8bdd-8ef451b7bdf5",
            "version": "KqlParameterItem/1.0",
            "name": "Resource",
            "type": 5,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "typeSettings": {
              "additionalResourceOptions": [],
              "showDefault": false,
              "componentIdOnly": true
            }
          },
          {
            "id": "9ebd8e9a-5e9c-496a-bdb1-e41b9faaf9ad",
            "version": "KqlParameterItem/1.0",
            "name": "TimeRange",
            "type": 4,
            "isRequired": true,
            "isGlobal": true,
            "value": {
              "durationMs": 2419200000
            },
            "typeSettings": {
              "selectableValues": [
                {
                  "durationMs": 3600000
                },
                {
                  "durationMs": 14400000
                },
                {
                  "durationMs": 43200000
                },
                {
                  "durationMs": 86400000
                },
                {
                  "durationMs": 172800000
                },
                {
                  "durationMs": 259200000
                },
                {
                  "durationMs": 604800000
                },
                {
                  "durationMs": 1209600000
                },
                {
                  "durationMs": 2419200000
                }
              ],
              "allowCustom": true
            },
            "timeContext": {
              "durationMs": 86400000
            },
            "label": "Analysis period (local time)"
          },
          {
            "id": "233ae05f-0f3d-4463-b8ec-579074b35c53",
            "version": "KqlParameterItem/1.0",
            "name": "MIN_TIME_WINDOW_SEC",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "3600"
                }
              }
            ]
          },
          {
            "id": "655143e7-f5f6-4d8a-81f9-9aa8c49e2520",
            "version": "KqlParameterItem/1.0",
            "name": "READ_WORKLOAD_SPIKE_TUP_RETURNED_PCT",
            "type": 1,
            "description": "Defines the minimum % difference in tuples returned between intervals to classify a read workload spike. ",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "50"
                }
              }
            ]
          },
          {
            "id": "e43a4f05-b912-4815-870d-e22141b050fc",
            "version": "KqlParameterItem/1.0",
            "name": "WINDOW_SIZE_FOR_QUERY_TIME_CAPTURE",
            "type": 1,
            "description": "Specifies aggregation window to capture max query time for high time consuming queries ",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "30m"
                }
              }
            ]
          },
          {
            "id": "ae53554f-de54-4978-8204-a7f1147a8ad1",
            "version": "KqlParameterItem/1.0",
            "name": "SHORT_CONNECTION_DURATION",
            "type": 1,
            "description": "Defines the max time a connection may exist and be classified as short lived ",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "1s"
                }
              }
            ]
          },
          {
            "id": "5d46fb4c-f381-429f-8395-fcff2e7bf1f9",
            "version": "KqlParameterItem/1.0",
            "name": "LONG_CONNECTION_DURATION",
            "type": 1,
            "description": "Defines the minimum time a connection may exist before it is classified as long lived",
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "20m"
                }
              }
            ]
          },
          {
            "id": "089a8ccf-b6cb-4f68-adff-2bef115928ae",
            "version": "KqlParameterItem/1.0",
            "name": "QueryStoreTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} - 1h and TimeGenerated <= {TimeRange:end} + 1h | where Category =='PostgreSQLFlexQueryStoreRuntime' | project TimeGenerated, Resource, RuntimeStatsEntryId = tolong(     iff(isnotempty(AdditionalFields.Runtime_stats_entry_id), AdditionalFields.Runtime_stats_entry_id,         column_ifexists('Runtime_stats_entry_id_d',             column_ifexists('Runtime_stats_entry_id',                 column_ifexists('Runtime_stats_entry_id_s', \"\")             )         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Userid), AdditionalFields.Userid,         column_ifexists('Userid_d',             column_ifexists('Userid',                 column_ifexists('Userid_s', \"\")             )         )     ) ), DatabaseId = toint(     iff(isnotempty(AdditionalFields.Dbid), AdditionalFields.Dbid,         column_ifexists('Dbid_d',             column_ifexists('Dbid',                 column_ifexists('Dbid_s', \"\")             )         )     ) ), QueryId = iff(isnotempty(AdditionalFields.Queryid_str), todecimal(AdditionalFields.Queryid_str),  iff(isnotempty(AdditionalFields.Queryid), todecimal(AdditionalFields.Queryid), iff(isnotempty(column_ifexists('Queryid_str_s',\"\")), todecimal(column_ifexists('Queryid_str_s',\"\")),  iff(isnotempty(column_ifexists('Queryid_d',\"\")), todecimal(column_ifexists('Queryid_d',\"\")), iff(isnotempty(column_ifexists('Queryid',\"\")), todecimal(column_ifexists('Queryid', \"\")), todecimal(column_ifexists('Queryid_s', \"\"))))))), PlanId = tolong(     iff(isnotempty(AdditionalFields.Plan_id), AdditionalFields.Plan_id,         column_ifexists('Plan_id_d',             column_ifexists('Plan_id_s',                 column_ifexists('Plan_id', \"\")             )         )     ) ), StartTime = todatetime(     iff(isnotempty(AdditionalFields.Start_time), AdditionalFields.Start_time,         column_ifexists('Start_time_t',             column_ifexists('Start_time',                 column_ifexists('Start_time_s', \"\")             )         )     ) ), EndTime = todatetime(     iff(isnotempty(AdditionalFields.End_time), AdditionalFields.End_time,         column_ifexists('End_time_t',             column_ifexists('End_time',                 column_ifexists('End_time_s', \"\")             )         )     ) ), Calls = tolong(     iff(isnotempty(AdditionalFields.Calls), AdditionalFields.Calls,         column_ifexists('Calls_d',             column_ifexists('Calls',                 column_ifexists('Calls_s', \"\")             )         )     ) ), TotalExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Total_time), AdditionalFields.Total_time,         column_ifexists('Total_time_d',             column_ifexists('Total_time',                 column_ifexists('Total_time_s', \"\")             )         )     ) ), MinExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Min_time), AdditionalFields.Min_time,         column_ifexists('Min_time_d',             column_ifexists('Min_time',                 column_ifexists('Min_time_s', \"\")             )         )     ) ), MaxExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Max_time), AdditionalFields.Max_time,         column_ifexists('Max_time_d',             column_ifexists('Max_time',                 column_ifexists('Max_time_s', \"\")             )         )     ) ), MeanExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Mean_time), AdditionalFields.Mean_time,         column_ifexists('Mean_time_d',             column_ifexists('Mean_time',                 column_ifexists('Mean_time_s', \"\")             )         )     ) ), StdDevExecDurationMs = todouble(     iff(isnotempty(AdditionalFields.Stddev_time), AdditionalFields.Stddev_time,         column_ifexists('Stddev_time_d',             column_ifexists('Stddev_time',                 column_ifexists('Stddev_time_s', \"\")             )         )     ) ), Rows = tolong(     iff(isnotempty(AdditionalFields.Rows), AdditionalFields.Rows,         column_ifexists('Rows_d',             column_ifexists('Rows',                 column_ifexists('Rows_s', \"\")             )         )     ) ), SharedBlksHit = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_hit), AdditionalFields.Shared_blks_hit,         column_ifexists('Shared_blks_hit_d',             column_ifexists('Shared_blks_hit',                 column_ifexists('Shared_blks_hit_s', \"\")             )         )     ) ), SharedBlksRead = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_read), AdditionalFields.Shared_blks_read,         column_ifexists('Shared_blks_read_d',             column_ifexists('Shared_blks_read',                 column_ifexists('Shared_blks_read_s', \"\")             )         )     ) ), SharedBlksDirtied = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_dirtied), AdditionalFields.Shared_blks_dirtied,         column_ifexists('Shared_blks_dirtied_d',             column_ifexists('Shared_blks_dirtied',                 column_ifexists('Shared_blks_dirtied_s', \"\")             )         )     ) ), SharedBlksWritten = tolong(     iff(isnotempty(AdditionalFields.Shared_blks_written), AdditionalFields.Shared_blks_written,         column_ifexists('Shared_blks_written_d',             column_ifexists('Shared_blks_written',                 column_ifexists('Shared_blks_written_s', \"\")             )         )     ) ), LocalBlksHit = tolong(     iff(isnotempty(AdditionalFields.Local_blks_hit), AdditionalFields.Local_blks_hit,         column_ifexists('Local_blks_hit_d',             column_ifexists('Local_blks_hit',                 column_ifexists('Local_blks_hit_s', \"\")             )         )     ) ), LocalBlksRead = tolong(     iff(isnotempty(AdditionalFields.Local_blks_read), AdditionalFields.Local_blks_read,         column_ifexists('Local_blks_read_d',             column_ifexists('Local_blks_read',                 column_ifexists('Local_blks_read_s', \"\")             )         )     ) ), LocalBlksDirtied = tolong(     iff(isnotempty(AdditionalFields.Local_blks_dirtied), AdditionalFields.Local_blks_dirtied,         column_ifexists('Local_blks_dirtied_d',             column_ifexists('Local_blks_dirtied',                 column_ifexists('Local_blks_dirtied_s', \"\")             )         )     ) ), LocalBlksWritten = tolong(     iff(isnotempty(AdditionalFields.Local_blks_written), AdditionalFields.Local_blks_written,         column_ifexists('Local_blks_written_d',             column_ifexists('Local_blks_written',                 column_ifexists('Local_blks_written_s', \"\")             )         )     ) ), TempBlksRead = tolong(     iff(isnotempty(AdditionalFields.Temp_blks_read), AdditionalFields.Temp_blks_read,         column_ifexists('Temp_blks_read_d',             column_ifexists('Temp_blks_read',                 column_ifexists('Temp_blks_read_s', \"\")             )         )     ) ), TempBlksWritten = tolong(     iff(isnotempty(AdditionalFields.Temp_blks_written), AdditionalFields.Temp_blks_written,         column_ifexists('Temp_blks_written_d',             column_ifexists('Temp_blks_written',                 column_ifexists('Temp_blks_written_s', \"\")             )         )     ) ), BlkReadTime = todouble(     iff(isnotempty(AdditionalFields.Blk_read_time), AdditionalFields.Blk_read_time,         column_ifexists('Blk_read_time_d',             column_ifexists('Blk_read_time',                 column_ifexists('Blk_read_time_s', \"\")             )         )     ) ), BlkWriteTime = todouble(     iff(isnotempty(AdditionalFields.Blk_write_time), AdditionalFields.Blk_write_time,         column_ifexists('Blk_write_time_d',             column_ifexists('Blk_write_time',                 column_ifexists('Blk_write_time_s', \"\")             )         )     ) ), IsSystemQuery = tobool(     iff(isnotempty(AdditionalFields.Is_system_query), AdditionalFields.Is_system_query,         column_ifexists('Is_system_query_b',             column_ifexists('Is_system_query',                 column_ifexists('Is_system_query_s', \"\")             )         )     ) ), QueryType = tostring(     iff(isnotempty(AdditionalFields.Query_type), AdditionalFields.Query_type,         column_ifexists('Query_type_s',             column_ifexists('Query_type', \"\")         )     ) )"
                }
              }
            ]
          },
          {
            "id": "e5f4fc66-344a-4a21-b495-f5cc20c3ec1a",
            "version": "KqlParameterItem/1.0",
            "name": "SessionsTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category =='PostgreSQLFlexSessions' | project TimeGenerated, Resource, DatabaseId = toint(     iff(isnotempty(AdditionalFields.Datid), AdditionalFields.Datid,         column_ifexists('Datid_d',             column_ifexists('Datid_s',                 column_ifexists('Datid', \"\")             )         )     )     ), DatabaseName = tostring(     iff(isnotempty(AdditionalFields.Database_name), AdditionalFields.Database_name,         column_ifexists('Database_name_s',            column_ifexists('Database_name', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.Pid), AdditionalFields.Pid,         column_ifexists('Pid_d',            column_ifexists('Pid', \"\")         )     ) ), UserId = toint(     iff(isnotempty(AdditionalFields.Usesysid), AdditionalFields.Usesysid,         column_ifexists('Usesysid_d',             column_ifexists('Usesysid_s',                 column_ifexists('Usesysid', \"\")             )         )     )     ), ApplicationName = tostring(     iff(isnotempty(AdditionalFields.Application_name), AdditionalFields.Application_name,         column_ifexists('Application_name_s',            column_ifexists('Application_name', \"\")         )     ) ), ClientIpAddress = tostring(     iff(isnotempty(AdditionalFields.Client_addr), AdditionalFields.Client_addr,         column_ifexists('Client_addr_s',            column_ifexists('Client_addr', \"\")         )     ) ), State = tostring(     iff(isnotempty(AdditionalFields.State), AdditionalFields.State,         column_ifexists('State_s',            column_ifexists('State', \"\")         )     ) ), WaitEventType = tostring(     iff(isnotempty(AdditionalFields.Wait_event_type), AdditionalFields.Wait_event_type,         column_ifexists('Wait_event_type_s',            column_ifexists('Wait_event_type', \"\")         )     ) ), WaitEvent = tostring(     iff(isnotempty(AdditionalFields.Wait_event), AdditionalFields.Wait_event,         column_ifexists('Wait_event_s',            column_ifexists('Wait_event', \"\")         )     ) ), BackendStartTime = todatetime(     iff(isnotempty(AdditionalFields.Backend_start), AdditionalFields.Backend_start,         column_ifexists('Backend_start_t',             column_ifexists('Backend_start',                 column_ifexists('Backend_start_s', \"\")             )         )     ) ), TransactionStartTime = todatetime(     iff(isnotempty(AdditionalFields.Xact_start), AdditionalFields.Xact_start,         column_ifexists('Xact_start_t',             column_ifexists('Xact_start_s',                 column_ifexists('Xact_start', \"\")             )         )     ) ), QueryStartTime = todatetime(     iff(isnotempty(AdditionalFields.Query_start), AdditionalFields.Query_start,         column_ifexists('Query_start_t',             column_ifexists('Query_start_s',                 column_ifexists('Query_start', \"\")             )         )     ) ), StateChangeTime = todatetime(     iff(isnotempty(AdditionalFields.State_change), AdditionalFields.State_change,         column_ifexists('State_change_t',             column_ifexists('State_change_s',                 column_ifexists('State_change', \"\")             )         )     ) ), CollectionTime = todatetime(     iff(isnotempty(AdditionalFields.Collection_time), AdditionalFields.Collection_time,         column_ifexists('Collection_time_t',             column_ifexists('Collection_time_s',                 column_ifexists('Collection_time', \"\")             )         )     ) ), TransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xid), AdditionalFields.Backend_xid,         column_ifexists('Backend_xid_d',             column_ifexists('Backend_xid_s',                 column_ifexists('Backend_xid', \"\")             )         )     ) ), OldestTransactionId = tolong(     iff(isnotempty(AdditionalFields.Backend_xmin), AdditionalFields.Backend_xmin,         column_ifexists('Backend_xmin_d',             column_ifexists('Backend_xmin_s',                 column_ifexists('Backend_xmin', \"\")             )         )     ) ), BackendType = tostring(     iff(isnotempty(AdditionalFields.Backend_type), AdditionalFields.Backend_type,         column_ifexists('Backend_type_s',            column_ifexists('Backend_type', \"\")         )     ) )"
                }
              }
            ]
          },
          {
            "id": "50d73c33-57bd-4010-b262-b1b32cf9be16",
            "version": "KqlParameterItem/1.0",
            "name": "PGServerLogsTable",
            "type": 1,
            "isRequired": true,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "AzureDiagnostics | where TimeGenerated >= {TimeRange:start} and TimeGenerated <= {TimeRange:end} | where Category =='PostgreSQLLogs' | project TimeGenerated, Resource, Timestamp = tostring(     iff(isnotempty(AdditionalFields.timestamp), AdditionalFields.timestamp,         column_ifexists('timestamp_s',            column_ifexists('timestamp', \"\")         )     ) ), ProcessId = toint(     iff(isnotempty(AdditionalFields.processId), AdditionalFields.processId,         column_ifexists('processId_d',             column_ifexists('processId_s',                 column_ifexists('processId', \"\")             )         )     ) ), ErrorLevel = tostring(     iff(isnotempty(AdditionalFields.errorLevel), AdditionalFields.errorLevel,         column_ifexists('errorLevel_s',            column_ifexists('errorLevel', \"\")         )     ) ), SqlErrorCode = tostring(     iff(isnotempty(AdditionalFields.sqlerrcode), AdditionalFields.sqlerrcode,         column_ifexists('sqlerrcode_s',            column_ifexists('sqlerrcode', \"\")         )     ) ), Message = tostring(     iff(isnotempty(AdditionalFields.message), AdditionalFields.message,         column_ifexists('Message',            column_ifexists('message_s', \"\")         )     ) ), Detail = tostring(     iff(isnotempty(AdditionalFields.detail), AdditionalFields.detail,         column_ifexists('detail_s',            column_ifexists('detail', \"\")         )     ) ), Hint = tostring(     iff(isnotempty(AdditionalFields.hint), AdditionalFields.hint,         column_ifexists('hint_s',            column_ifexists('hint', \"\")         )     ) ), Query = tostring(     iff(isnotempty(AdditionalFields.query), AdditionalFields.query,         column_ifexists('query_s',            column_ifexists('query', \"\")         )     ) ), Context = tostring(     iff(isnotempty(AdditionalFields.context), AdditionalFields.context,         column_ifexists('context_s',            column_ifexists('context', \"\")         )     ) ), Statement = tostring(     iff(isnotempty(AdditionalFields.statement), AdditionalFields.statement,         column_ifexists('statement_s',            column_ifexists('statement', \"\")         )     ) ), SchemaName = tostring(     iff(isnotempty(AdditionalFields.schema_name), AdditionalFields.schema_name,         column_ifexists('schema_name_s',            column_ifexists('schema_name', \"\")         )     ) ), TableName = tostring(     iff(isnotempty(AdditionalFields.table_name), AdditionalFields.table_name,         column_ifexists('table_name_s',            column_ifexists('table_name', \"\")         )     ) ), ColumnName = tostring(     iff(isnotempty(AdditionalFields.column_name), AdditionalFields.column_name,         column_ifexists('column_name_s',            column_ifexists('column_name', \"\")         )     ) ), DatatypeName = tostring(     iff(isnotempty(AdditionalFields.datatype_name), AdditionalFields.datatype_name,         column_ifexists('datatype_name_s',            column_ifexists('datatype_name', \"\")         )     ) ), ConstraintName = tostring(     iff(isnotempty(AdditionalFields.constraint_name), AdditionalFields.constraint_name,         column_ifexists('constraint_name_s',            column_ifexists('constraint_name', \"\")         )     ) )"
                }
              }
            ]
          },
          {
            "id": "bfdc4660-2f41-45fb-b2f2-52df7b9afe9d",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimaryAPI",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$..properties..replicationRole\",\"columns\":[]}}]}",
            "isHiddenWhenLocked": true,
            "queryType": 12,
            "value": null
          },
          {
            "id": "7eebfb68-bca9-4489-a30a-9000d4a3f139",
            "version": "KqlParameterItem/1.0",
            "name": "IsServerPrimaryCheck",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsServerPrimaryAPI",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "Primary",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ]
          },
          {
            "id": "ad308bb5-3ef0-4239-bb1f-4917dd61ead8",
            "version": "KqlParameterItem/1.0",
            "name": "long_idle_sessions_threshold_hour",
            "type": 1,
            "isHiddenWhenLocked": true,
            "criteriaData": [
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "24"
                }
              }
            ]
          }
        ],
        "style": "above",
        "queryType": 1,
        "resourceType": "microsoft.resourcegraph/resources"
      },
      "name": "high memory all parameters"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "f25f8d3a-a6c6-4e4e-928a-48c2848c2377",
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetEnabledGroups",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.categoryGroup!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.categoryGroup\",\"columnid\":\"CategoryGroup\"}]}}]}",
            "queryType": 12,
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "AzureDiagnosticsGetAllEnabledCategories",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/providers/Microsoft.Insights/diagnosticSettings?api-version=2021-05-01-preview\",\"urlParams\":[],\"batchDisabled\":false,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"$.value[?(@.properties.workspaceId!=null )].properties.logs[?(@.category!=null&&@.enabled==true)]\",\"columns\":[{\"path\":\"$.category\",\"columnid\":\"Category\"}]}}]}",
            "queryType": 12,
            "id": "8fee2560-e789-42b1-9d18-0c9dea8c23cc"
          },
          {
            "id": "5532b5f0-37c7-448d-9d54-57a5bef6d9a7",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricsCollectorDatabaseActivityOn",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/metrics.collector_database_activity?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^ON|on|On$\",\"substringReplace\":\"ON\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "value": null
          },
          {
            "id": "19084cea-df53-4686-8be8-24e01d204bc0",
            "version": "KqlParameterItem/1.0",
            "name": "IsMetricCollectorON",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "IsMetricsCollectorDatabaseActivityOn",
                  "operator": "==",
                  "rightValType": "static",
                  "rightVal": "ON",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "id": "b9cb29ff-a3f6-439e-8c89-92078ef449e2",
            "version": "KqlParameterItem/1.0",
            "name": "IsQueryStoreRuntimeSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexQueryStoreRuntime",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "id": "008959b3-85f0-49b7-810b-c1813739baaa",
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLFlexSessions",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "id": "6d2342b4-a239-4458-b7c9-3c04cde9f4be",
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLLogsSentToLogAnalytics",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "allLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetEnabledGroups",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "audit",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "leftOperand": "AzureDiagnosticsGetAllEnabledCategories",
                  "operator": "contains",
                  "rightValType": "static",
                  "rightVal": "PostgreSQLLogs",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "QueryStoreCheck",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/pg_qs.query_capture_mode?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"tablePath\":\"\",\"columns\":[{\"path\":\"$..value\",\"columnid\":\"value\",\"substringRegexMatch\":\"^None|NONE|none$\",\"substringReplace\":\"none\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "69ecdf81-be11-4ba3-a80b-abc2478d24ee",
            "value": null
          },
          {
            "id": "e08af3d9-94fc-48d3-9eb6-2e38e1eda130",
            "version": "KqlParameterItem/1.0",
            "name": "isQueryStoreEnabled",
            "type": 1,
            "criteriaData": [
              {
                "criteriaContext": {
                  "leftOperand": "QueryStoreCheck",
                  "operator": "!=",
                  "rightValType": "static",
                  "rightVal": "none",
                  "resultValType": "static",
                  "resultVal": "Yes"
                }
              },
              {
                "criteriaContext": {
                  "operator": "Default",
                  "resultValType": "static",
                  "resultVal": "No"
                }
              }
            ],
            "timeContext": {
              "durationMs": 86400000
            }
          },
          {
            "id": "920c2aea-7eb3-4415-aff4-ed7fec1a19ba",
            "version": "KqlParameterItem/1.0",
            "name": "fetch_work_mem",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/work_mem?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..value\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_work_mem_default",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/work_mem?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..defaultValue\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "b8226629-8b07-41e6-b947-d52b9d085e5f",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_maintenance_work_mem",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/maintenance_work_mem?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..value\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "90018e16-7d46-4073-b2ce-708146cea7ef",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_maintenance_work_mem_default",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/maintenance_work_mem?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..defaultValue\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "0ec78afd-1098-4298-86b5-b6aa3dc45f15",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_shared_buffers",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/shared_buffers?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..value\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "8617b6c3-7fef-4d95-9357-f5ba29cb295c",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_shared_buffers_default",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/shared_buffers?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..defaultValue\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "2c6a73da-e666-4612-915d-87f6652dfedd",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_max_locks_per_transaction",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/max_locks_per_transaction?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..value\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "4c07c573-ab88-45e5-9116-79d31f81c097",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_max_locks_per_transaction_default",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/max_locks_per_transaction?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..defaultValue\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "adc64e4d-f9a9-4c08-939b-929fe8ac9711",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_work_mem",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_work_mem?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..value\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "abf28344-9506-4d2b-bb6f-73a763a881d0",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_work_mem_default",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_work_mem?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..defaultValue\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "15ef9968-7f12-4252-9d4b-d2a5ba1169f8",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_max_workers",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_max_workers?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..value\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "78f4b492-29ce-4c98-bf5b-07ea06936b37",
            "value": null
          },
          {
            "version": "KqlParameterItem/1.0",
            "name": "fetch_autovacuum_max_workers_default",
            "type": 1,
            "query": "{\"version\":\"ARMEndpoint/1.0\",\"data\":null,\"headers\":[],\"method\":\"GET\",\"path\":\"{Resource}/configurations/autovacuum_max_workers?api-version=2022-12-01\",\"urlParams\":[],\"batchDisabled\":true,\"transformers\":[{\"type\":\"jsonpath\",\"settings\":{\"columns\":[{\"path\":\"$..defaultValue\",\"columnid\":\"Name\"}]}}]}",
            "timeContext": {
              "durationMs": 86400000
            },
            "queryType": 12,
            "id": "6a85db9e-fcca-4d89-b8dc-af000f06a8b4",
            "value": null
          },
          {
            "id": "93d826ee-df7c-4339-9f7c-3cd2592a0098",
            "version": "KqlParameterItem/1.0",
            "name": "validate_memory_parameters",
            "type": 1,
            "query": "let work_mem_value = {fetch_work_mem}; \r\nlet default_work_mem = {fetch_work_mem_default};\r\n\r\nlet maintenance_work_mem_value = {fetch_maintenance_work_mem}; \r\nlet default_maintenance_work_mem = {fetch_maintenance_work_mem_default};\r\n\r\nlet shared_buffers_value = {fetch_shared_buffers}; \r\nlet default_shared_buffers = {fetch_shared_buffers_default};\r\n\r\nlet max_locks_per_transaction_value = {fetch_max_locks_per_transaction}; \r\nlet default_max_locks_per_transaction = {fetch_max_locks_per_transaction_default};\r\n\r\nlet autovacuum_work_mem_value = {fetch_autovacuum_work_mem} ; \r\nlet default_autovacuum_work_mem = {fetch_autovacuum_work_mem_default} ;\r\n\r\nlet autovacuum_max_workers_value = {fetch_autovacuum_max_workers}; \r\nlet default_autovacuum_max_workers = {fetch_autovacuum_max_workers_default} ;\r\n\r\nlet HasChanged = strcat(\r\n    iff(work_mem_value > default_work_mem, strcat('work_mem', ', '), ''), \r\n    iff(maintenance_work_mem_value > default_maintenance_work_mem, strcat('maintenance_work_mem', ', '), ''), \r\n    iff(shared_buffers_value > default_shared_buffers, strcat('shared_buffers', ', '), ''), \r\n    iff(max_locks_per_transaction_value > default_max_locks_per_transaction, strcat('max_locks_per_transaction', ', '), ''), \r\n    iff(autovacuum_work_mem_value > default_autovacuum_work_mem, strcat('autovacuum_work_mem', ', '), ''), \r\n    iff(autovacuum_max_workers_value > default_autovacuum_max_workers, strcat('autovacuum_max_workers', ', '), '')\r\n);\r\n\r\nprint iff(strlen(HasChanged) > 0, trim(',', HasChanged), \"No\");\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": " high memory validationsparameters"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "### Query Store is currently disabled\r\nThis troubleshooting guide depends on Query Store data. You need to enable it by setting the dynamic server parameter `pg_qs.query_capture_mode` to either ALL or TOP. Refer to this guide for detailed instructions: https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-query-store",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "isQueryStoreEnabled",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high memory QS disabled error"
          },
          {
            "type": 1,
            "content": {
              "json": "### The Query Store data is not being transmitted to the log analytics workspace\r\nThe Query Store data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for Query Store categories(`PostgreSQL Query Store Runtime`) and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "isQueryStoreEnabled",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high memory QS loganalytics error"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL server logs data is not being transmitted to the log analytics workspace\r\nThe PostgreSQL server logs data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Server Logs` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsPostgreSQLLogsSentToLogAnalytics",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high memory pglogs error"
          },
          {
            "type": 1,
            "content": {
              "json": "### The PostgreSQL Sessions logs data is not being transmitted to the log analytics workspace\r\nThe PostgreSQL Sessions logs data is not being sent to the log analytics workspace, which is necessary to use this troubleshooting guide. To configure the logging settings for category `PostgreSQL Sessions` and send the data to a log analytics workspace, please refer to this guide for detailed instructions: https://learn.microsoft.com/azure/postgresql/flexible-server/howto-configure-and-access-logs.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high memory pgsession error"
          },
          {
            "type": 1,
            "content": {
              "json": "### Enhanced metrics are currently disabled.\r\nThis Troubleshooting guide requires the use of enhanced metrics. To activate these metrics, simply enable the dynamic server parameter `metrics.collector_database_activity`.",
              "style": "error"
            },
            "conditionalVisibility": {
              "parameterName": "IsMetricCollectorON",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high memory enhanced metrics error"
          },
          {
            "type": 1,
            "content": {
              "json": "### Query tracking through `log_min_duration_statement` is currently disabled\r\nTo enable query tracking, you can set an appropriate threshold for the `log_min_duration_statement` parameter and properly configure `log_line_prefix` parameter to include the relevant details such as **%t-%c user=%u,db=%d,app=%a,client=%h**  through the Azure portal. This dynamic parameter determines the minimum duration of a query before it's logged in the PostgreSQL server logs. \r\n",
              "style": "error"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "IsLogMinDurationStatementEnabled",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "high memory Log min duration Error"
          }
        ],
        "exportParameters": true
      },
      "name": "high memory log min error"
    },
    {
      "type": 9,
      "content": {
        "version": "KqlParameterItem/1.0",
        "crossComponentResources": [
          "{Resource}"
        ],
        "parameters": [
          {
            "id": "62507ec3-c7bd-4ef2-b0c5-69eddf960a36",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalEndTime",
            "type": 1,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\n\r\nlet dt = {TimeRange:end};\r\nprint iff(dt<now(), dt, now())\r\n\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "25ec8def-09e9-4f9a-9b24-ac5fbe85ebf2",
            "version": "KqlParameterItem/1.0",
            "name": "GlobalStartTime",
            "type": 1,
            "query": "// GlobalEndTime will always equal TimeRange:end\r\n// In the case which selected interval is less than an hour, \r\n// we set GlobalStartTime to be an hour before GlobalEndTime\r\n// in order to avoid showing data \"in the future\".\r\n//print iff(true, totimespan({TimeRange:end}), totimespan({TimeRange:end}))\r\nprint iff (datetime_diff('second',{TimeRange:end},{TimeRange:start})<={MIN_TIME_WINDOW_SEC},todatetime('{GlobalEndTime}')-{MIN_TIME_WINDOW_SEC}s,{TimeRange:start})",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "477ec0d7-9343-498c-9124-6ab8e638c20c",
            "version": "KqlParameterItem/1.0",
            "name": "LessThanOneHourInterval",
            "type": 1,
            "query": "let interval = 1h;\r\nprint iff({TimeRange:end} - {TimeRange:start} < interval, \"Yes\", \"No\")",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "12190a81-5bc8-482b-a8e7-0848ca226af0",
            "version": "KqlParameterItem/1.0",
            "name": "ChartGrain",
            "type": 1,
            "query": "let trange=iff({TimeRange:grain}<15m,15m, {TimeRange:grain});\r\nprint case(\r\n    trange<1h, strcat(format_timespan(trange,'m'),' minute(s)'),\r\n    trange>=1h and trange<1d, strcat(format_timespan(trange,'H'),' hour(s)') ,\r\n    strcat(format_timespan(trange,'dd'),' day(s)')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "ca92282b-f0b5-4fc6-a16e-abfb25ea50d7",
            "version": "KqlParameterItem/1.0",
            "name": "MetricsGrain",
            "type": 1,
            "query": "print case(\r\n    {TimeRange:grain}<1h, strcat(format_timespan({TimeRange:grain},'m'),' minute(s)'),\r\n    {TimeRange:grain}>=1h and {TimeRange:grain}<1d, strcat(format_timespan({TimeRange:grain},'H'),' hour(s)') ,\r\n    strcat(format_timespan({TimeRange:grain},'dd'),' day(s)')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "fcb97dc5-c1da-472b-922d-85b781bc92d5",
            "version": "KqlParameterItem/1.0",
            "name": "ChartGrainMin5",
            "type": 1,
            "query": "let trange=iff({TimeRange:grain}<5m,5m,{TimeRange:grain});\r\nprint case(\r\n    trange<1h, strcat(format_timespan(trange,'m'),' minute(s)'),\r\n    trange>=1h and trange<1d, strcat(format_timespan(trange,'H'),' hour(s)') ,\r\n    strcat(format_timespan(trange,'dd'),' day(s)')\r\n);",
            "crossComponentResources": [
              "{Resource}"
            ],
            "timeContext": {
              "durationMs": 0
            },
            "timeContextFromParameter": "TimeRange",
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "b0de7bc2-e822-4ca6-9f82-ecb2ded5c03a",
            "version": "KqlParameterItem/1.0",
            "name": "IsConnectionDataExists",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('template1','template0', 'azure_maintenance','azure_sys')\r\n| where State !=\"\"\r\n| count\r\n| extend conndata = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project conndata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "13493d5d-94fa-4d7b-b2e4-d0093df962a8",
            "version": "KqlParameterItem/1.0",
            "name": "HighMemoryQueries",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n |extend Mean_memory_blks=(SharedBlksHit + SharedBlksDirtied)/Calls\r\n| summarize Max_blks = max(Mean_memory_blks) by QueryId\r\n|where Max_blks >0\r\n| count\r\n    | extend HaveQueryIds = iff(Count > 0, \"Yes\", \"No\")\r\n    | project HaveQueryIds",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "d1b7e82d-16bc-4de0-aadb-93a70f3926a0",
            "version": "KqlParameterItem/1.0",
            "name": "existsLongRunningSessionsData",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| extend Connection_duration_sec = datetime_diff('second',CollectionTime,BackendStartTime)\r\n//| summarize  Connection_duration_sec=max(Connection_duration_sec)  by Pid_d,Backend_type_s\r\n|limit 5\r\n| count\r\n| extend result=iff(Count>0, 'Yes','No')\r\n| project result\r\n",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "fa1e16b1-ea89-4893-b72d-f4353dee75d5",
            "version": "KqlParameterItem/1.0",
            "name": "IsPostgreSQLServerLogsDataExists",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"disconnection\"\r\n| distinct TimeGenerated,Timestamp,Message\r\n| extend DisconnectTime=todatetime(Timestamp)\r\n| extend allmatches=extract_all(@'session.time:(.+)user=(.+)database=(.+)host=(.+).port', Message)\r\n| extend duration=totime(allmatches[0][0])\r\n| extend user=trim(@\" \",tostring(allmatches[0][1]) )\r\n| extend database=tostring(allmatches[0][2])\r\n| extend IP=tostring(allmatches[0][3])\r\n| where user !in ('azuresu','replication')\r\n| count\r\n| extend logsdata = iff((Count) >= 1 , \"Yes\", \"No\")\r\n| project logsdata",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          },
          {
            "id": "57585acd-67fe-4f6a-b5da-0e1fd3565a3a",
            "version": "KqlParameterItem/1.0",
            "name": "long_idle_sessions_check",
            "type": 1,
            "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('hour',CollectionTime,todatetime(BackendStartTime))\r\n   | summarize Connection_duration_sec=max(Connection_duration_sec),arg_max(TimeGenerated,lastState=State) by ProcessId,BackendStartTime, BackendType\r\n | where Connection_duration_sec > {long_idle_sessions_threshold_hour}\r\n| count\r\n| extend result = iff(Count>0, 'Yes', 'No')\r\n| project result",
            "crossComponentResources": [
              "{Resource}"
            ],
            "queryType": 0,
            "resourceType": "microsoft.dbforpostgresql/flexibleservers"
          }
        ],
        "style": "pills",
        "queryType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
      },
      "conditionalVisibility": {
        "parameterName": "x",
        "comparison": "isEqualTo",
        "value": "y"
      },
      "name": "high memory log parameters"
    },
    {
      "type": 1,
      "content": {
        "json": "### Memory configuration: parameter value change detected!\r\n\r\nWeve observed that the memory parameters have been set to values higher than their default settings. These changes can impact system performance. Please check if there's an increase in server memory usage after these modifications.\r\n\r\nHere is the list of parameters that have been changed: **{validate_memory_parameters} **\r\n\r\nAltering these parameters should be done with caution. For best practices on parameter configuration, refer to the **\"Memory parameters\"** tab in this troubleshooting guide.\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "validate_memory_parameters",
          "comparison": "isNotEqualTo",
          "value": "No"
        }
      ],
      "name": "Memory parameters default value infomation"
    },
    {
      "type": 1,
      "content": {
        "json": "### Long idle session detected!\r\n\r\nOur monitoring system has detected a PostgreSQL session that has been idle and connected to the server for **more than {long_idle_sessions_threshold_hour} hours**. Long-idle sessions can consume valuable system resources and potentially impact overall server performance.\r\n\r\nWe strongly recommend you to **review your PostgreSQL sessions** and **terminate any idle sessions that have been connected for an extended period**. Efficient session management is key to maintaining optimal performance in a PostgreSQL environment.\r\n\r\nPlease follow these best practices:\r\n1. **Identify long-idle sessions**: Use PostgreSQL system catalogs or administration tools to identify any sessions that have been idle for an extended period.\r\n2. **Terminate idle sessions**: If a session is idle and has been connected for more than {long_idle_sessions_threshold_hour} hours, consider terminating it to free up system resources.\r\n3. **Review your application logic**: If your application often leaves sessions idle for extended periods, it might be a good idea to review your application logic to prevent this from happening.\r\n4. **Implement idle session timeout settings**: For PostgreSQL 14 and above, consider implementing `idle_session_timeout` settings in your PostgreSQL configuration to automatically terminate sessions after a certain period of inactivity.\r\n\r\n",
        "style": "warning"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "long_idle_sessions_check",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "long idle sessions warning"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "tabStyle": "bigger",
        "links": [
          {
            "id": "3a72e467-cf2f-49e6-b558-b9b73d820e20",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Memory",
            "subTarget": "memory",
            "style": "link"
          },
          {
            "id": "b1510460-7e36-4b34-aa90-afcce4e1a471",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Workload",
            "subTarget": "workload",
            "style": "link"
          },
          {
            "id": "32e2433c-1be0-44a8-b79b-7beeefbe3eae",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Sessions",
            "subTarget": "sessions",
            "style": "link"
          },
          {
            "id": "d04fe585-6a68-4c91-bd8b-e8ea28d18ab3",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Queries",
            "subTarget": "querystore",
            "style": "link"
          },
          {
            "id": "b9d67896-ede2-4ac2-8133-c8afab0790f6",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "User connections",
            "subTarget": "connections",
            "style": "link"
          },
          {
            "id": "58d38541-e497-4712-a357-b0a46464f881",
            "cellValue": "tab",
            "linkTarget": "parameter",
            "linkLabel": "Memory parameters",
            "subTarget": "guidelines",
            "style": "link"
          }
        ]
      },
      "name": "high memory tabs"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high memory existslongrunningsessionsdata check"
          },
          {
            "type": 1,
            "content": {
              "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "existsLongRunningSessionsData",
                "comparison": "isEqualTo",
                "value": ""
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              }
            ],
            "name": "high memory existslongrunningsessionsdataandloganalytics checkno "
          },
          {
            "type": 1,
            "content": {
              "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "existsLongRunningSessionsData",
                "comparison": "isEqualTo",
                "value": ""
              },
              {
                "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high memory existslongrunningsessionsdataandloganalytics checkyes "
          },
          {
            "type": 1,
            "content": {
              "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
              "style": "warning"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "existsLongRunningSessionsData",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "LessThanOneHourInterval",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high memory existslongrunningsessionsdata timeinterval "
          },
          {
            "type": 9,
            "content": {
              "version": "KqlParameterItem/1.0",
              "parameters": [
                {
                  "id": "98d4f3a7-4057-400a-a84f-cbd61df98051",
                  "version": "KqlParameterItem/1.0",
                  "name": "TopQueries",
                  "label": "Maximum processes",
                  "type": 2,
                  "isRequired": true,
                  "typeSettings": {
                    "additionalResourceOptions": [],
                    "showDefault": false
                  },
                  "jsonData": "[\r\n { \"value\":\"10\", \"label\":\"10\",\"selected\":true },\r\n  { \"value\":\"20\", \"label\":\"20\" },\r\n    { \"value\":\"30\", \"label\":\"30\" },\r\n     { \"value\":\"40\", \"label\":\"40\" },\r\n  { \"value\":\"50\", \"label\":\"50\" }\r\n]",
                  "timeContext": {
                    "durationMs": 86400000
                  }
                }
              ],
              "style": "pills",
              "queryType": 0,
              "resourceType": "microsoft.operationalinsights/workspaces"
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory topqueries"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime\r\n| extend Connection_duration_sec = datetime_diff('millisecond',CollectionTime,todatetime(BackendStartTime)), Query_duration_ms = datetime_diff('millisecond',CollectionTime,QueryStartTime),  Transaction_duration_ms=datetime_diff('millisecond',CollectionTime,TransactionStartTime)\r\n   | summarize Connection_duration_sec=max(Connection_duration_sec), Transaction_duration_ms=max(Transaction_duration_ms),  Query_duration_ms=max(Query_duration_ms),arg_max(TimeGenerated,lastState=State) by ProcessId,BackendStartTime, BackendType\r\n  | order by Connection_duration_sec desc, ProcessId asc\r\n  | limit {TopQueries}",
              "size": 1,
              "aggregation": 2,
              "title": "Top {TopQueries} process identifiers (PIDs) by connection duration. Blue - connection duration; Green - query duration. The state shown in the tile is the last state from telemetry snapshot, historically the state could have changed multiple times.",
              "noDataMessage": "No data available during the period selected",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "tiles",
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "ProcessId",
                  "formatter": 1,
                  "numberFormat": {
                    "unit": 0,
                    "options": {
                      "style": "decimal",
                      "useGrouping": false
                    }
                  }
                },
                "subtitleContent": {
                  "columnMatch": "lastState",
                  "formatter": 1,
                  "formatOptions": {
                    "compositeBarSettings": {
                      "labelText": "",
                      "columnSettings": []
                    }
                  }
                },
                "leftContent": {
                  "columnMatch": "Connection_duration_sec",
                  "formatter": 3,
                  "formatOptions": {
                    "palette": "blue"
                  },
                  "numberFormat": {
                    "unit": 23,
                    "options": {
                      "style": "decimal",
                      "useGrouping": false,
                      "maximumFractionDigits": 2
                    }
                  },
                  "tooltipFormat": {
                    "tooltip": "{1}"
                  }
                },
                "rightContent": {
                  "columnMatch": "Query_duration_ms",
                  "formatter": 3,
                  "formatOptions": {
                    "palette": "green"
                  },
                  "numberFormat": {
                    "unit": 23,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  },
                  "tooltipFormat": {
                    "tooltip": "Query Duration"
                  }
                },
                "secondaryContent": {
                  "columnMatch": "BackendType",
                  "formatter": 1
                },
                "showBorder": true,
                "sortCriteriaField": "Connection_duration_sec",
                "sortOrderField": 2,
                "size": "auto"
              },
              "graphSettings": {
                "type": 0,
                "topContent": {
                  "columnMatch": "Session_duration",
                  "formatter": 1
                },
                "centerContent": {
                  "columnMatch": "Pid",
                  "formatter": 1,
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                }
              },
              "chartSettings": {
                "showLegend": true,
                "xSettings": {
                  "numberFormatSettings": {
                    "unit": 0,
                    "options": {
                      "style": "decimal",
                      "useGrouping": true
                    }
                  }
                },
                "ySettings": {
                  "numberFormatSettings": {
                    "unit": 24,
                    "options": {
                      "style": "decimal",
                      "useGrouping": false
                    }
                  }
                }
              }
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions"
          },
          {
            "type": 1,
            "content": {
              "json": "## Statistics on long running sessions\r\n\r\nNote:\r\n\r\n* Connection duration **(blue)** - Duration of session or connection `(collection_time - backend_start)`. You will notice higher value if you are using connection pool.\r\n* Query duration **(yellow)** - Duration of query `(collection_time - query_start)`. This should be in expected range of query execution time.\r\n\r\nLong running transactions are identified through the information provided by the pg_stat_activity view in PostgreSQL. If you want to know more about the semantics of these columns, please refer to the [official documentation](https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW).",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions warning"
          },
          {
            "type": 9,
            "content": {
              "version": "KqlParameterItem/1.0",
              "crossComponentResources": [
                "{Resource}"
              ],
              "parameters": [
                {
                  "id": "e4b37b70-1891-4de7-b916-349a7ad5ae25",
                  "version": "KqlParameterItem/1.0",
                  "name": "SessionPid",
                  "label": "Show snapshot of PID",
                  "type": 2,
                  "isRequired": true,
                  "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,CollectionTime\r\n| extend Connection_duration_sec = datetime_diff('Millisecond',CollectionTime,BackendStartTime)\r\n| summarize  Connection_duration_sec=max(Connection_duration_sec)  by ProcessId,BackendStartTime\r\n| order by Connection_duration_sec desc, ProcessId asc\r\n| limit {TopQueries}\r\n| extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n| project uniquePidkeys,ProcessId\r\n| serialize Rank = row_number()\r\n| project value = uniquePidkeys, label = strcat(' ', ProcessId), selected = iff(Rank == 1, true, false)",
                  "crossComponentResources": [
                    "{Resource}"
                  ],
                  "typeSettings": {
                    "additionalResourceOptions": [],
                    "showDefault": false
                  },
                  "queryType": 0,
                  "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                }
              ],
              "style": "pills",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers"
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions pid snapshot"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n|  distinct TimeGenerated,ProcessId,BackendStartTime,BackendType,State,CollectionTime,QueryStartTime,TransactionStartTime,StateChangeTime,DatabaseId,DatabaseName,UserId,ClientIpAddress\r\n| extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n| where uniquePidkeys =='{SessionPid}'\r\n| extend Connection_Duration=iff(CollectionTime-BackendStartTime<time(00:00:00.00),0, datetime_diff('millisecond',CollectionTime,BackendStartTime))\r\n| extend StateLastChanged_ms=iff(CollectionTime-StateChangeTime<time(00:00:00.00),0, datetime_diff('millisecond',CollectionTime,StateChangeTime))\r\n| extend Xact_duration_ms=iff(CollectionTime-TransactionStartTime<time(00:00:00.00), datetime_diff('millisecond',TransactionStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,TransactionStartTime))\r\n| extend Query_duration_ms=iff(CollectionTime-QueryStartTime<time(00:00:00.00),datetime_diff('millisecond',QueryStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,QueryStartTime))\r\n| extend dummy_row=1\r\n| summarize max(Connection_Duration), max(Query_duration_ms), max(Xact_duration_ms),sum(dummy_row) by ProcessId,BackendStartTime, DatabaseId, DatabaseName, UserId, ClientIpAddress, BackendType\r\n| project ['process identifier'] = ProcessId, ['backend type'] = BackendType, ['database identifier'] = DatabaseId, ['database'] = DatabaseName, ['user identifier'] = UserId, ['client ip address'] = ClientIpAddress, ['backend start time'] = BackendStartTime, ['connection duration'] = max_Connection_Duration, ['longest transaction duration'] = max_Xact_duration_ms, ['longest query duration'] = max_Query_duration_ms, ['sampled data points'] = sum_dummy_row",
              "size": 4,
              "title": "Summary as of {GlobalEndTime} UTC",
              "noDataMessage": "No data available during the period selected",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "backend start time",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "connection duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "longest transaction duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "longest query duration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ]
              }
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions wrap up query"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| distinct TimeGenerated,ProcessId, BackendStartTime,State\r\n    | extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n    | where uniquePidkeys =='{SessionPid}'\r\n| extend workingState=iff(State in ('active','idle','idle in transaction','idle in transaction (aborted)'), State, 'other')\r\n| summarize count() by State=workingState",
              "size": 4,
              "title": "Overall state of the process (PID) for the period analyzed. Data is sampled each 5 minutes.",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "piechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Backend_start",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "TotalConnectionDuration",
                    "formatter": 1,
                    "numberFormat": {
                      "unit": 24,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "LongestTransactionDuration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "LongestQueryDuration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ]
              },
              "sortBy": [],
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "Pid",
                  "formatter": 1
                },
                "subtitleContent": {
                  "columnMatch": "Backend_start",
                  "formatter": 6,
                  "dateFormat": {
                    "showUtcTime": null,
                    "formatName": "fullDateTimePattern"
                  }
                },
                "leftContent": {
                  "columnMatch": "Database_name",
                  "formatter": 1
                },
                "showBorder": false
              },
              "graphSettings": {
                "type": 0,
                "topContent": {
                  "columnMatch": "Backend_start",
                  "formatter": 1
                },
                "centerContent": {
                  "columnMatch": "Pid",
                  "formatter": 1,
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                }
              },
              "chartSettings": {
                "showLegend": true
              }
            },
            "customWidth": "50",
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions history query"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| distinct TimeGenerated, ProcessId, BackendStartTime,WaitEventType,WaitEvent\r\n    | extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n    | where uniquePidkeys =='{SessionPid}'\r\n|  summarize count() by WaitEventType,WaitEvent\r\n|project iff(isempty(WaitEventType),'No Waits',strcat(WaitEventType,':',WaitEvent)),count_",
              "size": 4,
              "title": "Overall wait events of the process (PID) for the period analyzed. Data is sampled each 5 minutes.",
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "visualization": "piechart",
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "Backend_start",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "TotalConnectionDuration",
                    "formatter": 1,
                    "numberFormat": {
                      "unit": 24,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "LongestTransactionDuration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "LongestQueryDuration",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ]
              },
              "sortBy": [],
              "tileSettings": {
                "titleContent": {
                  "columnMatch": "Pid",
                  "formatter": 1
                },
                "subtitleContent": {
                  "columnMatch": "Backend_start",
                  "formatter": 6,
                  "dateFormat": {
                    "showUtcTime": null,
                    "formatName": "fullDateTimePattern"
                  }
                },
                "leftContent": {
                  "columnMatch": "Database_name",
                  "formatter": 1
                },
                "showBorder": false
              },
              "graphSettings": {
                "type": 0,
                "topContent": {
                  "columnMatch": "Backend_start",
                  "formatter": 1
                },
                "centerContent": {
                  "columnMatch": "Pid",
                  "formatter": 1,
                  "numberFormat": {
                    "unit": 17,
                    "options": {
                      "maximumSignificantDigits": 3,
                      "maximumFractionDigits": 2
                    }
                  }
                }
              },
              "chartSettings": {
                "showLegend": true
              }
            },
            "customWidth": "50",
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions waitevents"
          },
          {
            "type": 3,
            "content": {
              "version": "KqlItem/1.0",
              "query": " \r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_sys','azure_maintenance')\r\n| distinct TimeGenerated,ProcessId, CollectionTime, ApplicationName , State, WaitEventType , WaitEvent , TransactionId , OldestTransactionId,BackendStartTime,StateChangeTime,TransactionStartTime,QueryStartTime\r\n    | extend uniquePidkeys=strcat(ProcessId,'-',BackendStartTime)\r\n    | where uniquePidkeys =='{SessionPid}'\r\n| extend Connection_Duration=iff(CollectionTime-BackendStartTime<time(00:00:00.00),datetime_diff('second',BackendStartTime,CollectionTime), datetime_diff('second',CollectionTime,BackendStartTime))\r\n| extend StateLastChanged_ms=iff(CollectionTime-StateChangeTime<time(00:00:00.00),datetime_diff('millisecond',StateChangeTime,CollectionTime), datetime_diff('millisecond',CollectionTime,StateChangeTime))\r\n| extend Xact_duration_ms=iff(CollectionTime-TransactionStartTime<time(00:00:00.00),datetime_diff('millisecond',TransactionStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,TransactionStartTime))\r\n| extend Query_duration_ms=iff(CollectionTime-QueryStartTime<time(00:00:00.00),datetime_diff('millisecond',QueryStartTime,CollectionTime), datetime_diff('millisecond',CollectionTime,QueryStartTime))\r\n| project ProcessId, CollectionTime, ApplicationName , Connection_Duration,Query_duration_ms,Xact_duration_ms,StateLastChanged_ms, State, WaitEventType , WaitEvent , TransactionId , OldestTransactionId \r\n| order by Connection_Duration asc \r\n| serialize \r\n| extend rn=row_number()\r\n| extend prev_Application=(prev(ApplicationName,1))\r\n| extend prev_State=(prev(State,1))\r\n| extend prev_Waitevtype=(prev(WaitEventType,1))\r\n| extend prev_Waitev=(prev(WaitEvent,1))\r\n| extend prev_xid=(prev(TransactionId,1))\r\n| extend prev_xmin=(prev(OldestTransactionId,1))\r\n| extend isApp_change=iff( rn>1 and ApplicationName != prev_Application,1,0)\r\n| extend isState_change=iff( rn>1 and State != prev_State,1,0)\r\n| extend isWaitevtype_change=iff( rn>1 and WaitEventType != prev_Waitevtype,1,0)\r\n| extend isWaitev_change=iff( rn>1 and WaitEvent != prev_Waitev,1,0)\r\n| extend isxid_change=iff( rn>1 and TransactionId != prev_xid,1,0)\r\n| extend isxmin_change=iff( rn>1 and OldestTransactionId != prev_xmin,1,0)\r\n| extend breakPoint=iff (isApp_change>0 or isState_change>0 or isWaitevtype_change>0 or isWaitev_change>0 or isxid_change>0 or isxmin_change>0, 0, rn)\r\n| project CollectionTime,ProcessId,ApplicationName,Connection_Duration, State, prev_State, WaitEvent, prev_Waitev, WaitEventType, prev_Waitevtype, rn, breakPoint,TransactionId , OldestTransactionId,Xact_duration_ms,StateLastChanged_ms\r\n| scan with_match_id=change_id declare (TheRank: long) with \r\n(\r\n    step buildRank: true => TheRank = iff(isnull(buildRank.TheRank), rn, buildRank.TheRank);\r\n    step endRank output=none: breakPoint==0;\r\n)\r\n| summarize min(Connection_Duration),max(Connection_Duration),min(CollectionTime),max(CollectionTime), SampledCounter=count(), max(Xact_duration_ms), avg(Xact_duration_ms), max(StateLastChanged_ms)  by change_id, ApplicationName, State,WaitEvent,WaitEventType,ProcessId, TransactionId , OldestTransactionId\r\n| extend WaitEvent=iff(isempty(WaitEventType),'No Waits',strcat(WaitEventType,':',WaitEvent))\r\n| project ['process identifier'] = ProcessId, ['from'] = min_CollectionTime, ['to'] = max_CollectionTime, ['from connection start'] = min_Connection_Duration, ['application name'] = ApplicationName, ['state'] = State, ['wait event'] = WaitEvent, ['transaction identifier'] = TransactionId, ['oldest transaction identifier'] = OldestTransactionId, ['maximum transaction time'] = max_Xact_duration_ms, ['sampled data points'] = SampledCounter",
              "size": 0,
              "title": "Full history of the process (PID) for the period analyzed",
              "showExportToExcel": true,
              "queryType": 0,
              "resourceType": "microsoft.dbforpostgresql/flexibleservers",
              "crossComponentResources": [
                "{Resource}"
              ],
              "gridSettings": {
                "formatters": [
                  {
                    "columnMatch": "from",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "to",
                    "formatter": 6
                  },
                  {
                    "columnMatch": "from connection start",
                    "formatter": 19,
                    "formatOptions": {
                      "palette": "blue",
                      "timelineSettings": {
                        "timelineStartColumn": "from connection start"
                      }
                    },
                    "numberFormat": {
                      "unit": 24,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "maximum transaction time",
                    "formatter": 1,
                    "numberFormat": {
                      "unit": 23,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  },
                  {
                    "columnMatch": "from connection start",
                    "formatter": 0,
                    "numberFormat": {
                      "unit": 24,
                      "options": {
                        "style": "decimal"
                      }
                    }
                  }
                ],
                "rowLimit": 10000,
                "filter": true
              },
              "sortBy": []
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions rank query"
          },
          {
            "type": 1,
            "content": {
              "json": "**Recommendations**\r\n\r\n* As a long term approach, consider leveraging [index tuning](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-index-tuning) feature to get index recommendations that would optimize your workload.\r\nYou can also use EXPLAIN ANALYZE to manually tune the queries identified from the above PIDs.\r\nMore information on EXPLAIN command can be found [here](https://www.postgresql.org/docs/current/sql-explain.html).\r\n\r\n\r\n* As a short term option you can terminate or cancel the sessions by executing below commands:\r\n\r\nFrom the PIDs retrieved above, execute the following query on the server, to terminate the session:\r\n\r\n\tSELECT pg_terminate_backend(<pid>);\r\n\r\nYou can also cancel the running queries by executing the following query:\r\n\r\n\tselect pg_cancel_backend(<pid>); \r\n\r\n* Sessions that run for a prolonged period of time can use up a significant amount of CPU and RAM. Therefore, it is recommended to configure server parameters such as `statement_timeout`, `idle_session_timeout` (only available from version 14 of PostgreSQL), or `idle_in_transaction_session_timeout` to terminate such long running sessions. This will prevent unnecessary consumption of system resources and help maintain server performance.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "existsLongRunningSessionsData",
              "comparison": "isEqualTo",
              "value": "Yes"
            },
            "name": "high memory long running sessions recommendationsy"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibility": {
        "parameterName": "tab",
        "comparison": "isEqualTo",
        "value": "sessions"
      },
      "name": "high memory long running sessions recommendationsn"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "HighMemoryQueries",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high memory query store nodata"
          },
          {
            "type": 1,
            "content": {
              "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "HighMemoryQueries",
                "comparison": "isEqualTo",
                "value": ""
              },
              {
                "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "No"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isNotEqualTo",
                "value": "No"
              }
            ],
            "name": "high memory query store loganalytics warning"
          },
          {
            "type": 1,
            "content": {
              "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
              "style": "info"
            },
            "conditionalVisibilities": [
              {
                "parameterName": "HighMemoryQueries",
                "comparison": "isEqualTo",
                "value": ""
              },
              {
                "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high memory query store loganalytics and highmemqueries"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 9,
                  "content": {
                    "version": "KqlParameterItem/1.0",
                    "parameters": [
                      {
                        "id": "98d4f3a7-4057-400a-a84f-cbd61df98051",
                        "version": "KqlParameterItem/1.0",
                        "name": "TopTimeConsumingQueries",
                        "label": "Maximum queries",
                        "type": 2,
                        "isRequired": true,
                        "typeSettings": {
                          "additionalResourceOptions": [],
                          "showDefault": false
                        },
                        "jsonData": "[\r\n { \"value\":\"5\", \"label\":\"5\",\"selected\":true },\r\n  { \"value\":\"10\", \"label\":\"10\" },\r\n    { \"value\":\"20\", \"label\":\"20\" }\r\n]",
                        "timeContext": {
                          "durationMs": 86400000
                        }
                      }
                    ],
                    "style": "pills",
                    "queryType": 0,
                    "resourceType": "microsoft.operationalinsights/workspaces"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store maxcount"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "**Selected interval is too small. A one hour capture from the selected end time is being shown.**",
                    "style": "warning"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "LessThanOneHourInterval",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store timeiterval"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graphgrain=iff({TimeRange:grain}<15m,15m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet TopQueryIDs = \r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n|extend Mean_memory_blks=(SharedBlksHit + SharedBlksDirtied)/Calls\r\n| summarize Max_blks = max(Mean_memory_blks) by QueryId, Resource \r\n| where Max_blks>0\r\n| top {TopTimeConsumingQueries} by Max_blks desc\r\n| project QueryId;\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd            \r\n| where QueryId in (TopQueryIDs)\r\n|extend Mean_memory_blks=(SharedBlksHit + SharedBlksDirtied)/Calls\r\n| extend  EVENT_TIME_GRAPHGRAIN = bin(todatetime(EndTime), 1m)\r\n| make-series maxmemorytime=max(Mean_memory_blks*8) default=0 on EVENT_TIME_GRAPHGRAIN from TimeStart to TimeEnd step graphgrain by QueryId=strcat('QueryId ',QueryId)",
                    "size": 0,
                    "aggregation": 2,
                    "title": "Top {TopTimeConsumingQueries} queries by data usage. Data is plotted at a granularity of {ChartGrain}",
                    "noDataMessage": "No data available during the period selected",
                    "noDataMessageStyle": 4,
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "areachart",
                    "chartSettings": {
                      "showLegend": true,
                      "ySettings": {
                        "numberFormatSettings": {
                          "unit": 3,
                          "options": {
                            "style": "decimal",
                            "useGrouping": true
                          }
                        }
                      }
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store metric"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "**Shown above are the top {TopTimeConsumingQueries} queries by data usage for the period analyzed. ** \r\n\r\nThese queries have the largest sum of `shared_blks_hit` and `shared_blks_dirtied` in that period.\r\n\r\nThe counter indicates how many blocks were pinned through the execution process. It could happen that a page from memory was pinned multiple times, hence the total data processed by the given query can be multiple times higher than the value of `shared_buffers` or total memory.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store warning"
                },
                {
                  "type": 9,
                  "content": {
                    "version": "KqlParameterItem/1.0",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "parameters": [
                      {
                        "id": "98d4f3a7-4057-400a-a84f-cbd61df98051",
                        "version": "KqlParameterItem/1.0",
                        "name": "QueryIdsByTime",
                        "label": "Snapshot for query id",
                        "type": 2,
                        "isRequired": true,
                        "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where todatetime(EndTime) >= Start_Time and todatetime(EndTime) <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| extend Mean_memory_blks=(SharedBlksHit + SharedBlksDirtied)/Calls\r\n| summarize Max_blks = max(Mean_memory_blks) by QueryId\r\n| where Max_blks>0\r\n| top {TopTimeConsumingQueries} by Max_blks desc\r\n| serialize Rank = row_number()\r\n| project value = QueryId, label = QueryId, selected = iff(Rank == 1, true, false)",
                        "crossComponentResources": [
                          "{Resource}"
                        ],
                        "typeSettings": {
                          "additionalResourceOptions": [],
                          "showDefault": false
                        },
                        "queryType": 0,
                        "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                      }
                    ],
                    "style": "pills",
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store queryid snapshot"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where EndTime >= TimeStart and EndTime <= TimeEnd\r\n| where UserId != 10 // exclude azure super user \r\n| where QueryId == {QueryIdsByTime}\r\n| distinct MeanExecDurationMs,MaxExecDurationMs,MinExecDurationMs,Calls,QueryId,QueryType,Rows,TotalExecDurationMs,StartTime,EndTime,PlanId,DatabaseId,UserId,SharedBlksHit,SharedBlksDirtied,RuntimeStatsEntryId\r\n| extend Total_Memory_blks_hit=(SharedBlksHit + SharedBlksDirtied)*8\r\n| extend Mean_Memory_blks_hit=Total_Memory_blks_hit/Calls         \r\n| summarize ['mean execution time'] = avg(MeanExecDurationMs), ['mean data usage'] = avg(Mean_Memory_blks_hit), ['maximum execution time'] = max(MaxExecDurationMs), ['maximum data usage'] = max(Mean_Memory_blks_hit),  ['total calls'] = sum(Calls), ['total data usage'] = sum(Total_Memory_blks_hit) by QueryId, QueryType\r\n| project-rename ['query identifier'] = QueryId, ['query type'] = QueryType",
                    "size": 4,
                    "title": "Summary for query with identifier {QueryIdsByTime} for the period analyzed",
                    "noDataMessage": "No data available during the period selected",
                    "noDataMessageStyle": 4,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "mean execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "mean data usage",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "maximum execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "maximum data usage",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "total calls",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "green"
                          }
                        },
                        {
                          "columnMatch": "total data usage",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "query identifier",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "query type",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "minimum execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        }
                      ],
                      "rowLimit": 10000
                    },
                    "sortBy": []
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "detail high mem"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "letgraphgrain=iff({TimeRange:grain}<15m,15m,{TimeRange:grain});\r\nlet TimeStart = todatetime('{GlobalStartTime}');\r\nlet TimeEnd = todatetime('{GlobalEndTime}');\r\nlet databasename = \r\n{SessionsTable}\r\n|distinct DatabaseName,DatabaseId;\r\n{QueryStoreTable}\r\n    | where EndTime >= TimeStart and EndTime <= TimeEnd\r\n    | where UserId != 10  \r\n    | where QueryId == {QueryIdsByTime}\r\n    | distinct MeanExecDurationMs,MaxExecDurationMs,MinExecDurationMs,Calls,QueryId,QueryType,Rows,TotalExecDurationMs,StartTime,EndTime,PlanId,DatabaseId,UserId,SharedBlksHit,SharedBlksDirtied\r\n    | extend Total_Memory_blks_hit=(SharedBlksHit + SharedBlksDirtied)*8\r\n    | extend Mean_Memory_blks_hit=Total_Memory_blks_hit/Calls         \r\n    | summarize WindowStart=min(StartTime), WindowEnd=max(EndTime),MeanRows=sum(Rows)/sum(Calls), MeanDataUsage=avg(Mean_Memory_blks_hit), MeanExecutionTime=avg(MeanExecDurationMs), MinDataUsage=min(Mean_Memory_blks_hit),MaxDataUsage=max(Mean_Memory_blks_hit), TotalCalls=sum(Calls),TotalDataUsage=sum(Total_Memory_blks_hit), TotalRows=sum(Rows),MinExecutionTime=min(MinExecDurationMs),MaxExecutionTime=max(MaxExecDurationMs),TotalExecutionTime=sum(TotalExecDurationMs) by bin(todatetime(EndTime), graphgrain), QueryId, QueryType, PlanId,DatabaseId,UserId\r\n| join kind = leftouter databasename on $left.DatabaseId == $right.DatabaseId\r\n| project ['query identifier'] = QueryId, ['query type'] = QueryType, ['plan identifier'] = PlanId, ['database'] = iff(isempty(DatabaseName), strcat('oid::', DatabaseId), DatabaseName), ['user identifier'] = UserId, ['window start'] = WindowStart, ['window end'] = WindowEnd, ['mean rows'] = MeanRows, ['mean data usage'] = MeanDataUsage, ['mean execution time'] = MeanExecutionTime, ['minimum data usage'] = MinDataUsage, ['maximum data usage'] = MaxDataUsage, ['total calls'] = TotalCalls, ['total data usage'] = TotalDataUsage, ['total rows'] = TotalRows, ['minimum execution time'] = MinExecutionTime, ['maximum execution time'] = MaxExecutionTime, ['total execution time'] = TotalExecutionTime\r\n| order by ['window start'] asc",
                    "size": 0,
                    "title": "Runtime statistics for query identifier {QueryIdsByTime} split by time buckets of {ChartGrain}",
                    "noDataMessage": "No data available during the period selected",
                    "noDataMessageStyle": 4,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "window start",
                          "formatter": 6
                        },
                        {
                          "columnMatch": "window end",
                          "formatter": 6
                        },
                        {
                          "columnMatch": "total rows",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          }
                        },
                        {
                          "columnMatch": "mean data usage",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "mean execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "minimum data usage",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "maximum data usage",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "total calls",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          }
                        },
                        {
                          "columnMatch": "total data usage",
                          "formatter": 8,
                          "formatOptions": {
                            "palette": "blue"
                          },
                          "numberFormat": {
                            "unit": 3,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "minimum execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "maxium execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "total execution time",
                          "formatter": 0,
                          "numberFormat": {
                            "unit": 23,
                            "options": {
                              "style": "decimal"
                            }
                          }
                        },
                        {
                          "columnMatch": "query identifier",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "query type",
                          "formatter": 1
                        }
                      ],
                      "rowLimit": 10000,
                      "filter": true,
                      "sortBy": [
                        {
                          "itemKey": "window start",
                          "sortOrder": 1
                        }
                      ]
                    },
                    "sortBy": [
                      {
                        "itemKey": "window start",
                        "sortOrder": 1
                      }
                    ]
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store top queries history"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "** Shown above data usage for the given QueryId and TimeRange. **\r\n\r\n**MeanDataUsage**: The mean (average) data processed by the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd<br>\r\n**MinDataUsage**: The minimum data processed by the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd<br>\r\n**MaxDataUsage**: The maximum data processed by the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd<br>\r\n**TotalDataUsage**: Total data processed by the QueryId for all the calls in the time bucket defined between WindowStart and WindowEnd<br>\r\n\r\n**MeanRows**: The mean (average) rows retrieved or affected by the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd<br>\r\n**TotalRows**: Total rows retrieved or affected by the QueryId for all the calls in the time bucket defined between WindowStart and WindowEnd<br>\r\n\r\n**MeanExecutionTime**: The mean (average) execution time of the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd<br>\r\n**MinExecutionTime**: The minimum execution time of the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd <br>\r\n**MaxExecutionTime**: The maximum execution time of the QueryId in a single call across the time bucket defined between WindowStart and WindowEnd <br>\r\n**TotalExecutionTime**: The total execution time of the QueryId for all the calls in the time bucket defined between WindowStart and WindowEnd <br>",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store top queries history commentery"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "**How can you retrieve the text for a specific query, given its query identifier?**\r\n\r\nTo retrieve the text for a specific query, you need to follow these steps:\r\n\r\n1. Connect to the server using the **`azure_sys`** database, in which Query Store persists the information it collects. For example, you can use the following command:\r\n```SQL\r\npsql -h <server_name>.postgres.database.azure.com -U <admin_user_name> -d azure_sys\r\n```\r\n\r\n2. Use the generated `query text` column to retrieve the text of the query associated with the query identifier.\r\n\r\nIt is important to note that the retention period for Query Store applies when querying the database, and older data gets deleted based on the server parameter `pg_qs.retention_period_in_days`. However, our telemetry has a higher retention period.\r\n\r\n**To retrieve the text of the query for a given query identifier, use the following SQL:**",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store querytext recommendation"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": " let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{QueryStoreTable}\r\n| where todatetime(EndTime) >= Start_Time and todatetime(EndTime) <= End_Time\r\n| where UserId != 10 // exclude azure super user \r\n| extend Mean_memory_blks=(SharedBlksHit + SharedBlksDirtied)/Calls\r\n| summarize Max_blks = max(Mean_memory_blks) by QueryId, Resource \r\n| where Max_blks>0\r\n| top {TopTimeConsumingQueries} by Max_blks desc\r\n    | extend GetQueryText = strcat(\"SELECT query_sql_text FROM query_store.query_texts_view WHERE query_text_id=\",QueryId,\";\")\r\n    | project ['query text'] = GetQueryText ",
                    "size": 1,
                    "title": "Get text of the queries from their query identifiers",
                    "noDataMessage": "No data available during the period selected",
                    "noDataMessageStyle": 4,
                    "showExportToExcel": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "gridSettings": {
                      "rowLimit": 10000
                    }
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store querytext output"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "**General recommendations to tune high data usage queries:**\r\n\r\n1) As a long term approach, consider leveraging [index tuning](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-index-tuning) feature to get index recommendations that would optimize your workload.\r\n\r\n2) You can also use EXPLAIN ANALYZE to manually tune the queries identified above. More information on EXPLAIN command can be found [here](https://www.postgresql.org/docs/current/sql-explain.html). \r\n\r\n3) High bloat on the tables can also lead to considerable IO & CPU utilization. As a one off case consider carrying manual vacuum analyze of the tables used in the slow running queries using the below command on the database:\r\n\r\n\tVACUUM (ANALYZE, VERBOSE) <table_name> \r\n\r\n4) Indexes and joins: Consider creating indexes and reduce the joins in the query, if applicable.\r\n\r\n4) Indexes and joins: Consider creating indexes and reduce the joins in the query, if applicable.\r\n\r\n5) Consider tuning server parameters like `shared_buffers`, `work_mem`, `maintenance_work_mem`, `max_locks_per_transaction`, and `max_parallel_workers_per_gather`. Please, make the changes with caution and testing as setting a very high value of these parameters could lead to higher memory consumption.\r\n\r\n6) Consider upgrading to a higher SKU or from the General Purpose to the Memory Optimized tier, if the workload is more memory-intensive. This can help alleviate memory constraints and improve query performance.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "isQueryStoreEnabled",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "HighMemoryQueries",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsServerPrimaryCheck",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory query store recom"
                }
              ],
              "exportParameters": true
            },
            "conditionalVisibilities": [
              {
                "parameterName": "isQueryStoreEnabled",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsServerPrimaryCheck",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "IsQueryStoreRuntimeSentToLogAnalytics",
                "comparison": "isEqualTo",
                "value": "Yes"
              },
              {
                "parameterName": "HighMemoryQueries",
                "comparison": "isEqualTo",
                "value": "Yes"
              }
            ],
            "name": "high memory query store recommendations"
          },
          {
            "type": 1,
            "content": {
              "json": "### The Query Store's capabilities are not functioning on the replica server.\r\n#### After analysis, we have determined that this server is a replica server, which means that the query store functionality is not available. However, there are alternative methods you can use to monitor long-running sessions on the replica server.\r\n- To help pinpoint possible performance issues, a recommended solution is to adjust the `log_min_duration_statement` parameter to the desired threshold and properly configure `log_line_prefix` to include the relevant details such as **%t-%c user=%u,db=%d,app=%a,client=%h**. This will enable the logging of slow queries in the PostgreSQL logs. By doing so, you can easily access the top queries and review the slow queries that may require optimization.\r\n- Another option is to configure `pg_stat_statements`, which allows you to view information about your query performance on the replica server. However, Please keep in mind that you need to execute the `CREATE EXTENSION pg_stat_statements` command on the primary server database. For more informaiton, please visit [PostgreSQL Documentation](https://www.postgresql.org/docs/current/pgstatstatements.html).\r\n- You can also monitor the ongoing workload on the replica server by using the `pg_stat_activity` catalog view.",
              "style": "info"
            },
            "conditionalVisibility": {
              "parameterName": "IsServerPrimaryCheck",
              "comparison": "isEqualTo",
              "value": "No"
            },
            "name": "high memory query store replica"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibility": {
        "parameterName": "tab",
        "comparison": "isEqualTo",
        "value": "querystore"
      },
      "name": "high memory query store datausage tab "
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 11,
            "content": {
              "version": "LinkItem/1.0",
              "style": "tabs",
              "links": [
                {
                  "id": "ce889247-43cd-4b4b-affb-b0753d5173ee",
                  "cellValue": "conn-tab",
                  "linkTarget": "parameter",
                  "linkLabel": "Connections by state",
                  "subTarget": "state",
                  "style": "link"
                },
                {
                  "id": "cb78e5e9-2ef1-4f4c-832f-6ddc98ae5c6f",
                  "cellValue": "conn-tab",
                  "linkTarget": "parameter",
                  "linkLabel": "Connections by duration",
                  "subTarget": "duration",
                  "style": "link"
                }
              ]
            },
            "name": "high memory connections tab"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "**Selected interval is too small. A one hour capture from the selected End Time is being shown.**",
                    "style": "warning"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "LessThanOneHourInterval",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsConnectionDataExists",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory connections time interval"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsConnectionDataExists",
                    "comparison": "isEqualTo",
                    "value": "No"
                  },
                  "name": "high memory connections nodata"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "IsConnectionDataExists",
                      "comparison": "isEqualTo",
                      "value": ""
                    },
                    {
                      "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                      "comparison": "isEqualTo",
                      "value": "No"
                    }
                  ],
                  "name": "high memory connections nodata log analytics no"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "IsConnectionDataExists",
                      "comparison": "isEqualTo",
                      "value": ""
                    },
                    {
                      "parameterName": "IsPostgreSQLFlexSessionsSentToLogAnalytics",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory connections nodata log analytics yes"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let graph_grain=iff({TimeRange:grain}<5m,5m,{TimeRange:grain});\r\nlet Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{SessionsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where UserId != 10\r\n| where isnotempty(DatabaseId) and DatabaseName !in('azure_maintenance','azure_sys')\r\n| where State !=\"\"\r\n|distinct TimeGenerated,BackendStartTime,ProcessId,State\r\n|summarize count_state=count() by bin(TimeGenerated,1m),State\r\n| make-series max_count= max(count_state) on TimeGenerated from Start_Time to End_Time step graph_grain by State",
                    "size": 0,
                    "aggregation": 2,
                    "showAnnotations": true,
                    "title": "Summary of connections by state. Data is plotted at a granularity of {ChartGrainMin5}",
                    "noDataMessage": "No data found in given time range",
                    "noDataMessageStyle": 4,
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "timechart",
                    "chartSettings": {
                      "showLegend": true
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsConnectionDataExists",
                    "comparison": "isEqualTo",
                    "value": "Yes"
                  },
                  "name": "high memory connections summary by state"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "### **Dealing with high number of connections**\r\n\r\nIf you are experiencing a high number of connections on your PostgreSQL database, consider following these recommendations:\r\n\r\n\r\n#### **Adjust server parameters**\r\n\r\nSet the `statement_timeout`, `idle_in_transaction_session_timeout` and `idle_session_timeout` (only available from version 14 of PostgreSQL) server parameters to appropriate values. These can help manage connections and prevent idle connections from consuming resources.\r\n\r\nFor more information, refer to [Connection handling best practices with PostgreSQL](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/connection-handling-best-practice-with-postgresql/ba-p/790883).\r\n\r\n#### **Consider using connection pooling**\r\n\r\nIn situations where there are a lot of idle connections or connections that are consuming CPU resources, consider using a connection pooler like PgBouncer.\r\n\r\nFor more details on PgBouncer and how it works, check out this reference on [connection pooler](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/not-all-postgres-connection-pooling-is-equal/ba-p/825717).\r\n\r\n##### **Set up PgBouncer**\r\n\r\nIf you're using Azure database for Flexible Server, you can take advantage of PgBouncer as a built-in connection pooling solution. For more information on how to set it up, see this resource: [PgBouncer in Azure database for PostgreSQL Flexible Server](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-pgbouncer).\r\n\r\n##### **Recommended settings for PgBouncer on Flexible Server**\r\n\r\n##### **Pool mode (`pool_mode`):**\r\n- `Transaction` pool mode is generally considered to be the most suitable mode for higher TPS scenarios, as it provides a new connection for each transaction and releases the connection immediately after the transaction is complete. This approach can help reduce connection overhead and improve performance, especially for systems with a high number of short-lived transactions.\r\n- In `session` pool mode, a client is assigned a server connection for the entire duration of its connection, and the connection is returned to the pool when the client disconnects. This approach can help reduce the overhead of establishing new connections, which can be beneficial for systems with a high number of relatively long-lived connections. Also, This mode supports all PostgreSQL features.\r\n\r\n**Pool size (`default_pool_size`):** Adjust the size of the pool based on your workload. Note that this setting is per user/database pair.\r\n\r\n**Timeouts:** To ensure that idle connections are closed and long running queries are terminated, set the `server_idle_timeout` and `query_timeout` parameters according to your workload needs.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsConnectionDataExists",
                    "comparison": "isEqualTo",
                    "value": "Yes"
                  },
                  "name": "high memory connections recommendations"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "conn-tab",
              "comparison": "isEqualTo",
              "value": "state"
            },
            "name": "State"
          },
          {
            "type": 12,
            "content": {
              "version": "NotebookGroup/1.0",
              "groupType": "editable",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "This chart shows the count of connections categorized by their duration: **short** (less than 1 second), **normal** (between 1 second and 20 minutes), and **long** (greater than 20 minutes). These are calculated using disconnection messages extracted from PostgreSQL logs.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsPostgreSQLServerLogsDataExists",
                    "comparison": "isEqualTo",
                    "value": "Yes"
                  },
                  "name": "high memory connections by duration warning"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "**Selected interval is too small. A one hour capture from the selected End Time is being shown.**",
                    "style": "warning"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "LessThanOneHourInterval",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    },
                    {
                      "parameterName": "IsPostgreSQLServerLogsDataExists",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory connections by duration time interval"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsPostgreSQLServerLogsDataExists",
                    "comparison": "isEqualTo",
                    "value": "No"
                  },
                  "name": "high memory connections by duration loganalytics no"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "#### The selected window does not contain any data in the telemetry. To configure logging and address this issue, please refer to the error message located at the top of the troubleshooting guide.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "IsPostgreSQLServerLogsDataExists",
                      "comparison": "isEqualTo",
                      "value": ""
                    },
                    {
                      "parameterName": "IsPostgreSQLLogsSentToLogAnalytics",
                      "comparison": "isEqualTo",
                      "value": "No"
                    }
                  ],
                  "name": "high memory connections by duration loganalytics no data exists no"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "#### There is no data available in the telemetry for the chosen window. Maybe you have recently configured logging for the server. If so, kindly allow up to 30 minutes for the telemetry data to become visible.",
                    "style": "info"
                  },
                  "conditionalVisibilities": [
                    {
                      "parameterName": "IsPostgreSQLServerLogsDataExists",
                      "comparison": "isEqualTo",
                      "value": ""
                    },
                    {
                      "parameterName": "IsPostgreSQLLogsSentToLogAnalytics",
                      "comparison": "isEqualTo",
                      "value": "Yes"
                    }
                  ],
                  "name": "high memory connections by duration loganalytics yes data exists no"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let Start_Time = todatetime('{GlobalStartTime}');\r\nlet End_Time = todatetime('{GlobalEndTime}');\r\n{PGServerLogsTable}\r\n| where TimeGenerated >= Start_Time and TimeGenerated <= End_Time\r\n| where Message contains \"disconnection\"\r\n| distinct TimeGenerated,Timestamp,Message\r\n| extend DisconnectTime=todatetime(Timestamp)\r\n| extend allmatches=extract_all(@'session.time:(.+)user=(.+)database=(.+)host=(.+).port', Message)\r\n| extend duration=totime(allmatches[0][0])\r\n| extend user=trim(@\" \",tostring(allmatches[0][1]) )\r\n| extend database=tostring(allmatches[0][2])\r\n| extend IP=tostring(allmatches[0][3])\r\n| where  user !in ('azuresu','replication')\r\n| extend ts = totimespan(duration)\r\n| extend DurationInSeconds = ts / 1s\r\n| extend ConnType=iff(    DurationInSeconds <= 60, 'short' ,     iff(DurationInSeconds > 60 and DurationInSeconds < 1200, 'normal','long'))\r\n| make-series Connections=count() default=0 on DisconnectTime from Start_Time to End_Time step {TimeRange:grain} by ConnType",
                    "size": 0,
                    "aggregation": 2,
                    "title": "Summary of connections by duration",
                    "noDataMessage": "No data found in given time range",
                    "noDataMessageStyle": 4,
                    "timeBrushParameterName": "TimeRange",
                    "timeBrushExportOnlyWhenBrushed": true,
                    "queryType": 0,
                    "resourceType": "microsoft.dbforpostgresql/flexibleservers",
                    "crossComponentResources": [
                      "{Resource}"
                    ],
                    "visualization": "linechart",
                    "chartSettings": {
                      "showLegend": true,
                      "seriesLabelSettings": [
                        {
                          "seriesName": "long",
                          "color": "blueDark"
                        },
                        {
                          "seriesName": "normal",
                          "color": "blue"
                        },
                        {
                          "seriesName": "short",
                          "color": "redBright"
                        }
                      ]
                    }
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsPostgreSQLServerLogsDataExists",
                    "comparison": "isEqualTo",
                    "value": "Yes"
                  },
                  "name": "high memory connections by duration query"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "### **Dealing with high number of connections**\r\n\r\nIf you are experiencing a high number of connections on your PostgreSQL database, consider following these recommendations:\r\n\r\n\r\n#### **Adjust server parameters**\r\n\r\nSet the `statement_timeout`, `idle_in_transaction_session_timeout` and `idle_session_timeout` (only available from version 14 of PostgreSQL) server parameters to appropriate values. These can help manage connections and prevent idle connections from consuming resources.\r\n\r\nFor more information, refer to [Connection handling best practices with PostgreSQL](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/connection-handling-best-practice-with-postgresql/ba-p/790883).\r\n\r\n#### **Consider using connection pooling**\r\n\r\nIn situations where there are a lot of idle connections or connections that are consuming CPU resources, consider using a connection pooler like PgBouncer.\r\n\r\nFor more details on PgBouncer and how it works, check out this reference on [connection pooler](https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/not-all-postgres-connection-pooling-is-equal/ba-p/825717).\r\n\r\n##### **Set up PgBouncer**\r\n\r\nIf you're using Azure database for Flexible Server, you can take advantage of PgBouncer as a built-in connection pooling solution. For more information on how to set it up, see this resource: [PgBouncer in Azure database for PostgreSQL Flexible Server](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-pgbouncer).\r\n\r\n##### **Recommended settings for PgBouncer on Flexible Server**\r\n\r\n##### **Pool mode (`pool_mode`):**\r\n- `Transaction` pool mode is generally considered to be the most suitable mode for higher TPS scenarios, as it provides a new connection for each transaction and releases the connection immediately after the transaction is complete. This approach can help reduce connection overhead and improve performance, especially for systems with a high number of short-lived transactions.\r\n- In `session` pool mode, a client is assigned a server connection for the entire duration of its connection, and the connection is returned to the pool when the client disconnects. This approach can help reduce the overhead of establishing new connections, which can be beneficial for systems with a high number of relatively long-lived connections. Also, This mode supports all PostgreSQL features.\r\n\r\n**Pool size (`default_pool_size`):** Adjust the size of the pool based on your workload. Note that this setting is per user/database pair.\r\n\r\n**Timeouts:** To ensure that idle connections are closed and long running queries are terminated, set the `server_idle_timeout` and `query_timeout` parameters according to your workload needs.",
                    "style": "info"
                  },
                  "conditionalVisibility": {
                    "parameterName": "IsPostgreSQLServerLogsDataExists",
                    "comparison": "isEqualTo",
                    "value": "Yes"
                  },
                  "showPin": false,
                  "name": "high memory connections by duration recommendation"
                }
              ]
            },
            "conditionalVisibility": {
              "parameterName": "conn-tab",
              "comparison": "isEqualTo",
              "value": "duration"
            },
            "name": "high memory connections conn-tab"
          }
        ],
        "exportParameters": true
      },
      "conditionalVisibility": {
        "parameterName": "tab",
        "comparison": "isEqualTo",
        "value": "connections"
      },
      "name": "high memory TotalConnections"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook7f70739f-94e7-4a64-8af6-494380041c21",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Saturation-memory_percent",
            "aggregation": 3
          }
        ],
        "title": "Maximum percentage of memory in use",
        "showCreateAlertRule": true,
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibility": {
        "parameterName": "tab",
        "comparison": "isEqualTo",
        "value": "memory"
      },
      "name": "high memory maximum percentage of memory metric"
    },
    {
      "type": 1,
      "content": {
        "json": "#### PostgreSQL can use high memory in various scenarios, including:\r\n\r\n- **Large amounts of data:** As the amount of data stored in a database increases, the memory required to access and manipulate that data also increases. If your database contains many tables or large tables with many columns, this can consume a lot of memory. To find more information, please refer to the `Workload` tab in this troubleshooting guide.\r\n\r\n- **Large transactions:** Transactions that modify many rows or tables can consume a significant amount of memory, especially if the changes involve indexes or triggers. If the transaction is not committed or rolled back in a timely manner, it can keep locks and buffers in memory, causing high memory usage. To find more information, please refer to the `Sessions` tab in this troubleshooting guide.\r\n\r\n- **Complex queries:** Queries that involve multiple joins, subqueries, or aggregates can require significant amounts of memory to execute. If these queries are not optimized or tuned correctly, they can consume excessive memory. To find more information, please refer to the `Queries` tab.\r\n\r\n- **Concurrent connections:** If your application has many concurrent connections to the database, each connection will consume a certain amount of memory. Improper management of connections can lead to high memory usage. To find more information, please refer to the `User connections` tab in this troubleshooting guide.\r\n\r\nTo manage memory usage in PostgreSQL, it is important to properly configure server parameters, optimize queries, and monitor the system's memory usage.",
        "style": "info"
      },
      "conditionalVisibility": {
        "parameterName": "tab",
        "comparison": "isEqualTo",
        "value": "memory"
      },
      "name": "high memory maximum percentage of memory recommendation"
    },
    {
      "type": 1,
      "content": {
        "json": "### Enhanced metrics are currently disabled.\r\nThis Troubleshooting guide requires the use of enhanced metrics. To activate these metrics, simply enable the dynamic server parameter `metrics.collector_database_activity`.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory enhanced metrics disabled workload related"
    },
    {
      "type": 11,
      "content": {
        "version": "LinkItem/1.0",
        "style": "tabs",
        "links": [
          {
            "id": "bbd1eb36-7b53-4cf3-9eb3-b7d578ac6f69",
            "cellValue": "child-tab",
            "linkTarget": "parameter",
            "linkLabel": "Read workload",
            "subTarget": "readworkload",
            "style": "link"
          },
          {
            "id": "8269efc0-6814-4c74-b446-b6197ce51d5b",
            "cellValue": "child-tab",
            "linkTarget": "parameter",
            "linkLabel": "Write workload",
            "subTarget": "writeworkload",
            "style": "link"
          }
        ]
      },
      "conditionalVisibilities": [
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high memory workload tab"
    },
    {
      "type": 1,
      "content": {
        "json": "#### Write workload details are not available for replica servers.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "No"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        },
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        }
      ],
      "name": "high memory workload - readreplica"
    },
    {
      "type": 1,
      "content": {
        "json": "## Read workload details\r\n\r\n**tup_fetched** and **tup_returned** are two metrics that measure the number of rows read from a table.\r\n\r\n**tup_returned** represents the number of live rows fetched by sequential scans and index entries returned by index scans in this database.\r\n\r\n**tup_fetched** measures the number of live rows fetched by index scans in this database.\r\n\r\nBy monitoring these two metrics, you can gain a better understanding of the performance of your PostgreSQL read workloads.",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory workload readtext"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookb945890e-3384-4f08-8518-0515c1c5b144",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_fetched",
            "aggregation": 1,
            "columnName": "Tuples Fetched"
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_returned",
            "aggregation": 1,
            "columnName": "Tuples Returned"
          }
        ],
        "title": "Read workload metrics",
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "3",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory read workload details"
    },
    {
      "type": 1,
      "content": {
        "json": "**The read workload metric calculates the total number of tuples fetched and returned for all databases, except for system databases like `azure_sys` and `azure_maintenance`.**",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory readworkload warning"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookb945890e-3384-4f08-8518-0515c1c5b144",
        "version": "MetricsItem/2.0",
        "size": 1,
        "chartType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_fetched",
            "aggregation": 1,
            "splitBy": "DatabaseName",
            "splitBySortOrder": -1,
            "splitByLimit": 50
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_returned",
            "aggregation": 1,
            "splitBy": "DatabaseName",
            "splitBySortOrder": -1,
            "splitByLimit": 50
          }
        ],
        "title": "Tuples (rows) fetched and returned by database",
        "gridFormatType": 2,
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "showRefreshButton": true,
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "Subscription",
              "formatter": 5
            },
            {
              "columnMatch": "Name",
              "formatter": 5,
              "formatOptions": {
                "linkTarget": "Resource"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_fetched",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_returned",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": ".*\\/Tuples Returned$",
              "formatter": 1
            },
            {
              "columnMatch": "Tuples Returned Timeline",
              "formatter": 5
            },
            {
              "columnMatch": "Tuples Returned",
              "formatter": 1,
              "numberFormat": {
                "unit": 0,
                "options": null
              }
            },
            {
              "columnMatch": "Metric",
              "formatter": 1
            },
            {
              "columnMatch": "Aggregation",
              "formatter": 5
            },
            {
              "columnMatch": "Value",
              "formatter": 1
            }
          ],
          "rowLimit": 10000,
          "labelSettings": [
            {
              "columnId": "Segment",
              "label": "database"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_fetched",
              "label": "fetched (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_fetched Timeline",
              "label": "fetched (sum) [timeline]"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_returned",
              "label": "returned (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_returned Timeline",
              "label": "returned (sum) [timeline]"
            }
          ]
        },
        "sortBy": [],
        "showExportToExcel": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "readworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory readload metric"
    },
    {
      "type": 1,
      "content": {
        "json": "## Write workload details\r\nThe number of tuples that have been inserted, updated, or deleted are critical for understanding the overall performance of the database and for identifying potential inefficiencies.\r\n\r\n\r\nBy monitoring these metrics, you can gain insights into the performance of your PostgreSQL write workloads and make data-driven decisions to optimize the database.\r\n\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory writeload info"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbook5576f52a-daae-4bd6-8b6e-333f5de05ac1",
        "version": "MetricsItem/2.0",
        "size": 0,
        "chartType": 2,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_inserted",
            "aggregation": 1,
            "columnName": "inserted"
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_updated",
            "aggregation": 1,
            "columnName": "updated"
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_deleted",
            "aggregation": 1,
            "columnName": "deleted"
          }
        ],
        "title": "Write workload metrics",
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "2",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "gridSettings": {
          "rowLimit": 10000
        }
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory write workload metric"
    },
    {
      "type": 1,
      "content": {
        "json": "**The write workload metric calculates the total number of tuples inserted, updated, and deleted for all databases, except for system databases like `azure_sys` and `azure_maintenance`.**\r\n\r\n",
        "style": "info"
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory write workload warning"
    },
    {
      "type": 10,
      "content": {
        "chartId": "workbookb945890e-3384-4f08-8518-0515c1c5b144",
        "version": "MetricsItem/2.0",
        "size": 1,
        "chartType": 0,
        "resourceType": "microsoft.dbforpostgresql/flexibleservers",
        "metricScope": 0,
        "resourceParameter": "Resource",
        "resourceIds": [
          "{Resource}"
        ],
        "timeContextFromParameter": "TimeRange",
        "timeContext": {
          "durationMs": 2419200000
        },
        "metrics": [
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_inserted",
            "aggregation": 1,
            "splitBy": "DatabaseName",
            "splitBySortOrder": -1,
            "splitByLimit": 50
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_updated",
            "aggregation": 1,
            "splitBy": "DatabaseName",
            "splitBySortOrder": -1,
            "splitByLimit": 50
          },
          {
            "namespace": "microsoft.dbforpostgresql/flexibleservers",
            "metric": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_deleted",
            "aggregation": 1,
            "splitBy": "DatabaseName",
            "splitBySortOrder": -1,
            "splitByLimit": 50
          }
        ],
        "title": "Tuples (rows) inserted, updated and deleted by database",
        "gridFormatType": 2,
        "showCreateAlertRule": true,
        "filters": [
          {
            "id": "1",
            "key": "DatabaseName",
            "operator": 1,
            "values": [
              "azure_maintenance",
              "azure_sys"
            ]
          }
        ],
        "timeBrushParameterName": "TimeRange",
        "timeBrushExportOnlyWhenBrushed": true,
        "showRefreshButton": true,
        "gridSettings": {
          "formatters": [
            {
              "columnMatch": "Subscription",
              "formatter": 5
            },
            {
              "columnMatch": "Name",
              "formatter": 5,
              "formatOptions": {
                "linkTarget": "Resource"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_inserted",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "Timeline",
              "formatter": 21,
              "formatOptions": {
                "palette": "blue"
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_updated",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_deleted",
              "formatter": 1,
              "numberFormat": {
                "unit": 17,
                "options": {
                  "style": "decimal"
                }
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_fetched",
              "formatter": 1,
              "numberFormat": {
                "unit": 0,
                "options": null
              }
            },
            {
              "columnMatch": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_returned",
              "formatter": 1,
              "numberFormat": {
                "unit": 0,
                "options": null
              }
            },
            {
              "columnMatch": ".*\\/Tuples Returned$",
              "formatter": 1
            },
            {
              "columnMatch": "Tuples Returned Timeline",
              "formatter": 5
            },
            {
              "columnMatch": "Tuples Returned",
              "formatter": 1,
              "numberFormat": {
                "unit": 0,
                "options": null
              }
            },
            {
              "columnMatch": "Metric",
              "formatter": 1
            },
            {
              "columnMatch": "Aggregation",
              "formatter": 5
            },
            {
              "columnMatch": "Value",
              "formatter": 1
            }
          ],
          "rowLimit": 10000,
          "labelSettings": [
            {
              "columnId": "Segment",
              "label": "database"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_inserted",
              "label": "inserted (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_inserted Timeline",
              "label": "inserted (sum) [timeline]"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_updated",
              "label": "updated (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_updated Timeline",
              "label": "updated (sum) [timeline]"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_deleted",
              "label": "deleted (sum)"
            },
            {
              "columnId": "microsoft.dbforpostgresql/flexibleservers-Database (Preview)-tup_deleted Timeline",
              "label": "deleted (sum) [timeline]"
            }
          ]
        },
        "sortBy": [],
        "showExportToExcel": true
      },
      "conditionalVisibilities": [
        {
          "parameterName": "IsMetricCollectorON",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "IsServerPrimaryCheck",
          "comparison": "isEqualTo",
          "value": "Yes"
        },
        {
          "parameterName": "child-tab",
          "comparison": "isEqualTo",
          "value": "writeworkload"
        },
        {
          "parameterName": "tab",
          "comparison": "isEqualTo",
          "value": "workload"
        }
      ],
      "name": "high memory write workload Tup_fetched by Database"
    },
    {
      "type": 12,
      "content": {
        "version": "NotebookGroup/1.0",
        "groupType": "editable",
        "items": [
          {
            "type": 1,
            "content": {
              "json": "#### work_mem\r\n\r\nThe `work_mem` parameter is an important setting that determines the amount of memory allocated for internal sort and hash query operations before data is written to temporary disk files. Unlike some other parameters, `work_mem` is not set on a per-query basis, but rather dynamically adjusted based on the number and complexity of sorting and hash operations that are being performed.\r\n\r\nFor workloads that involve many short-running queries with simple joins and minimal sorting, it is advisable to keep `work_mem` at a lower value. However, if there are a few active queries with complex joins and sorts, a higher value for `work_mem` may be more appropriate. Setting the value of `work_mem` correctly can be a challenge, but if you notice high memory usage or out-of-memory errors, reducing `work_mem` may be necessary.\r\n\r\nA good rule of thumb for setting `work_mem` is to use the formula **work_mem = total RAM / max_connections / 16**. This can provide a safer starting point for adjusting the parameter.\r\n\r\nBy default, `work_mem` is set to 4 MB, but it can be customized at various levels, including at the server level via the parameters page in the Azure portal. It is recommended to monitor memory consumption during peak times, and gradually increase `work_mem` if disk sorts are occurring if there is unused memory. Conversely, if memory usage is high, decreasing `work_mem` may be necessary to achieve a better balance between available and used memory.",
              "style": "info"
            },
            "name": "high memory parameter guideance - work mem"
          },
          {
            "type": 1,
            "content": {
              "json": "#### maintenance_work_mem\r\n\r\nMaintenance tasks such as vacuuming, creating indexes or reindexing existing indexes, and foreign key insertion require a dedicated memory allocation whose size is controlled through the parameter called `maintenance_work_mem`. This memory usage is specific to each session.\r\n\r\nFor instance, suppose there are three autovacuum workers running simultaneously. In that case, a `maintenance_work_mem` value of 1 GB will result in a total memory usage of 3 GB across all sessions.\r\n\r\nHence, it's important to note that setting a high `maintenance_work_mem` value coupled with multiple concurrent sessions performing maintenance tasks can result in excessive memory usage. In Azure Database for PostgreSQL Flexible Server, the maximum permissible value for the `maintenance_work_mem` server parameter is 2 GB.",
              "style": "info"
            },
            "name": "high memory parameter guideance - maintenance work mem"
          },
          {
            "type": 1,
            "content": {
              "json": "#### shared_buffers\r\n\r\nThe `shared_buffers` server parameter specifies the amount of memory allocated by the server to cache data, with the aim of minimizing disk I/O.\r\n\r\nIt's generally recommended to allocate around 25% of available RAM to `shared_buffers`, although the maximum permissible value can be set to 75% of available RAM. This helps to ensure efficient use of memory resources and optimal performance.\r\n\r\nBy utilizing `shared_buffers` to cache frequently accessed data, the server can significantly reduce the amount of I/O operations needed to fetch data from disk, resulting in faster query processing times and improved overall system performance. However, it's important to balance the allocation of memory resources between `shared_buffers` and other system components to prevent excessive memory usage and potential performance issues.",
              "style": "info"
            },
            "name": "high memory parameter guideance - shared buffers"
          },
          {
            "type": 1,
            "content": {
              "json": "#### max_locks_per_transaction\r\n\r\nThe `max_locks_per_transaction` parameter controls the maximum number of database objects that can be locked concurrently during a single transaction. By default, this value is set to 64.\r\n\r\nIncreasing the value of `max_locks_per_transaction` may result in higher memory consumption on the server, which can potentially impact system performance. It's important to carefully consider the appropriate value for this parameter based on the specific requirements of your application.\r\n\r\nFurthermore, modifying the value of `max_locks_per_transaction` requires a restart of the database server. As such, it's essential to plan any changes to this parameter carefully and ensure that they are performed during a maintenance window or other scheduled downtime to minimize disruption to application users.",
              "style": "info"
            },
            "name": "high memory parameter guideance - max locks"
          },
          {
            "type": 1,
            "content": {
              "json": "#### max_connections\r\n\r\nThe `max_connections` parameter specifies the maximum number of concurrent database connections that the server can accept. It's important to set this parameter to a value that is appropriate for the expected workload and usage patterns of your application.\r\n\r\nConfiguring `max_connections` incorrectly can lead to a range of issues, including degraded system performance, connection timeouts, and potential system crashes. To ensure optimal performance and stability, it's essential to review the [documentation](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/concepts-limits) and follow best practices when setting the `max_connections` parameter.",
              "style": "info"
            },
            "name": "high memory parameter guideance - max connections"
          }
        ]
      },
      "conditionalVisibility": {
        "parameterName": "tab",
        "comparison": "isEqualTo",
        "value": "guidelines"
      },
      "name": "high memory parameter guidance"
    }
  ],
  "fallbackResourceIds": [],
  "$schema": "https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json"
}